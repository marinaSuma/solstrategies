import { existsSync } from 'node:fs';
import fs from 'node:fs/promises';
import { homedir } from 'node:os';
import c from 'ansis';
import { join } from 'pathe';
import { searchForWorkspaceRoot } from 'vite';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import DEBUG from 'debug';

const debug = DEBUG("vite:mcp:server");
async function setupRoutes(base, server, vite) {
  const transports = /* @__PURE__ */ new Map();
  vite.middlewares.use(`${base}/sse`, async (req, res) => {
    const transport = new SSEServerTransport(`${base}/messages`, res);
    transports.set(transport.sessionId, transport);
    debug("SSE Connected %s", transport.sessionId);
    res.on("close", () => {
      transports.delete(transport.sessionId);
    });
    await server.connect(transport);
  });
  vite.middlewares.use(`${base}/messages`, async (req, res) => {
    if (req.method !== "POST") {
      res.statusCode = 405;
      res.end("Method Not Allowed");
      return;
    }
    const query = new URLSearchParams(req.url?.split("?").pop() || "");
    const clientId = query.get("sessionId");
    if (!clientId || typeof clientId !== "string") {
      res.statusCode = 400;
      res.end("Bad Request");
      return;
    }
    const transport = transports.get(clientId);
    if (!transport) {
      res.statusCode = 404;
      res.end("Not Found");
      return;
    }
    debug("Message from %s", clientId);
    await transport.handlePostMessage(req, res);
  });
}

const CONSOLE_LOG_PREFIX = c.cyan.bold`[MCP] `;
function ViteMcp(options = {}) {
  const {
    printUrl = true,
    mcpServer = (vite) => import('./chunks/server.mjs').then((m) => m.createMcpServerDefault(options, vite))
  } = options;
  const mcpRoute = options.mcpRouteRoot ?? options.mcpPath ?? "/__mcp";
  return {
    name: "vite-plugin-mcp",
    async configureServer(vite) {
      let mcp = await mcpServer(vite);
      mcp = await options.mcpServerSetup?.(mcp, vite) || mcp;
      await setupRoutes(mcpRoute, mcp, vite);
      const port = vite.config.server.port;
      const root = searchForWorkspaceRoot(vite.config.root);
      const protocol = vite.config.server.https ? "https" : "http";
      const sseUrl = `${protocol}://${options.host || "localhost"}:${options.port || port}${mcpRoute}/sse`;
      if (printUrl) {
        console.log(`${c.cyan`  âžœ MCP:      `}${c.gray(`Mcp server is running at ${c.green(sseUrl)}`)}`);
      }
      await updateConfigs(root, sseUrl, options, vite);
    }
  };
}
async function updateConfigs(root, sseUrl, options, vite) {
  const {
    updateConfig = "auto",
    updateConfigServerName = "vite",
    updateConfigAdditionalServers = []
  } = options;
  if (updateConfig === false)
    return;
  const configs = updateConfig === "auto" ? [
    existsSync(join(root, ".cursor")) ? "cursor" : null,
    existsSync(join(root, ".vscode")) ? "vscode" : null,
    existsSync(join(homedir(), ".codeium", "windsurf")) ? "windsurf" : null,
    existsSync(join(root, ".mcp.json")) ? "claude-code" : null
  ].filter((x) => x !== null) : Array.isArray(updateConfig) ? updateConfig : [];
  if (configs.includes("cursor")) {
    await fs.mkdir(join(root, ".cursor"), { recursive: true });
    const mcp = existsSync(join(root, ".cursor/mcp.json")) ? JSON.parse(await fs.readFile(join(root, ".cursor/mcp.json"), "utf-8") || "{}") : {};
    mcp.mcpServers ||= {};
    mcp.mcpServers[updateConfigServerName || "vite"] = { url: sseUrl };
    for (const server of updateConfigAdditionalServers) {
      mcp.mcpServers[server.name] = { url: server.url };
    }
    await fs.writeFile(join(root, ".cursor/mcp.json"), `${JSON.stringify(mcp, null, 2)}
`);
    vite.config.logger.info(`${CONSOLE_LOG_PREFIX}${c.gray(`Updated config file ${join(root, ".cursor/mcp.json")}`)}`);
  }
  if (configs.includes("vscode")) {
    await fs.mkdir(join(root, ".vscode"), { recursive: true });
    const mcp = existsSync(join(root, ".vscode/mcp.json")) ? JSON.parse(await fs.readFile(join(root, ".vscode/mcp.json"), "utf-8") || "{}") : {};
    mcp.servers ||= {};
    mcp.servers[updateConfigServerName || "vite"] = {
      type: "sse",
      url: sseUrl
    };
    for (const server of updateConfigAdditionalServers) {
      mcp.servers[server.name] = {
        type: "sse",
        url: server.url
      };
    }
    await fs.writeFile(join(root, ".vscode/mcp.json"), `${JSON.stringify(mcp, null, 2)}
`);
    vite.config.logger.info(`${CONSOLE_LOG_PREFIX}${c.gray(`Updated config file ${join(root, ".vscode/mcp.json")}`)}`);
  }
  if (configs.includes("windsurf")) {
    const windsurfDir = join(homedir(), ".codeium", "windsurf");
    const windsurfConfigPath = join(windsurfDir, "mcp_config.json");
    try {
      await fs.mkdir(windsurfDir, { recursive: true });
      const config = existsSync(windsurfConfigPath) ? JSON.parse(await fs.readFile(windsurfConfigPath, "utf-8").catch(() => "{}") || "{}") : {};
      config.mcpServers ||= {};
      config.mcpServers[updateConfigServerName || "vite"] = { serverUrl: sseUrl };
      for (const server of updateConfigAdditionalServers) {
        config.mcpServers[server.name] = { serverUrl: server.url };
      }
      await fs.writeFile(windsurfConfigPath, `${JSON.stringify(config, null, 2)}
`);
      vite.config.logger.info(`${CONSOLE_LOG_PREFIX}${c.gray(`Updated config file ${windsurfConfigPath}`)}`);
    } catch (e) {
      vite.config.logger.error(`${CONSOLE_LOG_PREFIX}${c.red(`Failed to update ${windsurfConfigPath}`)}${e}`);
    }
  }
  if (configs.includes("claude-code")) {
    const mcp = existsSync(join(root, ".mcp.json")) ? JSON.parse(await fs.readFile(join(root, ".mcp.json"), "utf-8") || "{}") : {};
    mcp.mcpServers ||= {};
    mcp.mcpServers[updateConfigServerName || "vite"] = {
      type: "sse",
      url: sseUrl
    };
    for (const server of updateConfigAdditionalServers) {
      mcp.mcpServers[server.name] = {
        type: "sse",
        url: server.url
      };
    }
    await fs.writeFile(join(root, ".mcp.json"), `${JSON.stringify(mcp, null, 2)}
`);
    vite.config.logger.info(`${CONSOLE_LOG_PREFIX}${c.gray(`Updated config file ${join(root, ".mcp.json")}`)}`);
  }
}

export { ViteMcp };
