import { defineNuxtModule, addVitePlugin } from '@nuxt/kit';
import { ViteMcp } from 'vite-plugin-mcp';
import process from 'node:process';
import c from 'ansis';
import { z } from 'zod';

function promptNuxtBasic({ mcp, nuxt }) {
  mcp.prompt("nuxt-basic", () => {
    const lines = [];
    lines.push(`
You are a professional developer specializing in Nuxt and Vue.

This nuxt project is configured with following structure:
- Root directory: ${nuxt.options.rootDir}
- App directory: ${nuxt.options.appDir}
- Source code directory: ${nuxt.options.srcDir}
- Server directory: ${nuxt.options.serverDir}

`);
    if (nuxt.options.ssr) {
      lines.push(`
## SSR

This is a Nuxt 3 application with SSR enabled. Components should be isomorphic and can be executed on both server or client side.

In scenarios where you need different logic for server and client, use \`import.meta.client\` and \`import.meta.server\` 
to branch the code, and use dynamic imports if needed.
`);
    } else {
      lines.push(`
## CSR

This is a Nuxt 3 application with SSR disabled. While components are primarily rendered on the client side, still try to make the code as isomorphic as possible to be future-proof.
`);
    }
    if (nuxt.options.imports.autoImport) {
      lines.push(`
## Auto-imports

This Nuxt project is configured have auto-imports enabled.

For example, Vue apis (ref, computed, watch, etc.) are auto-imported, so you can directly use them in your code without import statements.

You can find the full auto-import items with tool \`list-nuxt-auto-imports-items\`.
`);
    } else {
      lines.push(`
## No auto-imports

This Nuxt project is configured have auto-imports disabled.

You can still reference the registered entries with tool \`list-nuxt-auto-imports-items\`.
But you need to always manually import the usages when modifying the code, either directly import the item from their source, 
or use explicit \`import { xxx } from '#imports'\` to import any items from the registry.
`);
    }
    return {
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: lines.join("\n")
          }
        }
      ]
    };
  });
}

function toolsNuxtRuntime({ mcp, nuxt, unimport }) {
  mcp.tool(
    "get-nuxt-config",
    "Get the Nuxt configuration, including the ssr, appDir, srcDir, rootDir, alias, runtimeConfig, modules, etc.",
    {},
    async () => {
      return {
        content: [{
          type: "text",
          text: JSON.stringify({
            ssr: !!nuxt.options.ssr,
            appDir: nuxt.options.appDir,
            srcDir: nuxt.options.srcDir,
            rootDir: nuxt.options.rootDir,
            alias: nuxt.options.alias,
            runtimeConfig: {
              public: nuxt.options.runtimeConfig.public
            },
            modules: nuxt.options._installedModules.map((i) => i.meta.name || i.name).filter(Boolean),
            imports: {
              autoImport: !!nuxt.options.imports.autoImport,
              ...nuxt.options.imports
            },
            components: nuxt.options.components
          })
        }]
      };
    }
  );
  mcp.tool(
    "list-nuxt-auto-imports-items",
    "List auto-imports items, when importing new functions to the code, check available items from this tool.",
    {},
    async () => {
      return {
        content: [{
          type: "text",
          text: JSON.stringify({
            items: await (await unimport).getImports()
          }, null, 2)
        }]
      };
    }
  );
  let components = [];
  nuxt.hook("components:extend", (_components) => {
    components = _components;
  });
  mcp.tool(
    "list-nuxt-components",
    "List registered components in the Nuxt app. When adding importing new components, check available components from this tool.",
    {},
    async () => {
      return {
        content: [{
          type: "text",
          text: JSON.stringify(components, null, 2)
        }]
      };
    }
  );
  let pages = [];
  nuxt.hook("pages:extend", (_pages) => {
    pages = _pages;
  });
  mcp.tool(
    "list-nuxt-pages",
    "List registered pages and their metadata in the Nuxt app.",
    {},
    async () => {
      return {
        content: [{
          type: "text",
          text: JSON.stringify(pages, null, 2)
        }]
      };
    }
  );
}

function toolsScaffold({ mcp, nuxt }) {
  const setup = async () => {
    const { main } = await import('nuxi');
    const add2 = await (await main.subCommands).add();
    const { runCommand: run } = await import('citty');
    return {
      add: add2,
      run
    };
  };
  const promise = setup();
  async function add(args, options) {
    const { add: add2, run } = await promise;
    return await run(add2, {
      rawArgs: [
        "--cwd",
        nuxt.options.rootDir,
        ...args
      ],
      data: {
        cwd: nuxt.options.rootDir,
        ...options
      }
    }).then((r) => r.result);
  }
  mcp.tool(
    "nuxt-scaffold",
    "Scaffold a new component/page/layout/middleware etc. in the current Nuxt project.",
    {
      // api, app, app-config, component, composable, error, layer, layout, middleware, module, page, plugin, server-middleware, server-plugin, server-route, server-util
      template: z.enum(["api", "app", "app-config", "component", "composable", "error", "layer", "layout", "middleware", "module", "page", "plugin", "server-middleware", "server-plugin", "server-route", "server-util"]).describe("Type of the file to scaffold"),
      name: z.string().describe("Name of the component to add")
    },
    async ({ template, name }) => {
      const { stdout, stderr, result } = await interceptStdout(async () => {
        return await add([
          template,
          name
        ]);
      });
      return {
        content: [{
          type: "text",
          text: JSON.stringify({
            nuxtRoot: nuxt.options.rootDir,
            nuxtSrcDir: nuxt.options.srcDir,
            cliResult: {
              stdout,
              stderr,
              result: String(result) || "OK"
            }
          }, null, 2)
        }]
      };
    }
  );
}
async function interceptStdout(fn) {
  const stdout = [];
  const stderr = [];
  const oldStdout = process.stdout.write;
  const oldStderr = process.stderr.write;
  process.stdout.write = (chunk) => {
    stdout.push(chunk.toString());
    return oldStdout.call(process.stdout, chunk);
  };
  process.stderr.write = (chunk) => {
    stderr.push(chunk.toString());
    return oldStderr.call(process.stderr, chunk);
  };
  try {
    const result = await fn();
    return {
      stdout: c.strip(stdout.join("\n")),
      stderr: c.strip(stderr.join("\n")),
      result
    };
  } finally {
    process.stdout.write = oldStdout;
    process.stderr.write = oldStderr;
  }
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-mcp",
    configKey: "mcp"
  },
  defaults: {
    includeNuxtDocsMcp: true
  },
  async setup(options, nuxt) {
    const unimport = promiseWithResolve();
    const nitro = promiseWithResolve();
    nuxt.hook("imports:context", (_unimport) => {
      unimport.resolve(_unimport);
    });
    nuxt.hook("nitro:init", (_nitro) => {
      nitro.resolve(_nitro);
    });
    addVitePlugin(ViteMcp({
      updateConfigServerName: "nuxt",
      ...options,
      updateConfigAdditionalServers: [
        ...options.updateConfigAdditionalServers || [],
        ...options.includeNuxtDocsMcp ? [{
          name: "nuxt-docs",
          url: "https://mcp.nuxt.com/sse"
        }] : []
      ],
      port: options.port || nuxt.options.devServer.port,
      async mcpServerSetup(mcp, vite) {
        await options.mcpServerSetup?.(mcp, vite);
        const context = {
          unimport: unimport.promise,
          nitro: nitro.promise,
          nuxt,
          vite,
          mcp
        };
        promptNuxtBasic(context);
        toolsNuxtRuntime(context);
        toolsScaffold(context);
        await nuxt.callHook("mcp:setup", context);
      }
    }), { client: true, server: false });
  }
});
function promiseWithResolve() {
  let resolve = void 0;
  const promise = new Promise((_resolve) => {
    resolve = _resolve;
  });
  return { promise, resolve };
}

export { module as default };
