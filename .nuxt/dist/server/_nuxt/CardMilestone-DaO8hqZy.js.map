{"version":3,"file":"CardMilestone-DaO8hqZy.js","sources":["../../../../app/components/button/ButtonIcon.vue","../../../../app/components/motion/MotionSlider.vue","../../../../app/components/card/CardMilestone.vue"],"sourcesContent":["<template>\n  <div class=\"btn-icon\">\n    <span ref=\"elIconWrapper\" class=\"icon-wrapper\">\n      <span ref=\"elIcon\" class=\"icon-inner\"><slot /></span>\n    </span>\n  </div>\n</template>\n\n<script setup>\nconst elIconWrapper = useTemplateRef('elIconWrapper');\nconst elIcon = useTemplateRef('elIcon');\n\nonMounted(() => {\n  const clonedElement = elIcon.value.cloneNode(true);\n  clonedElement.classList.add('is--clone');\n  elIconWrapper.value.appendChild(clonedElement);\n});\n</script>\n\n<style scoped lang=\"scss\">\n.btn-icon {\n  cursor: pointer;\n  user-select: none;\n\n  position: relative;\n\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  width: fn.toVw(48);\n  height: fn.toVw(48);\n  border: 1px solid #d9d9d9;\n  border-radius: fn.toVw(5);\n\n  &::after {\n    content: '';\n\n    position: absolute;\n    z-index: -1;\n    inset: 0;\n    transform: scale(0);\n\n    border-radius: fn.toVw(5);\n\n    background-color: #d9d9d9;\n\n    transition: transform 0.6s $transition-ease;\n  }\n\n  &:hover {\n    &::after {\n      transform: scale(1);\n    }\n\n    :deep(.icon-inner:not(.is--clone)) {\n      transform: translateX(calc(-100% - fn.toVw(6)));\n    }\n\n    :deep(.icon-inner.is--clone) {\n      transform: translateX(0%);\n    }\n  }\n\n  &:deep(.icon-wrapper) {\n    position: relative;\n\n    overflow: hidden;\n    display: inline-block;\n\n    width: fn.toVw(18);\n    height: fn.toVw(18);\n  }\n\n  &:deep(.icon-inner) {\n    display: block;\n    transition: transform $transition-default;\n  }\n\n  &:deep(.icon-inner.is--clone) {\n    position: absolute;\n    inset: 0;\n    transform: translateX(calc(100% + fn.toVw(6)));\n  }\n\n  &:deep(svg) {\n    display: block;\n    width: fn.toVw(18);\n    height: fn.toVw(18);\n  }\n}\n</style>\n","<template>\n  <div ref=\"elContainer\" class=\"section-slider\">\n    <div ref=\"elSlider\" class=\"slider\">\n      <div ref=\"elWrapper\" class=\"slider-wrapper\">\n        <slot />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nconst props = defineProps({\n  desktopEnable: {\n    type: Boolean,\n    default: true,\n  },\n  mobileEnable: {\n    type: Boolean,\n    default: true,\n  },\n  gapDesktop: {\n    type: Number,\n    default: 10,\n  },\n  gapMobile: {\n    type: Number,\n    default: 10,\n  },\n  lerpFactor: {\n    type: Number,\n    default: 0.25,\n  },\n  dragSensitivity: {\n    type: Number,\n    default: 0.8,\n    validator: (value) => value >= 0 && value <= 1,\n  },\n  mobileDragSensitivity: {\n    type: Number,\n    default: 2.5,\n    validator: (value) => value >= 0 && value <= 3,\n  },\n  speedDecay: {\n    type: Number,\n    default: 0.85,\n  },\n  snap: {\n    type: Boolean,\n    default: false,\n  },\n  snapStrength: {\n    type: Number,\n    default: 0.1,\n  },\n  bounceStrength: {\n    type: Number,\n    default: 0,\n  },\n});\n\nconst emit = defineEmits(['progress', 'next', 'prev']);\n\nconst elContainer = ref();\nconst elSlider = ref();\nconst elWrapper = ref();\n\nconst isDragging = ref(false);\nconst dragStart = ref(0);\nconst dragStartTarget = ref(0);\nconst current = ref(0);\nconst target = ref(0);\nconst speed = ref(0);\nconst lspeed = ref(0);\nconst previousTime = ref(0);\nconst deltaTime = ref(0);\nconst maxScroll = ref(0);\nconst touchStartY = ref(0);\nconst isScrollingVertically = ref(false);\nconst dragThreshold = 15; // Increased threshold for better detection\n\nlet touchInitialized = false;\n\nlet tickerFunction;\nlet ctx;\n\nconst getStepWidth = () => {\n  if (!elWrapper.value) return 0;\n  const firstChild = elWrapper.value.children?.[0];\n  if (!(firstChild instanceof HTMLElement)) return 0;\n  const styles = getComputedStyle(elWrapper.value);\n  const gap = parseFloat(styles.columnGap || '0') || 0;\n  return firstChild.offsetWidth + gap;\n};\n\nconst next = () => {\n  const step = getStepWidth();\n  if (step === 0) return;\n  const desired = target.value - step;\n  // Clamp hard to bounds for discrete navigation\n  target.value = gsap.utils.clamp(maxScroll.value, 0, desired);\n  emit('next');\n};\n\nconst prev = () => {\n  const step = getStepWidth();\n  if (step === 0) return;\n  const desired = target.value + step;\n  target.value = gsap.utils.clamp(maxScroll.value, 0, desired);\n  emit('prev');\n};\n\ndefineExpose({ next, prev });\n\nconst calculateBounds = () => {\n  if (!elWrapper.value || !elSlider.value) return;\n\n  const wrapperWidth = elWrapper.value.scrollWidth;\n  const containerWidth = elSlider.value.clientWidth;\n\n  maxScroll.value = wrapperWidth <= containerWidth ? 0 : -(wrapperWidth - containerWidth);\n};\n\nconst applyBounds = (value) => {\n  if (value > 0) {\n    return value * 0.5;\n  } else if (value < maxScroll.value) {\n    return maxScroll.value + (value - maxScroll.value) * 0.5;\n  }\n  return value;\n};\n\nconst snapToBounds = () => {\n  if (target.value > 0) {\n    target.value = 0;\n    speed.value = 0;\n  } else if (target.value < maxScroll.value) {\n    target.value = maxScroll.value;\n    speed.value = 0;\n  }\n};\n\nconst updateAnimation = (time) => {\n  if (!elWrapper.value) return;\n\n  const currentTime = time;\n  deltaTime.value = previousTime.value === 0 ? 0.016 : currentTime - previousTime.value;\n  previousTime.value = currentTime;\n\n  if (isDragging.value) {\n    target.value = applyBounds(target.value);\n  } else {\n    if (target.value > 0) {\n      target.value += (0 - target.value) * props.bounceStrength;\n    } else if (target.value < maxScroll.value) {\n      target.value += (maxScroll.value - target.value) * props.bounceStrength;\n    }\n\n    if (props.snap && !isDragging.value) {\n      const currentSnap = Math.round(target.value);\n      if (currentSnap <= 0 && currentSnap >= maxScroll.value) {\n        const diff = currentSnap - target.value;\n        target.value += diff * props.snapStrength;\n      }\n    }\n  }\n\n  current.value = mathUtils().damp(current.value, target.value, 1 / props.lerpFactor, deltaTime.value);\n  gsap.set(elWrapper.value, { x: current.value });\n\n  // Calculate and emit progress\n  const progress = maxScroll.value === 0 ? 0 : Math.abs(current.value) / Math.abs(maxScroll.value);\n  const clampedProgress = Math.max(0, Math.min(1, progress));\n  emit('progress', clampedProgress);\n\n  lspeed.value = mathUtils().damp(lspeed.value, speed.value, 1 / props.lerpFactor, deltaTime.value);\n  speed.value *= props.speedDecay;\n};\n\nconst handleDragStart = (event) => {\n  isDragging.value = true;\n  dragStart.value = event.clientX || event.touches?.[0]?.clientX || 0;\n  dragStartTarget.value = target.value;\n  if (elWrapper.value) elWrapper.value.style.cursor = 'grabbing';\n};\n\nconst handleDragMove = (event) => {\n  if (!isDragging.value || !elWrapper.value) return;\n\n  const clientX = event.clientX || event.touches?.[0]?.clientX || 0;\n  const deltaX = clientX - dragStart.value;\n\n  // Apply sensitivity in 0-1 range (0 = no movement, 1 = full movement)\n  // Scale the sensitivity to create a natural feeling\n  const sensitivity = gsap.utils.clamp(0, 1, props.dragSensitivity) * 2;\n  target.value = dragStartTarget.value + deltaX * sensitivity;\n\n  if (event.movementX) {\n    // Scale speed based on sensitivity as well\n    speed.value += event.movementX * sensitivity * 0.05;\n  }\n};\n\nconst handleTouchStart = (e) => {\n  // Do not block touch if it's not directly on a draggable element\n  if (!elWrapper.value) return;\n\n  // Record both X and Y positions\n  touchStartY.value = e.touches[0].clientY;\n  dragStart.value = e.touches[0].clientX;\n  dragStartTarget.value = target.value;\n\n  // Reset flags\n  touchInitialized = false;\n  isScrollingVertically.value = false;\n  isDragging.value = false;\n};\n\nconst handleTouchMove = (e) => {\n  if (!elWrapper.value) return;\n\n  // Calculate horizontal and vertical distances\n  const touchCurrentX = e.touches[0].clientX;\n  const touchCurrentY = e.touches[0].clientY;\n  const deltaX = Math.abs(touchCurrentX - dragStart.value);\n  const deltaY = Math.abs(touchCurrentY - touchStartY.value);\n\n  // Only initialize once per touch gesture\n  if (!touchInitialized) {\n    // If clearly moving more horizontally\n    if (deltaX > dragThreshold && deltaX > deltaY * 1.5) {\n      isDragging.value = true;\n      e.preventDefault(); // Now prevent default to enable horizontal dragging\n      elWrapper.value.style.cursor = 'grabbing';\n    }\n    // If clearly moving more vertically\n    else if (deltaY > dragThreshold && deltaY > deltaX * 1.2) {\n      isScrollingVertically.value = true;\n      // Allow regular scrolling behavior\n    }\n\n    // Consider the direction initialized if either condition was met\n    if (isDragging.value || isScrollingVertically.value) {\n      touchInitialized = true;\n    }\n  }\n\n  // If we've determined we're doing horizontal dragging, handle it\n  if (isDragging.value) {\n    e.preventDefault();\n    const clientX = e.touches[0].clientX;\n    const deltaX = clientX - dragStart.value;\n\n    // Apply mobile-specific sensitivity for lighter touch control\n    const sensitivity = props.mobileDragSensitivity;\n    target.value = dragStartTarget.value + deltaX * sensitivity;\n\n    // Use touch velocity for speed with lighter multiplier for mobile\n    const movementX = clientX - (e.touches[0]._lastX || clientX);\n    e.touches[0]._lastX = clientX;\n\n    speed.value += movementX * sensitivity * 0.08;\n  }\n  // Otherwise, let the browser handle vertical scrolling naturally\n};\n\nconst handleDragEnd = () => {\n  isDragging.value = false;\n  isScrollingVertically.value = false;\n  if (elWrapper.value) elWrapper.value.style.cursor = 'grab';\n\n  snapToBounds();\n\n  if (props.snap) {\n    const snappedValue = Math.round(target.value);\n    if (snappedValue <= 0 && snappedValue >= maxScroll.value) {\n      target.value = snappedValue;\n    }\n  }\n};\n\nconst handleResize = () => {\n  calculateBounds();\n\n  if (target.value < maxScroll.value) {\n    target.value = maxScroll.value;\n    current.value = maxScroll.value;\n  }\n};\n\nonMounted(() => {\n  ctx = gsap.context(() => {\n    if ((props.desktopEnable && !IS_MOBILE.value) || (props.mobileEnable && IS_MOBILE.value)) {\n      calculateBounds();\n\n      gsap.set(elWrapper.value, { x: 0 });\n      elWrapper.value.style.cursor = 'grab';\n      // Allow vertical scrolling by default\n      elWrapper.value.style.touchAction = 'pan-y';\n\n      useEventListener(elWrapper, 'mousedown', handleDragStart);\n      useEventListener(window, 'mousemove', handleDragMove);\n      useEventListener(window, 'mouseup', handleDragEnd);\n\n      // Use passive: true for touchstart to allow scrolling\n      useEventListener(elWrapper, 'touchstart', handleTouchStart, { passive: true });\n      // Keep passive: false for touchmove to allow preventDefault in horizontal drag case\n      useEventListener(window, 'touchmove', handleTouchMove, { passive: false });\n      useEventListener(window, 'touchend', handleDragEnd);\n\n      useWindowResize(handleResize);\n\n      previousTime.value = 0;\n      tickerFunction = updateAnimation;\n      gsap.ticker.add(tickerFunction);\n    }\n  }, elContainer.value);\n});\n\nonUnmounted(() => {\n  if (tickerFunction) {\n    gsap.ticker.remove(tickerFunction);\n  }\n  ctx?.revert();\n});\n</script>\n\n<style scoped lang=\"scss\">\n.section-slider {\n  user-select: none;\n  overflow: visible;\n\n  .slider {\n    overflow: visible;\n    display: flex;\n    flex-direction: column;\n\n    .slider-wrapper {\n      will-change: transform;\n\n      display: flex;\n      flex-wrap: nowrap;\n      gap: fn.toVw(v-bind('$props.gapDesktop'));\n\n      width: max-content;\n\n      @include mx.mobile {\n        gap: fn.toVw(v-bind('$props.gapMobile'));\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"card-milestone\">\n    <div v-if=\"props.background\" class=\"bg\">\n      <MediaImg :src=\"props.background\" alt=\"Background of card\" />\n    </div>\n\n    <Text class=\"title\" tag=\"h3\" variant=\"heading1\" data-split data-linereveal>\n      <slot name=\"title\" />\n    </Text>\n\n    <template v-if=\"!props.isDownload\">\n      <Text class=\"desc\" variant=\"body28\" data-split data-linereveal>\n        {{ props.desc }}\n      </Text>\n    </template>\n    <template v-else>\n      <div class=\"desc-wrapper\">\n        <Text class=\"desc\" variant=\"body28\" data-split data-linereveal>\n          {{ props.desc }}\n        </Text>\n\n        <div class=\"download\">\n          <NuxtLink to=\"https://apps.apple.com/us/app/orangefin-solana-staking/id6743318259\" :external=\"true\" target=\"_blank\">\n            <IconGoogleplay class=\"googleplay\" />\n          </NuxtLink>\n          <NuxtLink to=\"https://play.google.com/store/apps/details?id=ventures.orangefin.staking\" :external=\"true\" target=\"_blank\">\n            <IconAppstore class=\"appstore\" />\n          </NuxtLink>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n\n<script setup>\nconst props = defineProps({\n  desc: {\n    type: String,\n  },\n  background: {\n    type: String,\n  },\n  isDownload: {\n    type: Boolean,\n  },\n});\n</script>\n\n<style scoped lang=\"scss\">\n.card-milestone {\n  position: relative;\n\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n\n  width: fn.toVw(506);\n  height: fn.toVw(400);\n  padding: fn.toVw(39);\n  border-radius: fn.toVw(30);\n\n  background-color: #f8f8f8;\n\n  @include mx.mobile {\n    width: fn.toVw(395);\n    height: fn.toVw(313);\n    padding: fn.toVw(30) fn.toVw(15);\n    border-radius: fn.toVw(23);\n  }\n}\n\n.bg {\n  position: absolute;\n  z-index: 1;\n  inset: 0;\n\n  width: 100%;\n  height: 100%;\n}\n\n.title,\n.desc {\n  position: relative;\n  z-index: 2;\n}\n\n.title {\n  width: 100%;\n  max-width: fn.toVw(380);\n  font-weight: 300;\n  line-height: 1;\n\n  @include mx.mobile {\n    font-size: fn.toVw(44);\n  }\n\n  b,\n  &:deep(b) {\n    font-weight: 500;\n  }\n}\n\n.desc {\n  width: 100%;\n  max-width: fn.toVw(280);\n\n  @include mx.mobile {\n    max-width: fn.toVw(200);\n  }\n}\n\n.desc-wrapper {\n  position: relative;\n  z-index: 2;\n\n  display: flex;\n  flex-direction: column;\n  gap: fn.toVw(5.5);\n\n  .download {\n    display: flex;\n    gap: fn.toVw(7);\n\n    &:deep(svg) {\n      height: fn.toVw(37);\n    }\n  }\n}\n</style>\n"],"names":["_ssrRenderAttrs","_mergeProps","gsap","$props","_push","_parent","_renderSlot","_ssrInterpolate","_createTextVNode","_toDisplayString","_ssrRenderComponent","_createVNode"],"mappings":"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"}