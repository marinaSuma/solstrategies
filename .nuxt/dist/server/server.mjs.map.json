{"file":"server.mjs","mappings":";;;;;;;;;;;;;;;;;;;;;AAEA,IAAI,CAAC,WAAW,QAAQ;AACtB,aAAW,SAAS,OAAO,OAAO;AAAA,IAChC,SAAS,QAAO;AAAA,EACpB,CAAG;AACH;ACLA,IAAI,EAAE,YAAY,aAAa;AAC7B,aAAW,SAAS;AACtB;ACOO,MAAM,sBAAsB;AA0C5B,MAAM,mBAAmB,EAAC,iBAAgB,WAA2D;AAUrG,MAAM,QAAQ;AC1Dd,SAAS,cAAc,KAAK,OAAqB;AACtD,SAAO,WAAW,IAAI;AAAA,IACpB,cAAc;AAAA,EAAA,CACf;AACH;AACO,MAAM,sBAAsB;AAC5B,SAAS,cAAc,SAAS;AACrC,MAAI,iBAAiB;AACrB,QAAM,UAAU;AAAA,IACd,KAAK,QAAQ,MAAM,SAAS;AAAA,IAC5B,QAAQ,YAAA;AAAA,IACR,SAAS;AAAA,IACT,UAAU;AAAA,MACR,IAAI,OAAO;AACT,eAAO;AAAA,MACT;AAAA,MACA,IAAI,MAAM;AACR,eAAO,QAAQ,OAAO;AAAA,MACxB;AAAA,IAAA;AAAA,IAEF,SAAS,gBAAgB;AAAA,MACvB,GAAG,QAAQ,YAAY,WAAW,CAAA;AAAA,MAClC,MAAM,gBAAgB,EAAE;AAAA,MACxB,OAAO,SAAS,EAAE;AAAA,MAClB,0BAA0B,IAAA;AAAA,MAC1B,SAAS,gBAAgB,CAAA,CAAE;AAAA,IAAA,CAC5B;AAAA,IACD,QAAQ;AAAA,MACN,MAAM,CAAA;AAAA,IAAC;AAAA,IAET,eAAe,IAAI;AACjB,UAAI,QAAQ,OAAO,UAAU,CAAC,mBAAmB;AAC/C,eAAO,QAAQ,OAAO,IAAI,MAAM,aAAa,SAAS,EAAE,CAAC;AAAA,MAC3D;AACA,aAAO,aAAa,SAAS,EAAE;AAAA,IACjC;AAAA,IACA,aAAa;AAAA,IACb,iBAAiB;AACf,UAAI,CAAC,QAAQ,aAAa;AACxB,eAAO,MAAM;AAAA,QACb;AAAA,MACF;AACA;AACA,UAAI,SAAS;AACb,aAAO,MAAM;AACX,YAAI,QAAQ;AACV;AAAA,QACF;AACA,iBAAS;AACT;AACA,YAAI,mBAAmB,GAAG;AACxB,kBAAQ,cAAc;AACtB,iBAAO,QAAQ,SAAS,sBAAsB;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAAA,IACA,oBAAoB,CAAA;AAAA,IACpB,YAAY,gBAAgB,EAAE;AAAA,IAC9B,kBAAkB,CAAA;AAAA,IAClB,GAAG;AAAA,EAAA;AAEmB;AACtB,YAAQ,QAAQ,iBAAiB;AAAA,EACnC;AACA,MAA0B,QAAQ,YAAY;AAC5C,YAAQ,QAAQ,OAAO,QAAQ,WAAW;AAC1C,YAAQ,WAAW,OAAO;AAC1B,YAAQ,WAAW,UAAU,QAAQ;AACrC,YAAQ,WAAW,SAAS;AAAA,MAC1B,QAAQ,QAAQ,WAAW,cAAc;AAAA,MACzC,KAAK,QAAQ,WAAW,cAAc;AAAA,IAAA;AAAA,EAE1C;AAiBA,UAAQ,QAAQ,YAAA;AAChB,UAAQ,OAAO,QAAQ,MAAM;AACL;AACtB,UAAM,gBAAgB,eAAe,OAAO,MAAM;AAChD,iBAAW,QAAQ,OAAO;AACxB,cAAM,QAAQ,eAAe,MAAM,KAAK,GAAG,IAAI,CAAC;AAAA,MAClD;AAAA,IACF;AACA,YAAQ,MAAM,WAAW,CAAC,SAAS,SAAS,QAAQ,MAAM,aAAa,eAAe,MAAM,GAAG,IAAI;AAAA,EACrG;AACA,UAAQ,WAAW,QAAQ,MAAM;AACjC,UAAQ,UAAU,CAAC,MAAM,UAAU;AACjC,UAAM,QAAQ,MAAM;AACpB,iBAAa,SAAS,OAAO,KAAK;AAClC,iBAAa,QAAQ,OAAO,OAAO,kBAAkB,OAAO,KAAK;AAAA,EACnE;AACA,eAAa,QAAQ,QAAQ,SAAS,OAAO;AAC7C,eAAa,QAAQ,OAAO,OAAO,kBAAkB,SAAS,OAAO;AAgBrE,QAAM,gBAAqC,QAAQ,WAAW;AAC9D,UAAQ,QAAQ,UAAiF,aAAa;AAC9G,SAAO;AACT;AACO,SAAS,oBAAoB,SAASA,SAAQ;AACnD,MAAIA,QAAO,OAAO;AAChB,YAAQ,MAAM,SAASA,QAAO,KAAK;AAAA,EACrC;AACF;AACA,eAAsB,YAAY,SAASA,SAAQ;AACjD,MAAI,OAAOA,YAAW,YAAY;AAChC,UAAM,EAAE,SAAAC,SAAA,IAAY,MAAM,QAAQ,eAAe,MAAMD,QAAO,OAAO,CAAC,KAAK,CAAA;AAC3E,QAAIC,YAAW,OAAOA,aAAY,UAAU;AAC1C,iBAAW,OAAOA,UAAS;AACzB,gBAAQ,QAAQ,KAAKA,SAAQ,GAAG,CAAC;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AACF;AACA,eAAsB,aAAa,SAASC,UAAS;AACnD,QAAM,sCAAsC,IAAA;AAC5C,QAAM,oBAAoB,CAAA;AAC1B,QAAM,YAAY,CAAA;AAClB,MAAI,QAAQ;AACZ,MAAI,eAAe;AACnB,iBAAe,cAAcF,SAAQ;AACnC,UAAM,iCAAiCA,QAAO,WAAW,OAAO,CAAC,SAASE,SAAQ,KAAK,CAAC,MAAM,EAAE,UAAU,IAAI,KAAK,CAAC,gBAAgB,IAAI,IAAI,CAAC,KAAK,CAAA;AAClJ,QAAI,+BAA+B,SAAS,GAAG;AAC7C,wBAAkB,KAAK,CAAC,IAAI,IAAI,8BAA8B,GAAGF,OAAM,CAAC;AAAA,IAC1E,OAAO;AACL,YAAM,UAAU,YAAY,SAASA,OAAM,EAAE,KAAK,YAAY;AAC5D,YAAIA,QAAO,OAAO;AAChB,0BAAgB,IAAIA,QAAO,KAAK;AAChC,gBAAM,QAAQ,IAAI,kBAAkB,IAAI,OAAO,CAAC,WAAW,gBAAgB,MAAM;AAC/E,gBAAI,UAAU,IAAIA,QAAO,KAAK,GAAG;AAC/B,wBAAU,OAAOA,QAAO,KAAK;AAC7B,kBAAI,UAAU,SAAS,GAAG;AACxB;AACA,sBAAM,cAAc,gBAAgB;AAAA,cACtC;AAAA,YACF;AAAA,UACF,CAAC,CAAC;AAAA,QACJ;AAAA,MACF,CAAC,EAAE,MAAM,CAAC,MAAM;AACd,YAAI,CAACA,QAAO,YAAY,CAAC,QAAQ,QAAQ,OAAO;AAC9C,gBAAM;AAAA,QACR;AACA,kBAAU;AAAA,MACZ,CAAC;AACD,UAAIA,QAAO,UAAU;AACnB,kBAAU,KAAK,OAAO;AAAA,MACxB,OAAO;AACL,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,aAAWA,WAAUE,UAAS;AAC5B,QAA0B,QAAQ,YAAY,iBAAiBF,QAAO,KAAK,YAAY,OAAO;AAC5F;AAAA,IACF;AACA,wBAAoB,SAASA,OAAM;AAAA,EACrC;AACA,aAAWA,WAAUE,UAAS;AAC5B,QAA0B,QAAQ,YAAY,iBAAiBF,QAAO,KAAK,YAAY,OAAO;AAC5F;AAAA,IACF;AACA,UAAM,cAAcA,OAAM;AAAA,EAC5B;AACA,QAAM,QAAQ,IAAI,SAAS;AAC3B,MAAI,cAAc;AAChB,aAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACrC,YAAM,QAAQ,IAAI,SAAS;AAAA,IAC7B;AAAA,EACF;AACA,MAAI,OAAO;AACT,UAAM,QAAQ,QAAQ,SAAS;AAAA,EACjC;AACF;AAAA;AAEO,SAAS,iBAAiBA,SAAQ;AACvC,MAAI,OAAOA,YAAW,YAAY;AAChC,WAAOA;AAAA,EACT;AACA,QAAM,QAAQA,QAAO,SAASA,QAAO;AACrC,SAAOA,QAAO;AACd,SAAO,OAAO,OAAOA,QAAO,UAAU,MAAM;AAAA,EAC5C,IAAIA,SAAQ,EAAE,CAAC,mBAAmB,GAAG,MAAM,OAAO;AACpD;AAKO,SAAS,aAAa,MAAM,OAAO,MAAM;AAC9C,QAAM,KAAK,MAA8B,MAAA;AACzC,QAAM,aAAa,cAAc,KAAK,GAAG;AACjB;AACtB,WAAO,KAAK,OAAO,eAAe,MAAM,WAAW,UAAU,MAAM,EAAE,CAAC;AAAA,EACxE;AAIF;AACO,SAAS,cAAc,IAAI;AAChC,MAAI;AACJ,MAAI,uBAAuB;AACzB,sBAAkB,mBAAA,GAAsB,WAAW,IAAI;AAAA,EACzD;AACA,sBAAoB,cAAc,EAAE,EAAE,OAAA;AACtC,SAAO,mBAAmB;AAC5B;AACO,SAAS,WAAW,IAAI;AAC7B,QAAM,kBAAkB,cAAc,EAAE;AACxC,MAAI,CAAC,iBAAiB;AAGb;AACL,YAAM,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AAAA,EACF;AACA,SAAO;AACT;AAAA;AAEO,SAAS,iBAAiB,QAAQ;AACvC,SAAO,aAAa;AACtB;AACA,SAAS,aAAa,KAAK,KAAK,KAAK;AACnC,SAAO,eAAe,KAAK,KAAK,EAAE,KAAK,MAAM,KAAK;AACpD;AC7PO,MAAM,mBAAmB,OAAO,aAAa;AAC7C,MAAM,kBAAkB,OAAO,OAAO;ACG7B,YAAY,IAAI,QAAQ,cAAc,GAAG;ACGlD,MAAM,YAAY,MAAM;AAC7B,SAAO,cAAc;AACvB;AACO,MAAM,WAAW,MAAM;AAM5B,MAAI,uBAAuB;AACzB,WAAO,OAAO,iBAAiB,WAAA,EAAa,MAAM;AAAA,EACpD;AACA,SAAO,aAAa;AACtB;AAAA;AAeO,SAAS,0BAA0B,YAAY;AACpD,SAAO;AACT;AAeA,MAAM,yBAAyB,MAAM;AACnC,MAAI;AACF,QAAI,WAAA,EAAa,uBAAuB;AACtC,aAAO;AAAA,IACT;AAAA,EACF,QAAQ;AACN,WAAO;AAAA,EACT;AACA,SAAO;AACT;AACA,MAAM,eAAe;AACd,MAAM,aAAa,CAAC,IAAI,YAAY;AACzC,SAAO;AACP,QAAM,SAAS,OAAO,OAAO,WAAW,KAAK,UAAU,KAAK,mBAAmB,EAAE,IAAI,UAAA,EAAY,QAAQ,EAAE,EAAE;AAO7G,QAAM,iBAAiB,YAAY,QAAQ,EAAE,gBAAgB,MAAM;AACnE,QAAM,aAAa,SAAS,YAAY;AACxC,MAAI,YAAY;AACd,QAAI,CAAC,SAAS,UAAU;AACtB,YAAM,IAAI,MAAM,qGAAqG;AAAA,IACvH;AACA,UAAM,EAAE,SAAA,IAAa,IAAI,IAAI,QAAoD,kBAAkB;AACnG,QAAI,YAAY,iBAAiB,QAAQ,GAAG;AAC1C,YAAM,IAAI,MAAM,kCAAkC,QAAQ,aAAa;AAAA,IACzE;AAAA,EACF;AACA,QAAM,eAAe,uBAAA;AAgBrB,QAAM,SAAS,UAAA;AACf,QAAM,UAAU,WAAA;AACQ;AACtB,QAAI,QAAQ,YAAY;AACtB,YAAM,WAAW,OAAO,OAAO,YAAY,aAAa,SAAS,OAAO,QAAQ,EAAE,EAAE,YAAY;AAChG,YAAM,YAAY,aAAa,SAAS,SAAQ,oCAAmB,IAAI,SAAS,QAAQ;AACxF,YAAM,WAAW,eAAe,UAAU;AACxC,cAAM,QAAQ,SAAS,gBAAgB;AACvC,cAAM,aAAa,UAAU,QAAQ,cAAc,KAAK;AACxD,cAAM,gBAAgB,UAAU,WAAW,cAAc;AACzD,gBAAQ,WAAW,kBAAkB;AAAA,UACnC,YAAY,mBAAmB,SAAS,gBAAgB,KAAK,GAAG;AAAA,UAChE,MAAM,yEAAyE,UAAU;AAAA,UACzF,SAAS,EAAE,UAAU,cAAA;AAAA,QAAc;AAErC,eAAO;AAAA,MACT;AACA,UAAI,CAAC,cAAc,cAAc;AAC/B,eAAO,UAAU,CAAC,UAAU,MAAM,aAAa,WAAW,SAAS,KAAK,IAAI,MAAM;AAClF,eAAO;AAAA,MACT;AACA,aAAO,SAAS,CAAC,eAAe;AAAA;AAAA,QAE9B;AAAA,OACD;AAAA,IACH;AAAA,EACF;AACA,MAAI,YAAY;AACd,YAAQ,OAAO,KAAA;AACf,QAAI,SAAS,SAAS;AACpB,MAAA,SAAS,QAAQ,MAAM;AAAA,IACzB,OAAO;AACL,MAAA,SAAS,OAAO;AAAA,IAClB;AACA,QAAI,cAAc;AAChB,UAAI,CAAC,QAAQ,aAAa;AACxB,eAAO;AAAA,MACT;AACA,aAAO,IAAI,QAAQ,MAAM;AAAA,MACzB,CAAC;AAAA,IACH;AACA,WAAO,QAAQ,QAAA;AAAA,EACjB;AACA,SAAO,SAAS,UAAU,OAAO,QAAQ,EAAE,IAAI,OAAO,KAAK,EAAE;AAC/D;AAoCO,SAAS,mBAAmB,IAAI;AACrC,SAAO,UAAU,GAAG,QAAQ,IAAI,GAAG,SAAS,EAAE,KAAK,GAAG,QAAQ;AAChE;AACO,SAAS,UAAU,WAAW,iBAAiB,OAAO;AAC3D,QAAM,MAAM,IAAI,IAAI,WAAW,kBAAkB;AACjD,MAAI,CAAC,gBAAgB;AACnB,WAAO,IAAI,WAAW,IAAI,SAAS,IAAI;AAAA,EACzC;AACA,MAAI,UAAU,WAAW,IAAI,GAAG;AAC9B,WAAO,IAAI,SAAA,EAAW,QAAQ,IAAI,UAAU,EAAE;AAAA,EAChD;AACA,SAAO,IAAI,SAAA;AACb;AC3LO,MAAM,uBAAuB;AAC7B,MAAM,WAAW,MAAM,MAAM,WAAU,EAAG,SAAS,OAAO;AAC1D,MAAM,YAAY,CAAC,UAAU;AAClC,QAAM,YAAY,YAAY,KAAK;AACnC,MAAI;AACF,UAAM,UAAU,WAAU;AAC1B,UAAM,SAAS,SAAQ;AACvB,QAAI,MAAoB;AAGxB,WAAO,UAAU;AAAA,EACnB,QAAQ;AACN,UAAM;AAAA,EACR;AACA,SAAO;AACT;AAUO,MAAM,cAAc,CAAC,UAAU,CAAC,CAAC,SAAS,OAAO,UAAU,YAAY,wBAAwB;AAC/F,MAAM,cAAc,CAAC,UAAU;AACpC,QAAM,YAAYG,cAAc,KAAK;AACrC,SAAO,eAAe,WAAW,sBAAsB;AAAA,IACrD,OAAO;AAAA,IACP,cAAc;AAAA,IACd,UAAU;AAAA,EACd,CAAG;AACD,SAAO;AACT;ACjCA,MAAM,aAAa;AAYnB,SAASC,eAAa;AACpB,MAAI,oBAAmB,GAAI;AACzB,UAAM,WAAW,OAAO,UAAU;AAClC,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,gGAAgG;AAAA,IAClH;AACA,WAAO;AAAA,EACT;AACA,QAAM,IAAI,MAAM,gGAAgG;AAClH;ACvBA,MAAA,qDAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM,SAAS;AACb,UAAM,OAA4B,QAAQ,WAAW;AACrD,YAAQ,OAAO,IAAI,IAAI;AAAA,EAqBzB;AACF,CAAC;ACfM,SAASC,UAAQ,OAAO;AAC7B,SAAO,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AAC9C;ACqBO,eAAe,cAAc,KAAK;AACvC,QAAM,OAAO,OAAO,QAAQ,WAAW,MAAM,IAAI;AACzB;AACtB,eAAU,EAAG,WAAW,mBAAmB;AAC3C,UAAM,qBAAqB;AAAA,MACzBC,aAAkB,EAAE,SAAQ,iCAAgB,GAAG,MAAM,WAAU,CAAE;AAAA,IACvE;AACI,WAAO,KAAK,CAAA,GAAI,GAAG,mBAAmB,SAAS,IAAI,EAAE,SAAS;AAAA,EAChE;AAYF;ACrBA,MAAA,UAAe;AAAA,EACb;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW,MAAM,OAAO,0BAAwE;AAAA,EAAA;AAAA,EAElG;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW,MAAM,OAAO,2BAAyE;AAAA,EAAA;AAAA,EAEnG;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW,MAAM,OAAO,2BAAyE;AAAA,EAAA;AAAA,EAEnG;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW,MAAM,OAAO,gCAA8E;AAAA,EAAA;AAAA,EAExG;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW,MAAM,OAAO,wCAAsF;AAAA,EAAA;AAElH;AC5DO,MAAM,oBAAoB,CAAC,OAAO,aAAa;AACpD,SAAO,EAAE,SAAS,MAA2F,SAAS,UAAO,EAAI;AACnI;AACA,MAAM,2BAA2B;AACjC,MAAM,uBAAuB;AAC7B,MAAM,sBAAsB;AAC5B,SAAS,iBAAiB,OAAO;AAC/B,QAAM,SAAS,OAAO,KAAK,OAAO,MAAM,KAAK,QAAQ,0BAA0B,IAAI,EAAE,QAAQ,sBAAsB,IAAI,EAAE,QAAQ,qBAAqB,CAAC,MAAM,MAAM,OAAO,EAAE,MAAM,CAAC,CAAC,GAAG,SAAQ,KAAM,EAAE;AACvM,SAAO,OAAO,WAAW,aAAa,OAAO,KAAK,IAAI;AACxD;AACO,SAAS,eAAe,IAAI,MAAM;AACvC,MAAI,OAAO,QAAQ,SAAS,gBAAgB;AAC1C,WAAO;AAAA,EACT;AACA,MAAI,iBAAiB,EAAE,MAAM,iBAAiB,IAAI,GAAG;AACnD,WAAO;AAAA,EACT;AACA,QAAM,oBAAoB,GAAG,QAAQ;AAAA,IACnC,CAAC,MAAM,UAAU,KAAK,cAAc,KAAK,WAAW,YAAY,KAAK,QAAQ,KAAK,GAAG,YAAY;AAAA,EACrG;AACE,MAAI,mBAAmB;AACrB,WAAO;AAAA,EACT;AACA,SAAO;AACT;ACvBA,MAAA,iBAAe;AAAA,EACb,eAAe,IAAI,MAAM,eAAe;AACtC,UAAM,UAAU,WAAA;AAChB,UAAM,sBAAsB,UAAA,EAAY,SAAS,sBAAsB;AACvE,QAAI,GAAG,SAAS,KAAK,MAAM;AACzB,UAAI,KAAK,QAAQ,CAAC,GAAG,MAAM;AACzB,eAAO,EAAE,MAAM,GAAG,KAAK,EAAA;AAAA,MACzB;AACA,UAAI,GAAG,MAAM;AACX,eAAO,EAAE,IAAI,GAAG,MAAM,KAAK,+BAA+B,GAAG,IAAI,GAAG,UAAU,oBAAA;AAAA,MAChF;AACA,aAAO;AAAA,IACT;AACA,UAAM,yBAAyB,OAAO,GAAG,KAAK,gBAAgB,aAAa,GAAG,KAAK,YAAY,IAAI,IAAI,IAAI,GAAG,KAAK;AACnH,QAAI,2BAA2B,OAAO;AACpC,aAAO;AAAA,IACT;AACA,UAAM,aAAa,QAAQ,qBAAqB,2BAA2B;AAC3E,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,UAAI,SAAS,gBAAgB;AAC3B,gBAAQ,mBAAmB,IAAI,MAAM,eAAe,mBAAmB,CAAC;AACxE;AAAA,MACF;AACA,cAAQ,MAAM,SAAS,YAAY,MAAM;AACvC,8BAAsB,MAAM,QAAQ,mBAAmB,IAAI,MAAM,eAAe,mBAAmB,CAAC,CAAC;AAAA,MACvG,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;AACA,SAAS,+BAA+B,UAAU;AAChD,MAAI;AACF,UAAM,OAAO,SAAS,cAAc,QAAQ;AAC5C,QAAI,MAAM;AACR,cAAQ,OAAO,WAAW,iBAAiB,IAAI,EAAE,eAAe,KAAK,MAAM,OAAO,WAAW,iBAAiB,SAAS,eAAe,EAAE,gBAAgB,KAAK;AAAA,IAC/J;AAAA,EACF,QAAQ;AAAA,EACR;AACA,SAAO;AACT;AACA,SAAS,mBAAmB,IAAI,MAAM,eAAe,4BAA4B;AAC/E,MAAI,eAAe;AACjB,WAAO;AAAA,EACT;AACA,QAAM,mBAAmB,eAAe,IAAI,IAAI;AAChD,MAAI,GAAG,MAAM;AACX,WAAO;AAAA,MACL,IAAI,GAAG;AAAA,MACP,KAAK,+BAA+B,GAAG,IAAI;AAAA,MAC3C,UAAU,mBAAmB,6BAA6B;AAAA,IAAA;AAAA,EAE9D;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,KAAK;AAAA,EAAA;AAET;AC1DA,MAAM,sBAAsB;AAAA,EAC1B,UAAU;AAAA,EACV,oBAAoB;AACtB;AAEA,MAAA,gBAAe;AAAA,EACf,GAAG;AAAA,EACH,GAAG;AACH;ACNE,MAAA,WAAQ,0CAAgB,OAAA,IAAA,SAAA;AAAA,MAAA,QAAA;AACtB,MAAA,CAAA,GAAA,MAAA,UAAA;AACF;AAAA,EACA;AACA,kBAAe,CAAA,QAAM,SAAA,IAAAC,aAAA,MAAA,QAAA,QAAA,GAAA,KAAA,SAAA,EAAA,CAAA,CAAA,GAAA,SAAA,MAAA,QAAA,UAAA,GAAA;AACnB,MAAA,WAAA,MAAA;AACF;AAAA,EACA;AAA0B,QACxB,QAAO,YAAA;AAAA,IACP,OAAA;AAAA,IACA,sBAAe,OAAU,cAAO;AAAA,IAChC,eAAM,UAAA,OAAA,iBAAA,mBAAA,GAAA,QAAA;AAAA,IAAA;MAEN,MAAA,GAAA;AAAA,IAAA;AAAA,EAEF,CAAA;AAIF,SAAC;;AClBC,MAAA,0BAA4C,0CAAA,OAAA,OAAA;AAC1C;AACF;AAAA,EACA;;ACLK,MAAM,mBAAmB;AAAA,EAC9B;AAAA,EACA;AACF;AACO,MAAM,kBAAkB,CAAA;ACqBC,MAC9B,SAAM,iCAAA;AAAA,EACN,MAAA;AAAA,EACA;EACE,MAAI,MAAA,SAAa;AAAA,QAAA,QAAA;AACjB,QAAI,cAAa,oCAAW,IAAY;AAIxC,UAAM,wBAAuB,UAAA,UAAA,KAA2C,oBAAK,UAAU;AACvF,UAAI,SAAA,cAAA,UAAA,CAAA,QAAA,SAAA,IAAAA,aAAA,MAAA,cAAA,OAAA,OAAA,CAAA,GAAA,SAAA,MAAA,QAAA,UAAA,GAAA,WAAA,UAAA;AACJ,QAAA;AAA4B,UACvB,SAAAC,eAAA;AAAA,MACH,GAAA;AAAA,MACE,gBAAa,CAAA,IAAA,MAAA,kBAAgB;AAC3B,YAAA,SAAA,gBAAgB;AAChB,0BAAA;AACF;AAAA,QACA;AACE,YAAA,8BAAgC;AAChC,iBAAI,QAAA,+BAAuC;AACzC,cAAA,uBAAqB,SAAW,SAAM;AACpC,kBAAA,QAAM,OAAA,WAAA,MAAA;AACN,oBAAA;AACD,cAAA,SAAA,QAAA,oBAAA;AAAA,YACH,CAAA;AAAA,UACA;AACF,iBAAA,cAAA,eAAA,IAAA,gBAAA,iBAAA,aAAA;AAAA,QACF;AAAA,MACA;AAAA,MACA;AAAA,MACD;AAAA,IACD,CAAA;AAOA,YAAM,OAAA,IAAA,MAAgB;AACtB,UAAA,gBAAkB,WAAc,OAAA,aAAA,KAAA;AAC9B,WAAA,UAAc,CAAA,KAAA,SAAQ;AACvB,oBAAA,QAAA;AAAA,IACD,CAAA;AAA+E,WACxE,eAAM,QAAc,OAAA,OAAA,kBAAA,iBAAA;AAAA,MAC1B,KAAA,MAAA,cAAA;AAAA,IACD,CAAA;AACA,UAAM,aAAoB,QAAO,WAAA;AACjC,UAAM,oBAAmB,OAAM,aAAA,KAAA;AAC7B,UAAA,mBAAsB,MAAA;AACxB,aAAA,QAAA,OAAA,aAAA;AAAA,IACA;AACA,YAAO,KAAA,eAAe,gBAAS;AAC7B,qBAAe,CAAA,IAAG,SAAQ;AACxB,UAAA,GAAA,QAAA,GAAA,QAAiB,SAAA,CAAA,GAAA,YAAA,YAAA,KAAA,QAAA,KAAA,QAAA,SAAA,CAAA,GAAA,YAAA,SAAA;AACnB,yBAAA;AAAA,MACD;AAAA,IACD,CAAA;AACA,UAAA,QAAW,CAAA;AACT,eAAO,OAAA,cAAsB;AAAK,aAC3B,eAAa,OAAS,KAAA;AAAA,QAC3B,KAAA,MAAA,OAAY,MAAA,GAAA;AAAA,QACb,YAAA;AAAA,MAAA,CACH;AAAA,IACA;AACA,YAAQ,SAAA,gBAAgB,KAAA;AAAA,4BACb;AAAA,MACT,QAAQ,CAAA;AAAA,MACV,OAAA,CAAA;AAAA,IACA;AACmC,aAAA;AACjC,QAAA,CAAA,QAAO,YAAU,eAAkB;AACjC,aAAA,UAAe,OAAA,IAAA,OAAA,YAAA;AACf,eAAI,QAA2D;AAI7D,YAAA,SAAM;AACR,gBAAA,QAAA,SAAA,kBAAA;AAAA,QACA;AACE,YAAA,SAAA,SAAA,GAAA;AACF;AAAA,QACA;AACE,YAAA,GAAA,kBAAc,GAAA,yBAAmC;AACnD,gBAAA,QAAA,eAAA,MAAA,WAAA,GAAA,YAAA,GAAA,CAAA;AAAA,QACD;AAAA,MACH,CAAA;AAAA,IACA;AACE,QAAA;AACE,UAAA,MAAA;AACF;AAAA,QAAA,CAAA,QAAA,SAAA,IAAAD,aAAA,MAAA,OAAA,KAAA,UAAA,CAAA,GAAA,MAAA,QAAA,UAAA;AAAA;AAAA;;eAEO,SAAQ,IAAAA,aAAA,MAAA,OAAA,QAAA,CAAA,GAAA,MAAA,QAAA,UAAA;AAAA;AAAA,IACf;AACF,MAAA,CAAA,QAAA,SAAA,IAAAA,aAAA,MAAA,QAAA,eAAA,MAAA,UAAA,MAAA,CAAA,CAAA,GAAA,MAAA,QAAA,UAAA;AAAA,IACA;AACA,UAAA,uBAAiB,OAAA,aAAA;AACjB;AACE,QAAA,QAAS,YAAW,eAAS;AAC/B,aAAA,EAAA,SAAA,EAAA,SAAA;AAAA,IACA;AACA,UAAA,gBAAkB,QAAW,QAAS,MAAA;AACpC,WAAA,kBAAuB,IAAA,SAAA;AACvB,YAAG,QAAO,SAAY,oBAAI;AAC1B,SAAA,OAAI;AACF,UAAA,QAAQ,eAAS,iBAAA,CAAA,WAAA,GAAA,KAAA,MAAA,GAAA;AACnB,WAAA,KAAA,SAAA;AAAA,MACA;AACA,cAA2B,wBAAoB;AAC7C,UAAA,CAAA,QAAM,YAAA,eAAoC;AAC1C,cAAA,oBAAoC,oBAAA,IAAA,CAAA,GAAA,kBAAA,GAAA,QAAA,YAAA,MAAA,CAAA;AAClC,mBAAME,cAAA,GAAA;AACN,gBAAK,sBAAqBA,WAAA,KAAA;AACxB,cAAA,CAAA,qBAAA;AACF;AAAA,UACA;AACE,qBAAAC,UAAkBL,UAAI,mBAAK,GAAA;AAC7B,8BAAA,IAAAK,MAAA;AAAA,UACF;AAAA,QACA;AACqB;AACnB,6BAAe,MAAA,QAAe,eAAA,MAAA,cAAA,EAAA,MAAA,GAAA,KAAA,CAAA,CAAA;AAC5B,cAAA,WAAW;AACT,uBAAI,OAAW,WAAA,eAAoB;AACjC,kBAAA,WAAA,cAAyB,GAAA,GAAA;AAC3B,kCAAO,IAAA,GAAA;AAAA,cACL,OAAA;AACF,kCAAA,OAAA,GAAA;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACA;AACE,mBAAMA,UAAA,mBAA8B;AACpC,gBAAK,aAAY,OAAAA,WAAA,WAAA,QAAA,YAAA,MAAAA,MAAA,KAAA,MAAA,gBAAAA,MAAA,IAAA,EAAA,KAAA,CAAA,MAAA,EAAA,WAAA,CAAA,IAAAA;AACf,cAAA,CAAA,YAAqB;AAIvB,kBAAA,IAAA,MAAA,8BAAAA,MAAA,IAAA;AAAA,UACA;AACE,cAAA;AACE,gBAAA;AAGF,kBAAI,SAA8E,MAAA,QAAA,eAAA,MAAA,WAAA,IAAA,IAAA,CAAA;AAChF,gBAAA,MAAI;AACF,kBAAA,WAAM,2BAA+B,OAAA;AAAA,sBACnC,SAAY,UAAA,YAAA;AAAA,kBACZ,YAAA;AAAA,kBACD,eAAA,mBAAA,UAAA;AAAA,gBACD,CAAA;AACA,sBAAA,QAAO,eAAA,MAAA,UAAA,MAAA,CAAA;AACT,uBAAA;AAAA,cACF;AAAA,YACA;AACE,gBAAA,WAAA,MAAA;AACF;AAAA,YACA;AACE,gBAAA,WAAO,OAAA;AACT,qBAAA;AAAA,YACA;AACE,gBAAA,QAAI;AACF,kBAAA,YAAc,MAAA,KAAA,OAAe,OAAM;AACrC,sBAAA,QAAA,eAAA,MAAA,UAAA,MAAA,CAAA;AAAA,cACA;AACF,qBAAA;AAAA;UAEA,SAAM,KAAA;AACN,2BAAW,YAAO,GAAA;AAChB,gBAAA,OAAM,OAAQ;AAChB,oBAAA,QAAA,eAAA,MAAA,UAAA,MAAA,CAAA;AAAA,YACA;AACF,mBAAA;AAAA,UACF;AAAA,QACF;AAAA,MACD;AAAA,IACD,CAAA;AACE,WAAA,QAAO,YAAQ;AACf,aAAM;AACP,YAAA,QAAA,SAAA,kBAAA;AAAA,IACD,CAAA;AACE,WAAI,UAAW,CAAA,OAAA;AACb,UAAA,GAAA,QAAO,WAAQ,GAAA;AAA2C,eACxD,QAAY,eAAA,MAAA,UAAA,YAAA;AAAA,UACZ,YAAO;AAAA,UACP,OAAA;AAAA,UACA,eAAM,mBAAA,GAAA,QAAA;AAAA,UAAA;YAEN,MAAA,GAAA;AAAA,UAAA;AAAA,QACC,CACL,CAAA,CAAA;AAAA,MACD;AAAA,IACD,CAAA;AACE,YAAI,MAAA,SAAA,eAAA,YAAA;AACF,UAAA;AACE,YAAA,UAAA,sBAA4B;AAC9B,+BAAA,OAAA;AAAA,QACA;AAAqB,cAChB,OAAA,QAAA;AAAA,UACH,GAAA;AAAA,UACD,OAAA;AAAA,QACD,CAAA;eACO,QAAQ,iBAAA,cAAA;AAAA,MACf,SAAM,QAAQ;AAChB,cAAA,QAAA,eAAA,MAAA,UAAA,MAAA,CAAA;AAAA,MACD;AAAA,IACD,CAAA;AACF,WAAA,EAAA,SAAA,EAAA,SAAA;AAAA,EACF;AACA,CAAA;ACjOO,SAAS,WAAW,SAAS;AAClC,QAAM,OAAO,WAAW,WAAU;AAClC,SAAO,KAAK,YAAY,QAAQ,KAAK,eAAe,MAAM;AACxD,QAAI,oBAAmB,GAAI;AACzB,YAAM,OAAO,OAAOC,YAAU;AAC9B,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC5D;AACA,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACH;AACO,SAAS,QAAQ,OAAO,UAAU,IAAI;AAC3C,QAAM,OAAO,WAAW,QAAQ,IAAI;AACpC,SAAOC,UAAS,OAAO,EAAE,MAAM,GAAG,QAAO,CAAE;AAC7C;AAKO,SAAS,WAAW,OAAO,UAAU,IAAI;AAC9C,QAAM,OAAO,WAAW,QAAQ,IAAI;AACpC,SAAOC,aAAQ,OAAO,EAAE,MAAM,GAAG,QAAO,CAAE;AAC5C;ACjCe,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,SAAS;AACP,WAAO,mBAAmB,KAAK;AAAA,EACjC;AACF,CAAC;ACDM,MAAM,mBAAmB,OAAO,IAAI,kBAAkB;AAE7D,MAAA,uBAAe,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO,CAAC,YAAY,eAAe,kBAAkB,aAAa;AAAA,EAClE,GAAG;AAAA,EAGH,MAAM,OAAO,EAAE,OAAO,MAAK,GAAI;AAC7B,UAAM,UAAU,WAAW,KAAK;AAShC,UAAM,KAAK,mBAAkB;AAC7B,QAAI,IAAI;AACN,SAAG,kBAAkB;AAAA,IACvB;AACA,YAAQ,kBAAkB,IAAI;AAC9B,WAAO,MAAM;AACX,UAAI,QAAQ,OAAO;AACjB,cAAM,SAAS,MAAM,UAAO;AAC5B,YAAI,UAAU,OAAO,WAAW,GAAG;AACjC,iBAAO,CAAC,WAAW,OAAO,CAAC,GAAG,KAAK,CAAC;AAAA,QACtC;AACA,eAAO;AAAA,MACT;AACA,YAAM,OAAO,MAAM,YAAY,MAAM;AACrC,UAAI,MAAM;AACR,eAAO,EAAE,IAAI;AAAA,MACf;AACA,YAAM,cAAc,MAAM,YAAY,MAAM,eAAe;AAC3D,YAAM,cAAc,MAAM,eAAe,MAAM,kBAAkB;AACjE,aAAO,mBAAmB,aAAa,OAAO,WAAW;AAAA,IAC3D;AAAA,EACF;AACF,CAAC;AC5CM,MAAM,cAAc,CAAC,aAAa;AACf;AACtB;AAAA,EACF;AASF;ACXA,MAAM,oBAAoB;AACnB,SAAS,YAAY,MAAM;AAChC,QAAM,UAAU,OAAO,KAAK,KAAK,SAAS,CAAC,MAAM,WAAW,KAAK,IAAG,IAAK;AACzE,MAAI,OAAO,KAAK,CAAC,MAAM,UAAU;AAC/B,SAAK,QAAQ,OAAO;AAAA,EACtB;AACA,QAAM,CAAC,MAAM,IAAI,IAAI;AACrB,MAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,UAAM,IAAI,UAAU,6CAA6C,IAAI;AAAA,EACvE;AACA,MAAI,SAAS,UAAU,OAAO,SAAS,YAAY;AACjD,UAAM,IAAI,MAAM,gDAAgD,IAAI;AAAA,EACtE;AACA,QAAM,MAAM,oBAAoB;AAChC,QAAM,UAAU,WAAU;AAC1B,QAAM,QAAQ,MAAM,QAAQ,QAAQ,OAAO,GAAG;AAC9C,MAAI,MAAM,UAAU,UAAU,MAAM;AAClC,UAAM,eAAe,KAAI;AACzB,QAAI,MAAM,YAAY,GAAG;AACvB,cAAQ,QAAQ,MAAM,GAAG,IAAI;AAC7B,aAAO;AAAA,IACT;AACA,UAAM,QAAQ;AAAA,EAChB;AACA,SAAO;AACT;ACvBO,SAAS,gBAAgB,SAAS;AAIvC,cAAY,WAAA;AACZ,SAAO,QAAQ,YAAY;AAC7B;AACO,SAAS,kBAAkB,SAAS;AAIzC,QAAM,QAAQ,gBAAA;AACd,QAAM,WAAW,QAAQ,kBAAkB,KAAK,IAAI,CAAA;AAC5B;AACtB,WAAO;AAAA,EACT;AAUF;ACrBA,MAAM,iBAAiB;AAAA,EACrB,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ,CAAC,QAAQ,MAAM,mBAAmB,GAAG,CAAC;AAAA,EAC9C,QAAQ,CAAC,QAAQ,mBAAmB,OAAO,QAAQ,WAAW,MAAM,KAAK,UAAU,GAAG,CAAC;AACzF;AAEO,SAAS,UAAU,MAAM,OAAO;AACrC,QAAM,OAAO,EAAE,GAAG,gBAAgB,GAAG,MAAA;AACrC,OAAK,WAAW,CAAC,QAAQ,QAAQ;AACjC,QAAM,UAAU,eAAe,IAAI,KAAK,CAAA;AACxC,MAAI;AACJ,MAAI,KAAK,WAAW,QAAQ;AAC1B,YAAQ,KAAK,SAAS;AAAA,EACxB,WAAW,KAAK,SAAS;AACvB,YAAQ,KAAK,QAAQ,QAAA,IAAY,KAAK,IAAA;AAAA,EACxC;AACA,QAAM,aAAa,UAAU,UAAU,SAAS;AAEhD,QAAM,cAAc,MAAM,aAAa,SAAS,QAAQ,IAAI,KAAK,KAAK,WAAW;AACjF,QAAM,SAA8H,IAAI,WAAW;AAyEpH;AAC7B,UAAM,UAAU,WAAA;AAChB,UAAM,wBAAwB,MAAM;AAClC,UAAI,KAAK,YAAY,QAAQ,OAAO,OAAO,QAAQ,IAAI,CAAC,GAAG;AACzD;AAAA,MACF;AACA,cAAQ,aAAa,CAAA;AACrB,UAAI,QAAQ,QAAQ,UAAU;AAC5B,YAAI,QAAQ,OAAO,OAAO,QAAQ,SAAS,IAAI,CAAC,GAAG;AACjD;AAAA,QACF;AAAA,MAIF;AACA,cAAQ,SAAS,IAAI,IAAI,OAAO;AAChC,wBAAkB,gBAAgB,OAAO,GAAG,MAAM,OAAO,OAAO,IAAI;AAAA,IACtE;AACA,UAAM,SAAS,QAAQ,MAAM,SAAS,gBAAgB,qBAAqB;AAC3E,YAAQ,MAAM,SAAS,aAAa,MAAM;AACxC,aAAA;AACA,aAAO,sBAAA;AAAA,IACT,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAOA,SAAS,eAAe,OAAO,IAAI;AACT;AACtB,WAAO,MAAM,iBAAiB,gBAAA,GAAmB,QAAQ,KAAK,IAAI,IAAI;AAAA,EACxE;AAGF;AAYA,SAAS,kBAAkB,OAAO,MAAM,OAAO,OAAO,CAAA,GAAI;AACxD,MAAI,OAAO;AACT,QAAI,UAAU,QAAQ,UAAU,QAAQ;AACtC,aAAO,UAAU,OAAO,MAAM,OAAO,IAAI;AAAA,IAC3C;AACA,QAAI,UAAU,OAAO,IAAI,MAAM,QAAQ;AACrC,aAAO,aAAa,OAAO,MAAM,IAAI;AAAA,IACvC;AAAA,EACF;AACF;ACrCO,SAAS,qBAAqB,MAAM,QAAQ;AACzB;AACtB,eAAA,EAAa,WAAW,iBAAiB,IAAI,IAAI;AAAA,EACnD;AACF;ACvHA,MAAM,oBAAoB,IAAI,SAAS,KAAK,KAAK,CAAC,QAAQ,QAAQ,MAAM;AAAA;AAGjE,SAAS,eAAe,SAAS;AACtC,QAAM,gBAAgB,QAAQ,iBAAiB;AAM/C,WAAS,0BAA0B,MAAM;AACvC,WAAoB,OAAO,SAAS,YAAY,KAAK,WAAW,GAAG;AAAA,EACrE;AACA,WAAS,6BAA6B,IAAI,SAAS,eAAe;AAChE,UAAM,yBAAyB,iBAAiB,QAAQ;AACxD,QAAI,CAAC,MAAM,2BAA2B,YAAY,2BAA2B,UAAU;AACrF,aAAO;AAAA,IACT;AACA,QAAI,OAAO,OAAO,UAAU;AAC1B,aAAO,2BAA2B,IAAI,sBAAsB;AAAA,IAC9D;AACA,UAAM,OAAO,UAAU,MAAM,GAAG,SAAS,SAAS,GAAG,OAAO,QAAQ,EAAE,EAAE;AACxE,UAAM,eAAe;AAAA,MACnB,GAAG;AAAA,MACH,MAAM;AAAA;AAAA,MAEN,MAAM,2BAA2B,MAAM,sBAAsB;AAAA,IAAA;AAE/D,WAAO;AAAA,EACT;AACA,WAAS,YAAY,OAAO;AAC1B,UAAM,SAAS,UAAA;AACf,UAAM,SAAS,iCAAA;AACf,UAAM,YAAY,SAAS,MAAM,CAAC,CAAC,MAAM,UAAU,MAAM,WAAW,OAAO;AAC3E,UAAM,gBAAgB,SAAS,MAAM;AACnC,YAAM,OAAO,MAAM,MAAM,MAAM,QAAQ;AACvC,aAAO,OAAO,SAAS,YAAY,YAAY,MAAM,EAAE,gBAAgB,MAAM;AAAA,IAC/E,CAAC;AACD,UAAM,oBAAoB,iBAAiB,YAAY;AACvD,UAAM,iBAAiB,qBAAqB,OAAO,sBAAsB,WAAW,kBAAkB,UAAU;AAChH,UAAM,aAAa,SAAS,MAAM;AAChC,UAAI,MAAM,UAAU;AAClB,eAAO;AAAA,MACT;AACA,YAAM,OAAO,MAAM,MAAM,MAAM,QAAQ;AACvC,UAAI,OAAO,SAAS,UAAU;AAC5B,eAAO;AAAA,MACT;AACA,aAAO,SAAS,MAAM,cAAc;AAAA,IACtC,CAAC;AACD,UAAM,KAAK,SAAS,MAAM;AAExB,YAAM,OAAO,MAAM,MAAM,MAAM,QAAQ;AACvC,UAAI,WAAW,OAAO;AACpB,eAAO;AAAA,MACT;AACA,aAAO,6BAA6B,MAAM,OAAO,SAAS,MAAM,aAAa;AAAA,IAC/E,CAAC;AACD,UAAM,OAAO,WAAW,QAAQ,SAAS,iBAAiB,EAAE,GAAG,OAAO,IAAI;AAC1E,UAAM,OAAO,SAAS,MAAM;AAC1B,YAAM,yBAAyB,MAAM,iBAAiB,QAAQ;AAC9D,UAAI,CAAC,GAAG,SAAS,cAAc,SAAS,0BAA0B,GAAG,KAAK,GAAG;AAC3E,eAAO,GAAG;AAAA,MACZ;AACA,UAAI,WAAW,OAAO;AACpB,cAAM,OAAO,OAAO,GAAG,UAAU,YAAY,UAAU,GAAG,QAAQ,mBAAmB,GAAG,KAAK,IAAI,GAAG;AACpG,cAAM,QAAQ,OAAO,SAAS,WAAW,OAAO,QAAQ,IAAI,EAAE,OAAO;AACrE,eAAO,2BAA2B,OAAO,sBAAsB;AAAA,MACjE;AACA,UAAI,OAAO,GAAG,UAAU,UAAU;AAChC,eAAO,OAAO,QAAQ,GAAG,KAAK,GAAG,QAAQ;AAAA,MAC3C;AACA,aAAO,2BAA2B,QAAQ,OAAO,IAAI,SAAS,GAAG,KAAK,GAAG,sBAAsB;AAAA,IACjG,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAEA;AAAA,MACA,UAAU,MAAM,YAAY,SAAS,MAAM,GAAG,UAAU,OAAO,aAAa,MAAM,IAAI;AAAA,MACtF,eAAe,MAAM,iBAAiB,SAAS,MAAM,GAAG,UAAU,OAAO,aAAa,MAAM,IAAI;AAAA,MAChG,OAAO,MAAM,SAAS,SAAS,MAAM,OAAO,QAAQ,GAAG,KAAK,CAAC;AAAA,MAC7D,MAAM,SAAS,IAAI;AACjB,cAAM,WAAW,KAAK,OAAO,EAAE,SAAS,MAAM,SAAS,UAAU,WAAW,SAAS,UAAU,MAAA,CAAO;AAAA,MACxG;AAAA,IAAA;AAAA,EAEJ;AACA,SAAO,gBAAgB;AAAA,IACrB,MAAM;AAAA,IACN,OAAO;AAAA;AAAA,MAEL,IAAI;AAAA,QACF,MAAM,CAAC,QAAQ,MAAM;AAAA,QACrB,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,MAEZ,MAAM;AAAA,QACJ,MAAM,CAAC,QAAQ,MAAM;AAAA,QACrB,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA;AAAA,MAGZ,QAAQ;AAAA,QACN,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,MAEZ,KAAK;AAAA,QACH,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,MAEZ,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA;AAAA,MAGZ,UAAU;AAAA,QACR,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,MAEZ,YAAY;AAAA,QACV,MAAM,CAAC,QAAQ,MAAM;AAAA,QACrB,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,MAEZ,YAAY;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA;AAAA,MAGZ,aAAa;AAAA,QACX,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,MAEZ,kBAAkB;AAAA,QAChB,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,MAEZ,iBAAiB;AAAA,QACf,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA;AAAA,MAGZ,SAAS;AAAA,QACP,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,MAEZ,kBAAkB;AAAA,QAChB,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA;AAAA,MAGZ,UAAU;AAAA,QACR,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA;AAAA,MAGZ,QAAQ;AAAA,QACN,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA;AAAA,MAGZ,eAAe;AAAA,QACb,MAAM;AAAA,QACN,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAAA,IACZ;AAAA,IAEF,SAAS;AAAA,IACT,MAAM,OAAO,EAAE,SAAS;AACtB,YAAM,SAAS,UAAA;AACf,YAAM,EAAE,IAAI,MAAM,UAAU,YAAY,WAAW,cAAA,IAAkB,YAAY,KAAK;AACnE,iBAAW,KAAK;AACnC,YAAM,KAA0B;AAChC,YAAM,QAA6B;AASnC,qBAAe,SAAS,UAAU,cAAc;AACtB;AACtB;AAAA,QACF;AAAA,MAaF;AAsCA,aAAO,MAAM;AACX,YAAI,CAAC,WAAW,SAAS,CAAC,UAAU,SAAS,CAAC,0BAA0B,GAAG,KAAK,GAAG;AACjF,gBAAM,kBAAkB;AAAA,YACtB,KAAK;AAAA,YACL,IAAI,GAAG;AAAA,YACP,aAAa,MAAM,eAAe,QAAQ;AAAA,YAC1C,kBAAkB,MAAM,oBAAoB,QAAQ;AAAA,YACpD,SAAS,MAAM;AAAA,YACf,kBAAkB,MAAM;AAAA,YACxB,QAAQ,MAAM;AAAA,UAAA;AAEhB,cAAI,CAAC,MAAM,QAAQ;AAUjB,4BAAgB,MAAM,MAAM,OAAO;AAAA,UACrC;AACA,iBAAO;AAAA,YACL,iBAAiB,YAAY;AAAA,YAC7B;AAAA,YACA,MAAM;AAAA,UAAA;AAAA,QAEV;AACA,cAAM,SAAS,MAAM,UAAU;AAE/B,cAAM,MAAM;AAAA;AAAA,UAEV,MAAM,QAAQ,KAAK,MAAM;AAAA,UACzB,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,UAKR,cAAc,SAAS,UAAU,QAAQ,wBAAwB;AAAA,QAAA,KAC9D;AACL,YAAI,MAAM,QAAQ;AAChB,cAAI,CAAC,MAAM,SAAS;AAClB,mBAAO;AAAA,UACT;AACA,iBAAO,MAAM,QAAQ;AAAA,YACnB,MAAM,KAAK;AAAA,YACX;AAAA,YACA;AAAA,YACA,IAAI,QAAQ;AACV,kBAAI,CAAC,KAAK,OAAO;AACf,uBAAO;AAAA,cACT;AACA,oBAAM,MAAM,IAAI,IAAI,KAAK,OAAmD,kBAAkB;AAC9F,qBAAO;AAAA,gBACL,MAAM,IAAI;AAAA,gBACV,UAAU,IAAI;AAAA,gBACd,IAAI,QAAQ;AACV,yBAAO,WAAW,IAAI,MAAM;AAAA,gBAC9B;AAAA,gBACA,MAAM,IAAI;AAAA,gBACV,QAAQ,CAAA;AAAA,gBACR,MAAM;AAAA,gBACN,SAAS,CAAA;AAAA,gBACT,gBAAgB;AAAA,gBAChB,MAAM,CAAA;AAAA,gBACN,MAAM,KAAK;AAAA,cAAA;AAAA,YAEf;AAAA,YACA;AAAA,YACA;AAAA,YACA,YAAY,WAAW,SAAS,UAAU;AAAA,YAC1C,UAAU;AAAA,YACV,eAAe;AAAA,UAAA,CAChB;AAAA,QACH;AACA,eAAO,EAAE,KAAK;AAAA,UACZ,KAAK;AAAA,UACL,MAAM,KAAK,SAAS;AAAA;AAAA,UAEpB;AAAA,UACA;AAAA,UACA,SAAS,CAAC,UAAU;AAClB,gBAAI,WAAW,SAAS,UAAU,OAAO;AACvC;AAAA,YACF;AACA,kBAAM,eAAA;AACN,mBAAO,MAAM,UAAU,OAAO,QAAQ,KAAK,KAAK,IAAI,OAAO,KAAK,KAAK,KAAK;AAAA,UAC5E;AAAA,QAAA,GACC,MAAM,WAAW;AAAA,MACtB;AAAA,IACF;AAAA;AAAA,EAAA,CAED;AACH;AACA,MAAA,sDAA8C,gBAAgB;AAC9D,SAAS,2BAA2B,IAAI,eAAe;AACrD,QAAM,cAAc,kBAAkB,WAAW,oBAAoB;AACrE,QAAM,+BAA+B,YAAY,EAAE,KAAK,CAAC,GAAG,WAAW,MAAM;AAC7E,MAAI,8BAA8B;AAChC,WAAO;AAAA,EACT;AACA,SAAO,YAAY,IAAI,IAAI;AAC7B;ACxWA,MAAA,4DAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM,MAAM,SAAS;AACnB,UAAM,QAA6B,mBAAmB,SAAS;AAC/D,UAAM,QAAQ,SAAS,aAAa;AACZ;AACtB,cAAQ,MAAM,KAAK,gBAAgB,MAAM;AACvC,cAAM,QAAQ,OAAO,IAAI;AAAA,UACvB,QAAO,iCAAA,GAAmB,kBAAkB,EAAE;AAAA,UAC9C,aAAa;AAAA,QAAA,CACd;AAAA,MACH,CAAC;AAAA,IACH;AASA,WAAO;AAAA,MACL,SAAS;AAAA,QACP,gBAAgB;AAAA,MAAA;AAAA,IAClB;AAAA,EAEJ;AACF,CAAC;ACxBD,MAAM,WAAW;AAAA,EACf,CAAC,aAAa,CAAC,SAAS,YAAY,IAAI,KAAK,KAAK,QAAQ;AAAA,EAC1D,CAAC,mBAAmB,CAAC,SAAS,MAAM,IAAI,KAAK,UAAU,IAAI,KAAK,CAAC,KAAK,UAAU,OAAO,KAAK,UAAU,WAAW,OAAO,KAAK,UAAU,KAAK,KAAK,KAAK,IAAI;AAAA,EAC1J,CAAC,YAAY,CAAC,SAAS,MAAM,IAAI,KAAK,CAAC,KAAK,UAAU,OAAO,KAAK,UAAU,WAAW,OAAO,KAAK,UAAU,KAAK,KAAK,KAAK,IAAI;AAAA,EAChI,CAAC,cAAc,CAAC,SAAS,MAAM,IAAI,KAAK,UAAU,IAAI,KAAK,KAAK,KAAK;AAAA,EACrE,CAAC,mBAAmB,CAAC,SAAS,WAAW,IAAI,KAAK,UAAU,IAAI,KAAK,MAAM,IAAI,CAAC;AAAA,EAChF,CAAC,OAAO,CAAC,SAAS,MAAM,IAAI,KAAK,KAAK,KAAK;AAAA,EAC3C,CAAC,YAAY,CAAC,SAAS,WAAW,IAAI,KAAK,MAAM,IAAI,CAAC;AACxD;AAIA,MAAA,oEAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,QAAQ;AACN,eAAW,CAAC,SAAS,EAAE,KAAK,UAAU;AACpC,2BAAqB,SAAS,EAAE;AAAA,IAClC;AAAA,EACF;AACF,CAAC;ACxBD,MAAA,mBAAe,qBAAqB,MAAM,OAAO,8BAAkF,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACA9K,MAAA,gBAAe,qBAAqB,MAAM,oCAAwF,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACA3K,MAAA,qBAAe,qBAAqB,MAAM,OAAO,gCAAoF,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACAhL,MAAA,kBAAe,qBAAqB,MAAM,sCAA0F,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACA7K,MAAA,uBAAe,qBAAqB,MAAM,OAAO,kCAAsF,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACAlL,MAAA,qBAAe,qBAAqB,MAAM,OAAO,gCAAoF,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACAhL,MAAA,sBAAe,qBAAqB,MAAM,OAAO,iCAAqF,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACAjL,MAAA,gBAAe,qBAAqB,MAAM,OAAO,2BAA+E,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACA3K,MAAA,qBAAe,qBAAqB,MAAM,OAAO,gCAAoF,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACAhL,MAAA,oBAAe,qBAAqB,MAAM,OAAO,+BAAmF,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACA/K,MAAA,mBAAe,qBAAqB,MAAM,uCAA2F,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACA9K,MAAA,mBAAe,qBAAqB,MAAM,uCAA2F,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACA9K,MAAA,gBAAe,qBAAqB,MAAM,OAAO,2BAA+E,EAAE,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;ACA3K,MAAA,kBAAe,qBAAqB,MAAM,sCAA0F,KAAK,OAAK,EAAE,SAAS,KAAK,EAAE,WAAW,CAAC,CAAC;;;ACC7K,MAAM,uBAAuB;AAAA,EAC3B,CAAC,gBAAgB,gBAAgB;AAAA,EACnC,CAAC,aAAa,aAAa;AAAA,EAC3B,CAAC,kBAAkB,kBAAkB;AAAA,EACrC,CAAC,eAAe,eAAe;AAAA,EAC/B,CAAC,oBAAoB,oBAAoB;AAAA,EACzC,CAAC,kBAAkB,kBAAkB;AAAA,EACrC,CAAC,mBAAmB,mBAAmB;AAAA,EACvC,CAAC,aAAa,aAAa;AAAA,EAC3B,CAAC,kBAAkB,kBAAkB;AAAA,EACrC,CAAC,iBAAiB,iBAAiB;AAAA,EACnC,CAAC,gBAAgB,gBAAgB;AAAA,EACjC,CAAC,gBAAgB,gBAAgB;AAAA,EACjC,CAAC,aAAa,aAAa;AAAA,EAC3B,CAAC,eAAe,eAAe;AAAA,EAC/B,CAAC,cAAc,cAAc;AAAA,EAC7B,CAAC,cAAc,cAAc;AAE7B;AAEA,MAAA,gEAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,MAAO,SAAS;AACd,eAAW,CAAC,MAAMJ,UAAS,KAAK,sBAAsB;AACpD,cAAQ,OAAO,UAAU,MAAMA,UAAS;AACxC,cAAQ,OAAO,UAAU,SAAS,MAAMA,UAAS;AAAA,IACnD;AAAA,EACF;AACF,CAAC;ACxBM,SAAS,cAAc,SAAS;AACrC,QAAM,QAA6B,mBAAmB,QAAQ,WAAW,IAAI,KAAK,EAAE,aAAa,QAAQ,OAAO,CAAC;AASjH,SAAO,MAAM;AACb,SAAO;AACT;ACfA,MAAA,yDAAe,iCAAiB,MAAM;AACpC,QAAM,OAAO,WAAU;AACvB,MAAI,CAAC;AACH;AACF,QAAM,aAAa,cAAa;AAChC,QAAM,QAAQ;AAAA,IACZ,MAAM,CAAA;AAAA,IACN,gBAAgB;AAAA,MACd,MAAM;AAAA;AAAA,MAEN,SAAS,WAAW;AAAA,MACpB,UAAU,WAAW;AAAA,IAC3B;AAAA,EACA;AACE,MAAI,WAAW;AACb,UAAM,eAAe,YAAY,WAAW;AAC9C,MAAI,WAAW;AACb,UAAM,eAAe,iBAAiB,WAAW;AACnD,MAAI,WAAW,aAAa;AAC1B,UAAM,eAAe,kBAAkB,WAAW;AAClD,UAAM,KAAK;AAAA,MACT;AAAA,QACE,MAAM;AAAA,QACN,SAAS;AAAA,QACT,aAAa;AAAA,MACrB;AAAA,IACA;AAAA,EACE;AACA,OAAK,KAAK,KAAK;AACjB,CAAC;AC5BD,MAAA,iEAAe,iCAAiB,MAAM;AACpC,QAAM,OAAO,WAAU;AACvB,MAAI,CAAC;AACH;AACF,OAAK,IAAI,oBAAoB;AAC7B,OAAK,IAAI,oBAAoB;AAC/B,CAAC;ACLD,MAAA,qDAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,KAAK;AAAA,IACH,SAAS;AAAA,EACb;AAAA,EACE,QAAQ;AACN,UAAM,QAAQ,SAAQ;AACtB,UAAM,MAAM,SAAQ;AACpB,UAAMK,SAAQ,SAAS,MAAM;AAC3B,UAAI,IAAI,SAAS,CAAC,KAAK,GAAG,EAAE,SAAS,IAAI,OAAO,UAAU,GAAG;AAC3D,eAAO,GAAG,IAAI,MAAM,UAAU,MAAM,IAAI,MAAM,OAAO;AAAA,MACvD;AACA,UAAI,OAAO,MAAM,MAAM,UAAU;AAC/B,eAAO,MAAM,MAAM;AACrB,YAAM,OAAO,qBAAqB,MAAM,QAAQ,GAAG;AACnD,YAAM,cAAc,KAAK,MAAM,GAAG,EAAE,IAAG;AACvC,aAAO,cAAc,UAAU,WAAW,IAAI;AAAA,IAChD,CAAC;AACD,UAAM,kBAAkB;AAAA;AAAA,MAEtB,aAAa;AAAA,IACnB;AACI,YAAQ,EAAE,OAAO,MAAMA,OAAM,MAAK,GAAI,eAAe;AAAA,EACvD;AACF,CAAC;AC3BM,SAAS,qBAAqB;AACnC,QAAM,gBAAgB,iCAAgB;AACtC,SAAO,KAAoE,cAAc,iBAAiB,GAAG;AAAA,IAC3G,kBAAkB,CAAA;AAAA,EACtB,CAAG;AACH;ACLO,SAAS,aAAa,OAAO;AAClC,QAAM,SAAS,mBAAkB;AACjC,QAAM,SAAS;AAAA,IACb,MAAM;AAAA,IACN,KAAK;AAAA;AAAA,IAEL,OAAO;AAAA,IACP,aAAa;AAAA,IACb,GAAG,OAAO;AAAA,EACd;AAM0B;AACtB,WAAO,QAAQ;AAAA,MACb,QAAQ,CAAC,MAAM;AAAA,IACrB,CAAK;AAAA,EACH;AAKF;ACxBA,SAAS,gBAAgB,WAAW,SAAS;AAC3C,MAAI,OAAO;AACX,MAAI,YAAY,WAAW,EAAE,QAAQ,OAAO,gBAAgB,KAAI,CAAE,GAAG;AACnE,UAAM,SAAS,SAAS,SAAS;AACjC,WAAO,OAAO;AAAA,EAChB;AACA,QAAMC,QAAO,iBAAiB,QAAQ,QAAQ,GAAG;AACjD,MAAIA,UAAS,OAAO,KAAK,WAAWA,KAAI,GAAG;AACzC,WAAO,KAAK,MAAMA,MAAK,MAAM;AAAA,EAC/B;AACA,MAAI,SAAS,qBAAqB,QAAQ,WAAW,QAAQ,UAAU,EAAE;AACzE,MAAIA,UAAS,OAAO,OAAO,SAASA,KAAI,GAAG;AACzC,aAAS,OAAO,MAAM,GAAG,OAAO,QAAQA,KAAI,CAAC;AAAA,EAC/C;AACA,QAAM,iBAAiB,QAAQ,WAAW,SAASA,OAAM,UAAU,GAAG,IAAI;AAC1E,QAAM,cAAc,SAAS,MAAM,cAAc;AACjD,SAAO,SAAS,OAAO,CAAC,QAAQ,WAAW,kBAAkB,WAAW,IAAI,WAAW,QAAQ,eAAe,WAAW;AAC3H;AACA,MAAM,iBAAiB;AAAA;AAAA,EAErB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AACA,SAAS,WAAW,MAAM;AACxB,QAAM,cAAc,KAAK,MAAM,GAAG,EAAE,IAAG;AACvC,QAAM,OAAO,eAAe,MAAM,MAAM,eAAe,IAAI,CAAC;AAC5D,SAAO,OAAO,eAAe,SAAS,IAAI,QAAQ,KAAK,EAAE,CAAC;AAC5D;AACA,SAAS,WAAW,eAAe,WAAW;AAC5C,QAAM,OAAO,SAAS,SAAS;AAC/B,MAAI,WAAW,KAAK,QAAQ;AAC1B,WAAO;AACT,QAAM,YAAY,gBAAgB,kBAAkB,KAAK,QAAQ,IAAI,qBAAqB,KAAK,QAAQ;AACvG,SAAO,GAAG,KAAK,WAAW,GAAG,KAAK,QAAQ,OAAO,EAAE,GAAG,KAAK,QAAQ,EAAE,GAAG,SAAS,GAAG,KAAK,UAAU,EAAE,GAAG,KAAK,QAAQ,EAAE;AACzH;AC9IO,SAAS,eAAe,GAAG;AACR;AACtB,QAAI,KAAK,gBAAA;AACT,WAAO,GAAG,SAAS,yBAAyB;AAAA,EAC9C;AAEF;ACFO,SAAS,uBAAuB,UAAU,IAAI;AACnD,QAAM,aAAa,cAAa;AAChC,QAAM,cAAc,eAAc;AAClC,QAAM,YAAW,iCAAgB,GAAG,IAAI,WAAW;AACnD,SAAO,CAAC,SAAS;AACf,WAAO,SAAS,MAAM,gBAAgB,MAAM,IAAI,GAAG;AAAA,MACjD,UAAU,MAAM,QAAQ,QAAQ;AAAA,MAChC,UAAU,MAAM,QAAQ,QAAQ;AAAA,MAChC,SAAS,MAAM,QAAQ,SAAS,MAAM,SAAS,YAAY,YAAY,WAAW,MAAM;AAAA,MACxF,eAAe,WAAW;AAAA,MAC1B,MAAM;AAAA,IACZ,CAAK,CAAC;AAAA,EACJ;AACF;ACNO,SAAS,WAAW,SAAS;AAClC,QAAM,OAAO,WAAU;AACvB,QAAM,SAAS,mBAAkB;AACjC,QAAM,QAAQ,SAAQ;AACtB,QAAM,aAAa,cAAa;AAChC,QAAM,cAAc,uBAAuB;AAAA,IACzC,UAAU;AAAA,IACV,UAAU;AAAA,EACd,CAAG;AACD,QAAM,aAAa,uBAAuB;AAAA,IACxC,WAAW;AAAA,IACX,UAAU;AAAA,IACV,UAAU;AAAA,EACd,CAAG;AACD,QAAM,YAAY,SAAS,MAAM;AAC/B,UAAM,qBAAqB,CAAA;AAC3B,eAAW,OAAO,YAAY;AAC5B,UAAI,IAAI,WAAW,GAAG,GAAG;AACvB;AAAA,MACF;AACA,yBAAmB,GAAG,IAAI,QAAQ,WAAW,GAAG,CAAC;AACjD,UAAI,OAAO,mBAAmB,GAAG,MAAM,UAAU;AAC/C,mBAAW,KAAK,mBAAmB,GAAG,GAAG;AACvC,6BAAmB,GAAG,EAAE,CAAC,IAAI,QAAQ,mBAAmB,GAAG,EAAE,CAAC,CAAC;AAAA,QACjE;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,MACL,GAAG,MAAM,MAAM,aAAa,CAAA;AAAA,MAC5B,GAAG;AAAA,MACH,KAAK,QAAQ,WAAW,MAAM,IAAI,CAAC;AAAA,MACnC,MAAM,kBAAkB,mBAAmB,GAAG;AAAA,MAC9C,YAAY,QAAQ,mBAAmB,aAAa,KAAK,QAAQ,mBAAmB,aAAa;AAAA,MACjG,MAAM,QAAQ,YAAY,MAAM,IAAI,CAAC;AAAA,IAC3C;AAAA,EACE,CAAC;AACD,QAAM,qBAAqB,QAAQ;AAAA,IACjC,gBAAgB,EAAE,WAAW,UAAU,MAAK;AAAA,EAChD,CAAG;AACD,QAAM,MAAM,YAAY,MAAM;AAC5B,uBAAmB,MAAM;AAAA,MACvB,gBAAgB,EAAE,WAAW,UAAU,MAAK;AAAA,IAClD,CAAK;AAAA,EACH,GAAG,EAAE,MAAM,MAAM;AACjB,OAAK;AAAA,IACH,sBAAsB,CAAA,GAAI,YAAY;AACpC,YAAM,OAAO,CAAA;AACb,YAAM,QAAQ,MAAM,SAAS,mBAAmB,IAAI;AACpD,aAAO;AAAA,IACT,GAAG;AAAA,MACD,QAAQ,OAAO;AAAA,MACf,eAAe,WAAW;AAAA,IAChC,CAAK;AAAA,EACL;AACA;AACO,SAAS,4BAA4B;AAC1C,QAAM,SAAS,mBAAkB;AACjC,QAAM,aAAa,cAAc;AAAA,IAC/B,aAAa;AAAA,EACjB,CAAG;AACD,MAAI,OAAO,YAAY,WAAW,UAAU;AAC1C,UAAM,WAAW,OAAO,YAAY,WAAW;AAC/C,QAAI,kBAAkB;AAAA,MACpB,MAAM,MAAM,QAAQ,WAAW,IAAI;AAAA,MACnC,KAAK,MAAM,QAAQ,WAAW,GAAG;AAAA,IACvC;AACI,QAAI;AACJ,QAAI,OAAO,aAAa,UAAU;AAChC,wBAAkB;AAAA,QAChB,GAAG;AAAA,QACH,GAAG;AAAA,MACX;AACM,qBAAe,SAAS;AACxB,aAAO,gBAAgB;AAAA,IACzB,OAAO;AACL,qBAAe;AAAA,IACjB;AACA,QAAI,WAAW,SAAS;AACtB,YAAM,KAAK,WAAW,QAAQ,WAAW,GAAG,IAAI,WAAW,QAAQ,MAAM,CAAC,IAAI,WAAW;AACzF,sBAAgB,SAAS;AAAA,QACvB,uBAAuB,EAAE;AAAA,MACjC;AAAA,IACI;AACA,oBAAgB,YAAY,gBAAgB,aAAa,UAAU,YAAY;AAC/E,iBAAa,CAAC,eAAe,CAAC;AAAA,EAChC;AACF;AC5FA,MAAA,uDAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,WAAW;AAAA,IACT;AAAA,EACJ;AAAA,EACE,QAAQ;AACN,UAAM,QAAQ,SAAQ;AACtB,QAAI,MAAM,OAAO,OAAO;AACtB;AAAA,IACF;AACA,UAAM,aAAa,cAAa;AAChC,iBAAa;AAAA,MACX,cAAc;AAAA,QACZ,MAAM,MAAM,QAAQ,WAAW,IAAI,KAAK;AAAA,QACxC,YAAY,MAAM,QAAQ,WAAW,aAAa,KAAK;AAAA,QACvD,aAAa,MAAM,QAAQ,WAAW,WAAW,KAAK;AAAA,MAC9D,CAAO;AAAA,MACD,cAAa;AAAA,IACnB,CAAK;AACD,8BAAyB;AAAA,EAC3B;AACF,CAAC;ACzBD,MAAA,mDAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,MAAM,SAAS;AACb,eAAW,OAAO;AAAA,EACpB;AACF,CAAC;ACLD,MAAA,gEAAe,iCAAiB;AAAA,EAC9B,QAAQ;AACN,UAAM,QAAQ,gBAAe;AAC7B,UAAM,MAAM,OAAO,SAAS;AAC5B,QAAI,CAAC;AACH;AACF,YAAQ;AAAA,MACN,MAAM;AAAA,QACJ;AAAA,UACE,QAAQ;AAAA,UACR,WAAW,MAAM,IAAI,QAAQ;AAAA,UAC7B,aAAa,MAA8G;AAAA,QACrI;AAAA,MACA;AAAA,IACA,CAAK;AAAA,EACH;AACF,CAAC;AClBM,MAAM,gBAAgB,IAAI,OAAO,27NAA27N;ACCn+N,MAAM,gBAAgB;AACtB,MAAM,gBAAgB;AACtB,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAChC,SAAS,SAAS,WAAW;AAC3B,SAAO,cAAc,KAAK,SAAS,KAAK,cAAc,KAAK,UAAU,MAAM,GAAG,CAAC,CAAC;AAClF;AACA,SAAS,iBAAiB,WAAW;AACnC,SAAO,wBAAwB,KAAK,SAAS,KAAK,wBAAwB,KAAK,UAAU,MAAM,GAAG,CAAC,CAAC;AACtG;AACA,SAAS,MAAM,WAAW;AACxB,SAAO,mBAAmB,KAAK,SAAS;AAC1C;AACA,SAAS,UAAU,WAAW;AAC5B,SAAO,WAAW,KAAK,SAAS;AAClC;AACA,SAAS,UAAU,WAAW;AAC5B,SAAO,UAAU,KAAK,SAAS;AACjC;AACA,SAAS,QAAQ,WAAW;AAC1B,SAAO,WAAW,KAAK,SAAS;AAClC;AACA,MAAM,WAAW;AAAA,EACf,EAAE,MAAM,WAAW,OAAO,kBAAA;AAAA,EAC1B,EAAE,MAAM,QAAQ,OAAO,sBAAA;AAAA,EACvB,EAAE,MAAM,WAAW,OAAO,2BAAA;AAAA,EAC1B,EAAE,MAAM,UAAU,OAAO,qBAAA;AAAA,EACzB,EAAE,MAAM,UAAU,OAAO,sBAAA;AAC3B;AACA,SAAS,eAAe,WAAW;AACjC,aAAW,WAAW,UAAU;AAC9B,QAAI,QAAQ,MAAM,KAAK,SAAS,GAAG;AACjC,aAAO,QAAQ;AAAA,IACjB;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAwB,cAAc,WAAW,UAAU,IAAI;AAC7D,MAAI,SAAS;AACb,MAAI,iBAAiB;AACrB,MAAI,MAAM;AACV,MAAI,UAAU;AACd,MAAI,cAAc,qBAAqB;AACrC,QAAI,QAAQ,6BAA6B,MAAM,QAAQ;AACrD,eAAS;AACT,uBAAiB;AAAA,IACnB;AACA,QAAI,QAAQ,6BAA6B,MAAM,QAAQ;AACrD,eAAS;AACT,uBAAiB;AAAA,IACnB;AACA,QAAI,QAAQ,8BAA8B,MAAM,QAAQ;AACtD,eAAS;AACT,uBAAiB;AAAA,IACnB;AACA,QAAI,QAAQ,0BAA0B,MAAM,QAAQ;AAClD,YAAM;AAAA,IACR;AACA,QAAI,QAAQ,8BAA8B,MAAM,QAAQ;AACtD,gBAAU;AAAA,IACZ;AAAA,EACF,WAAW,WAAW,QAAQ,gBAAgB,GAAG;AAC/C,YAAQ,QAAQ,gBAAgB,GAAA;AAAA,MAC9B,KAAK;AACH,iBAAS;AACT,yBAAiB;AACjB;AAAA,MACF,KAAK;AACH,iBAAS;AACT,yBAAiB;AACjB;AAAA,MACF,KAAK;AACH,iBAAS;AACT,yBAAiB;AACjB;AAAA,IAAA;AAAA,EAEN,OAAO;AACL,aAAS,SAAS,SAAS;AAC3B,qBAAiB,iBAAiB,SAAS;AAC3C,UAAM,MAAM,SAAS;AACrB,cAAU,UAAU,SAAS;AAAA,EAC/B;AACA,QAAM,UAAU,UAAU,SAAS;AACnC,QAAM,QAAQ,QAAQ,SAAS;AAC/B,QAAM,cAAc,eAAe,SAAS;AAC5C,QAAM,WAAW,gBAAgB;AACjC,QAAM,YAAY,gBAAgB;AAClC,QAAM,SAAS,gBAAgB;AAC/B,QAAM,WAAW,gBAAgB;AACjC,QAAM,YAAY,gBAAgB;AAClC,QAAM,YAAY,cAAc,KAAK,SAAS;AAC9C,SAAO;AAAA,IACL;AAAA,IACA,UAAU;AAAA,IACV,kBAAkB;AAAA,IAClB,UAAU,CAAC,UAAU;AAAA,IACrB,WAAW,CAAC;AAAA,IACZ,OAAO;AAAA,IACP,WAAW;AAAA,IACX,WAAW;AAAA,IACX,SAAS;AAAA,IACT,SAAS,SAAS;AAAA,IAClB,mBAAmB,CAAC;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ;AC7GA,MAAA,qDAAe,iCAAiB,MAAM;AACpC,QAAM,gBAAgB,iCAAA;AACtB,QAAM,mBAAmB,cAAc,OAAO,OAAO;AACrD,MAAI;AACoB;AACtB,UAAM,UAAU,kBAAA;AAChB,UAAM,YAAY,QAAQ,YAAY,KAAK;AAC3C,YAAQ,SAAS,cAAc,WAAW,OAAO,CAAC;AAAA,EACpD;AAcA,SAAO;AAAA,IACL,SAAS;AAAA,MACP,QAAQ;AAAA,IAAA;AAAA,EACV;AAEJ,CAAC;ACzBD,MAAA,0EAAe,iCAAiB;AAAA,EAC9B,SAAS;AAAA,EACT,QAAQ;AACN,UAAM,OAAO,WAAU;AACvB,QAAI,CAAC;AACH;AACF,UAAM,WAAW,uBAAuB;AAAA,MACtC,UAAU;AAAA,MACV,UAAU;AAAA,MACV,WAAW;AAAA,IACjB,CAAK;AACD,SAAK,IAAI;AAAA,MACP,KAAK;AAAA,MACL,OAAO;AAAA,QACL,gBAAgB,OAAO,EAAE,WAAW;AAClC,qBAAW,OAAO,MAAM;AACtB,gBAAI,IAAI,QAAQ;AACd;AACF,gBAAI,IAAI,MAAM,aAAa,kBAAkB,IAAI,MAAM,aAAa,cAAc,IAAI,MAAM,SAAS;AACnG;AACF,gBAAI,OAAO,IAAI,MAAM,YAAY,YAAY,CAAC,IAAI,MAAM,QAAQ,KAAI,KAAM,IAAI,MAAM,QAAQ,WAAW,MAAM,KAAK,IAAI,MAAM,QAAQ,WAAW,IAAI;AACjJ;AACF,gBAAI,MAAM,UAAU,MAAM,SAAS,IAAI,MAAM,OAAO,CAAC;AAAA,UACvD;AAAA,QACF;AAAA,MACR;AAAA,IACA,CAAK;AAAA,EACH;AACF,CAAC;AC7BD,MAAA,4DAAe,iCAAE;AAAA,EACf,SAAS;AAAA,EACT,MAAM,QAAQ;AAAC,QAAI,QAAQ;AACzB,UAAM,OAAO,WAAU;AACvB,UAAI,iBAAoB,SAAA,6BAAA,MAAA,IAAA;AACd;AACR,YAAM,QAAQ,gBAAI;AAClB,YAAM,cAAe,CAAC,QAAC,SAAA,IAAAR,aAAA,MAAA,cAAA,KAAA,CAAA,GAAA,SAAA,MAAA,QAAA,UAAA,GAAA;AACvB,qBAAe,QAAQ;AAAA,QACrB,MAAM,WAAW;AAAA,QAClB,SAAA,WAAA;AAAA,MACP;AAAA,IACI;AACA,QAAI,eAAe,OAAO;AACxB,YAAM,EAAE,MAAK,WAAA,QAAA,IAAA,eAAA;AACb,UAAI;AACF,aAAK,KAAI,SAAA;AACX,UAAI;AACN,mBAAA,OAAA;AAAA,IACF;AAAA,EACF;;AChBO,SAAS,gBAAgB;AAC9B,QAAM,aAAa,cAAc;AAAA,IAC/B,aAAa;AAAA,EACjB,CAAG;AACD,QAAM,uBAAuB,MAAM,QAAQ,WAAW,aAAa,KAAK,QAAQ,WAAW,aAAa,KAAK;AAC7G,QAAM,OAAO,WAAU;AACvB,OAAK,IAAI,oBAAoB;AAC7B,QAAM,EAAE,yBAAyB,mBAAkB,KAAK,iCAAgB,GAAG,OAAO,WAAW;AAC7F,QAAM,QAAQ,SAAQ;AACtB,QAAM,aAAa,uBAAuB,EAAE,UAAU,MAAM,UAAU,MAAM;AAC5E,QAAM,MAAM,SAAQ;AACpB,QAAM,eAAe,SAAS,MAAM;AAClC,QAAI,IAAI,OAAO;AACb,aAAO;AAAA,IACT;AACA,UAAM,EAAE,MAAK,IAAK;AAClB,QAAI,MAAM,WAAW,MAAM,QAAQ,GAAG,EAAE,SAAS,MAAM;AACvD,QAAI,oBAAoB;AACtB,UAAI;AACF,cAAM,IAAI,kBAAkB,sBAAsB;AAAA,MACpD,QAAQ;AACN,cAAM,IAAI,YAAW;AAAA,MACvB;AAAA,IACF;AACA,UAAM,gBAAgB,OAAO;AAAA,MAC3B,OAAO,QAAQ,KAAK,EAAE,OAAO,CAAC,CAAC,GAAG,MAAM,wBAAwB,SAAS,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;AAAA;AAAA,IAE1H;AACI,UAAM,OAAO,OAAO,KAAK,aAAa,EAAE,SAAS,GAAG,GAAG,IAAI,eAAe,aAAa,CAAC,KAAK;AAC7F,WAAO,EAAE,KAAK,aAAa,KAAI;AAAA,EACjC,CAAC;AACD,QAAM,kBAAkB;AAAA;AAAA,IAEtB,aAAa;AAAA,EACjB;AACE,UAAQ;AAAA,IACN,WAAW,EAAE,MAAM,qBAAoB;AAAA,IACvC,gBAAgB;AAAA,MACd,MAAM,MAAM;AAAA,MACZ,UAAU,MAAM,WAAW;AAAA,IACjC;AAAA,IACI,eAAe;AAAA,IACf,MAAM,CAAC,MAAM,aAAa,KAAK;AAAA,EACnC,GAAK,eAAe;AAClB,QAAM,UAAU;AAAA,IACd,QAAQ;AAAA,IACR,OAAO,MAAM;AACX,YAAM,MAAM,aAAa;AACzB,aAAO,MAAM,IAAI,OAAO;AAAA,IAC1B;AAAA,IACA,UAAU,MAAM;AACd,YAAM,SAAS,qBAAoB;AACvB;AACV,cAAM,IAAI,OAAO,QAAQ,KAAK,GAAG;AACjC,YAAI,EAAE,SAAS,GAAG,GAAG;AACnB,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA,YAAY,WAAW;AAAA,EAC3B;AACE,MAAI,WAAW;AACb,YAAQ,cAAc,WAAW;AACnC,MAAI,WAAW,SAAS;AACtB,UAAM,KAAK,WAAW,QAAQ,WAAW,GAAG,IAAI,WAAW,UAAU,IAAI,WAAW,OAAO;AAC3F,YAAQ,iBAAiB;AACzB,YAAQ,cAAc;AAAA,EACxB;AACA,aAAW,SAAS,eAAe;AACrC;AC3EA,MAAA,uDAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,IACH,SAAS;AAAA,EACb;AAAA,EACE,QAAQ;AACN,kBAAa;AAAA,EACf;AACF,CAAC;ACID,MAAA,UAAe;AAAA,EACb;AAAA,EACAS;AAAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AC7BA,MAAM,yBAAyB,OAAO,gBAAgB;AACtD,MAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA,EAIvB,MAAM,EAAE,MAAM,SAAS,SAAS,OAAM;AAAA,EACtC,aAAa,EAAE,MAAM,OAAM;AAC7B;AACA,MAAM,iBAAiB,CAAC,WAAW;AACjC,QAAM,QAAQ,OAAO;AAAA,IACnB,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,UAAU,MAAM;AAAA,EAClE;AACE,MAAI,OAAO,MAAM,SAAS,aAAa;AACrC,UAAM,cAAc,MAAM,OAAO,cAAc;AAAA,EACjD;AACA,MAAI,OAAO,MAAM,mBAAmB,aAAa;AAC/C,UAAM,cAAc,MAAM;AAAA,EAC5B;AACA,SAAO;AACT;AACA,SAAS,sBAAsB;AAC7B,SAAO,OAAO,wBAAwB,wBAAwB,IAAI;AACpE;AACA,SAAS,yBAAyB;AAChC,QAAM,OAAO,OAAO,wBAAwB,IAAI;AAChD,MAAI,MAAM;AACR,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,SAAS,EAAE;AACzB,QAAMN,SAAQ,QAAQ,KAAK;AAC3B,QAAM,MAAM,EAAE,OAAO,OAAAA,OAAK;AAC1B,UAAQ,wBAAwB,GAAG;AACnC,SAAO;AACT;AACA,MAAM,cAAc;AAAA,EAClB,WAAW;AAAA,EACX,gBAAgB;AAAA,EAChB,WAAW;AAAA,IACT,MAAM;AAAA,IACN,SAAS;AAAA,EACb;AAAA,EACE,OAAO,EAAE,MAAM,CAAC,QAAQ,QAAQ,KAAK,GAAG,SAAS,OAAM;AAAA,EACvD,iBAAiB;AAAA,IACf,MAAM;AAAA,IACN,SAAS;AAAA,EACb;AAAA,EACE,aAAa;AAAA,EACb,KAAK;AAAA,EACL,WAAW;AAAA,IACT,MAAM;AAAA,IACN,SAAS;AAAA,EACb;AAAA,EACE,cAAc;AAAA,EACd,aAAa;AAAA,EACb,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,SAAS;AAAA,EACb;AAAA,EACE,IAAI;AAAA,EACJ,WAAW;AAAA,EACX,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,SAAS;AAAA,EACT,WAAW;AAAA,EACX,UAAU;AAAA,EACV,MAAM;AAAA,EACN,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,YAAY;AAAA,IACV,MAAM;AAAA,IACN,SAAS;AAAA,EACb;AAAA,EACE,OAAO,EAAE,MAAM,CAAC,QAAQ,QAAQ,KAAK,GAAG,SAAS,OAAM;AAAA,EACvD,UAAU;AAAA,EACV,OAAO;AAAA,EACP,WAAW;AAAA;AAAA;AAAA;AAAA,EAIX,gBAAgB,CAAC,QAAQ,MAAM;AAAA;AAAA;AAAA;AAAA,EAI/B,aAAa,EAAE,MAAM,CAAC,QAAQ,MAAM,EAAC;AACvC;AACwB,gBAAgB;AAAA,EACtC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,IACH,OAAO;AAAA,EACX;AAAA,EACE,MAAM,OAAO,EAAE,SAAS;AACtB,UAAM,EAAE,MAAK,IAAK,oBAAmB;AACrC,UAAM,aAAa,CAAA;AACnB,UAAM,MAAM,MAAM,SAAS,KAAK,CAAA,CAAE,IAAI;AAEtC,WAAO,MAAM;AACX,YAAM,WAAW,eAAe,KAAK;AACrC,YAAM,aAAa,MAAM,UAAO;AAChC,YAAM,cAAc,aAAa,WAAW,OAAO,CAAC,EAAE,SAAQ,MAAO,QAAQ,EAAE,IAAI,CAAC,EAAE,eAAe,QAAQ,EAAE,KAAK,EAAE,IAAI;AAC1H,UAAI,aAAa;AACf,iBAAS,YAAY;AAAA,MACvB;AACA,YAAM,SAAS,GAAG,IAAI;AACtB,aAAO;AAAA,IACT;AAAA,EACF;AACF,CAAC;AACmB,gBAAgB;AAAA,EAClC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,aAAa;AAAA,IACb,UAAU;AAAA,IACV,eAAe;AAAA,IACf,MAAM;AAAA,IACN,UAAU;AAAA,IACV,YAAY;AAAA,IACZ,aAAa;AAAA,IACb,WAAW;AAAA,IACX,OAAO;AAAA,IACP,UAAU;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,IACf;AAAA,IACI,gBAAgB;AAAA,IAChB,KAAK;AAAA,IACL,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA;AAAA,IAEN,SAAS;AAAA;AAAA,IAET,QAAQ;AAAA,EACZ;AAAA,EACE,MAAM,OAAO;AACX,UAAM,EAAE,MAAK,IAAK,oBAAmB;AACrC,UAAM,SAAS,CAAA;AACf,UAAM,MAAM,MAAM,KAAK,KAAK,CAAA,CAAE,IAAI;AAElC,WAAO,MAAM;AACX,YAAM,KAAK,GAAG,IAAI,eAAe,KAAK;AACtC,aAAO;AAAA,IACT;AAAA,EACF;AACF,CAAC;AACmB,gBAAgB;AAAA,EAClC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,GAAG;AAAA,IACH,MAAM;AAAA,IACN,QAAQ;AAAA,EACZ;AAAA,EACE,MAAM,OAAO;AACX,UAAM,EAAE,MAAK,IAAK,oBAAmB;AAErC,WAAO,MAAM;AACX,YAAM,OAAO,eAAe,KAAK;AACjC,aAAO;AAAA,IACT;AAAA,EACF;AACF,CAAC;AACoB,gBAAgB;AAAA,EACnC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,MAAM,GAAG,EAAE,SAAS;AAClB,UAAM,EAAE,MAAK,IAAK,oBAAmB;AAErC,WAAO,MAAM;AACX,YAAM,cAAc,MAAM,UAAO;AACjC,YAAM,QAAQ,cAAc,CAAC,GAAG,WAAW,OAAO,cAAc,CAAC,GAAG,QAAQ,IAAI;AAMhF,aAAO;AAAA,IACT;AAAA,EACF;AACF,CAAC;AACmB,gBAAgB;AAAA,EAClC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,GAAG;AAAA,IACH,SAAS;AAAA,IACT,SAAS;AAAA,IACT,WAAW;AAAA,IACX,MAAM;AAAA,IACN,UAAU;AAAA,EACd;AAAA,EACE,MAAM,OAAO;AACX,UAAM,EAAE,MAAK,IAAK,oBAAmB;AACrC,UAAM,SAAS,CAAA;AACf,UAAM,MAAM,MAAM,KAAK,KAAK,CAAA,CAAE,IAAI;AAElC,WAAO,MAAM;AACX,YAAM,OAAO,EAAE,cAAc,MAAM,WAAW,GAAG,eAAe,KAAK,EAAC;AACtE,UAAI,eAAe,MAAM;AACvB,eAAO,KAAK;AAAA,MACd;AACA,YAAM,KAAK,GAAG,IAAI;AAClB,aAAO;AAAA,IACT;AAAA,EACF;AACF,CAAC;AACoB,gBAAgB;AAAA,EACnC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,IACH,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA;AAAA,IAEP,QAAQ;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,IACf;AAAA,EACA;AAAA,EACE,MAAM,OAAO,EAAE,SAAS;AACtB,UAAM,EAAE,MAAK,IAAK,oBAAmB;AACrC,UAAM,UAAU,CAAA;AAChB,UAAM,MAAM,MAAM,MAAM,KAAK,CAAA,CAAE,IAAI;AAEnC,WAAO,MAAM;AACX,YAAM,QAAQ,eAAe,KAAK;AAClC,YAAM,cAAc,MAAM,UAAO,IAAO,CAAC,GAAG;AAC5C,UAAI,aAAa;AAIf,cAAM,MAAM,GAAG,IAAI;AACnB,cAAM,cAAc;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF,CAAC;AACmB,gBAAgB;AAAA,EAClC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO,CAAC,QAAQ,QAAQ;AACtB,2BAAsB;AACtB,WAAO,MAAM,IAAI,MAAM,UAAO;AAAA,EAChC;AACF,CAAC;AACM,MAAM,OAAO,gBAAgB;AAAA,EAClC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,GAAG;AAAA,IACH,UAAU;AAAA,IACV,SAAS;AAAA,IACT,OAAO;AAAA,EACX;AAAA,EACE,MAAM,QAAQ,KAAK;AACjB,UAAM,EAAE,MAAK,IAAK,oBAAmB;AAErC,WAAO,MAAM;AACX,YAAM,YAAY,EAAE,GAAG,QAAQ,GAAG,IAAI,MAAK;AAC3C,aAAO,IAAI,MAAM,UAAO;AAAA,IAC1B;AAAA,EACF;AACF,CAAC;AACM,MAAM,OAAO,gBAAgB;AAAA,EAClC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,EACP,MAAM,QAAQ,KAAK;AACjB,UAAM,EAAE,MAAK,IAAK,oBAAmB;AAErC,WAAO,MAAM;AACX,YAAM,YAAY,EAAE,GAAG,QAAQ,GAAG,IAAI,MAAK;AAC3C,aAAO,IAAI,MAAM,UAAO;AAAA,IAC1B;AAAA,EACF;AACF,CAAC;AChSM,SAAS,sBAAsB,MAAM,IAAI,SAAS,IAAI,OAAO;AAClE,MAA2B,CAAC,YAAY,aAAa,CAAC,OAAO;AAC3D;AAAA,EACF;AACA,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,GAAG,OAAO,MAAM,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,KAAI,EAAG,MAAM,GAAG,EAAE,CAAC,EAAE,KAAI,CAAE;AAAA,EAClE,EAAI,OAAO,CAAC,MAAM,KAAK,EAAE,SAAS,QAAQ,CAAC;AACzC,MAAI,CAAC,MAAM,QAAQ;AACjB;AAAA,EACF;AACA,eAAa,OAAO,qBAAqB,MAAM,IAAI,CAAC,MAAM,mBAAmB,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC;AAC7F;ACDO,SAAS,iBAAiB,MAAM,IAAI;AACzC,QAAM,YAAY,IAAI,MAAM,MAAM,EAAE,MAAK,EAAG,MAAM,GAAG,EAAE,IAAG,EAAG,MAAM,GAAG,EAAE,IAAG;AAC3E,SAAO;AACT;AAIO,SAAS,aAAa,KAAK;AAChC,SAAO,CAAC,QAAQ;AACd,WAAO,MAAM,IAAI,GAAG,KAAK,MAAM,IAAI;AAAA,EACrC;AACF;AACO,SAAS,0BAA0B,EAAE,WAAW,QAAQ,WAAW,KAAK,SAAQ,IAAK,IAAI;AAC9F,MAAI,CAAC,WAAW;AACd,gBAAY,CAAC,KAAK,UAAU,GAAG,GAAG,IAAI,KAAK;AAAA,EAC7C;AACA,MAAI,UAAU,OAAO,WAAW,YAAY;AAC1C,aAAS,aAAa,MAAM;AAAA,EAC9B;AACA,QAAM,MAAM,YAAY,CAAA;AACxB,SAAO,KAAK,GAAG,EAAE,QAAQ,CAAC,aAAa;AACrC,QAAI,OAAO,IAAI,QAAQ,MAAM,YAAY;AACvC,UAAI,QAAQ,IAAI,aAAa,IAAI,QAAQ,CAAC;AAAA,IAC5C;AAAA,EACF,CAAC;AACD,SAAO,CAAC,YAAY,OAAO;AACzB,UAAM,aAAa,OAAO,QAAQ,SAAS,EAAE,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,OAAO,UAAU,WAAW,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AACtH,YAAM,SAAS,IAAI,GAAG;AACtB,UAAI,OAAO,WAAW,YAAY;AAChC,gBAAQ,OAAO,UAAU,GAAG,CAAC;AAAA,MAC/B;AACA,YAAM,OAAO,WAAW,aAAa,OAAO,GAAG,IAAI;AACnD,aAAO,UAAU,KAAK,KAAK;AAAA,IAC7B,CAAC;AACD,WAAO,WAAW,KAAK,QAAQ;AAAA,EACjC;AACF;AAcO,SAAS,UAAU,QAAQ,IAAI;AACpC,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,QAAI,MAAM,QAAQ,MAAM,EAAE,EAAE,MAAM,QAAQ,GAAG;AAC3C,aAAO,OAAO,SAAS,OAAO,EAAE;AAAA,IAClC;AAAA,EACF;AACF;AACO,SAAS,eAAe,QAAQ,IAAI;AACzC,MAAI,UAAU,UAAU,CAAC,MAAM,QAAQ;AACrC,WAAO,CAAA;AAAA,EACT;AACA,QAAM,YAA4B,oBAAI,IAAG;AACzC,aAAW,WAAW,MAAM,MAAM,GAAG,GAAG;AACtC,UAAM,IAAI,OAAO,SAAS,QAAQ,QAAQ,KAAK,EAAE,CAAC;AAClD,QAAI,GAAG;AACL,gBAAU,IAAI,CAAC;AAAA,IACjB;AAAA,EACF;AACA,SAAO,MAAM,KAAK,SAAS;AAC7B;AACO,SAAS,eAAe,WAAW;AACxC,MAAI,UAAU,WAAW,GAAG;AAC1B,UAAM,IAAI,MAAM,uFAAuF;AAAA,EACzG;AAQF;AACO,SAAS,WAAW,OAAO;AAChC,QAAM,QAAQ,CAAA;AACd,MAAI,OAAO,UAAU,UAAU;AAC7B,eAAWA,UAAS,MAAM,MAAM,QAAQ,EAAE,OAAO,CAAC,MAAM,CAAC,GAAG;AAC1D,YAAM,IAAIA,OAAM,MAAM,GAAG;AACzB,UAAI,EAAE,WAAW,GAAG;AAClB,cAAM,KAAK,IAAI,EAAE,CAAC,EAAE,KAAI;AAAA,MAC1B,OAAO;AACL,cAAM,EAAE,CAAC,EAAE,KAAI,CAAE,IAAI,EAAE,CAAC,EAAE,KAAI;AAAA,MAChC;AAAA,IACF;AAAA,EACF,OAAO;AACL,WAAO,OAAO,OAAO,KAAK;AAAA,EAC5B;AACA,SAAO;AACT;AChHO,eAAe,UAAU,MAAM,KAAK;AACzC,QAAM,OAAO,MAAM,WAAW,GAAG,EAAE,MAAM,CAAC,QAAQ;AAChD,YAAQ,MAAM,kCAAkC,KAAK,MAAM,EAAE;AAC7D,WAAO;AAAA,MACL,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,OAAO;AAAA,IACb;AAAA,EACE,CAAC;AACD,SAAO;AACT;AACA,eAAe,WAAW,KAAK;AACL;AACtB,UAAM,aAAa,MAAM,OAAO,YAAY,EAAE,KAAK,CAAC,MAAM,EAAE,SAAS;AACrE,UAAM,OAAO,MAAM,MAAM,GAAG,EAAE,KAAK,CAAC,QAAQ,IAAI,QAAQ;AACxD,UAAM,WAAW,WAAW,IAAI;AAChC,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,mDAAmD,GAAG,KAAK;AAAA,IAC7E;AACA,UAAM,EAAE,OAAO,OAAM,IAAK;AAC1B,UAAM,OAAO;AAAA,MACX;AAAA,MACA;AAAA,MACA,OAAO,SAAS,SAAS,QAAQ,SAAS;AAAA,IAChD;AACI,WAAO;AAAA,EACT;AAiBF;ACtCO,SAAS,YAAY,eAAe;AACzC,QAAM,MAAM;AAAA,IACV,SAAS;AAAA,EACb;AACE,QAAMO,YAAW,CAAC,OAAO,UAAU,CAAA,MAAO;AACxC,UAAM,QAAQ,aAAa,KAAK,OAAO,OAAO;AAC9C,QAA0B,YAAY,aAAa,cAAc,OAAO;AACtE,4BAAsB,MAAM,KAAK,QAAQ,cAAc,KAAK;AAAA,IAC9D;AACA,WAAO;AAAA,EACT;AACA,QAAM,OAAO,CAAC,OAAO,YAAY,CAAA,GAAI,UAAU,OAAO;AACpD,WAAOA,UAAS,OAAO;AAAA,MACrB,GAAG;AAAA,MACH,WAAW,KAAK,WAAW,QAAQ,aAAa,CAAA,CAAE;AAAA,IACxD,CAAK,EAAE;AAAA,EACL;AACA,aAAW,cAAc,cAAc,SAAS;AAC9C,SAAK,UAAU,IAAI,CAAC,QAAQ,WAAW,YAAY,KAAK,QAAQ,WAAW,EAAE,GAAG,cAAc,QAAQ,UAAU,GAAG,GAAG,SAAS;AAAA,EACjI;AACA,OAAK,UAAU;AACf,OAAK,WAAWA;AAChB,OAAK,UAAU,CAAC,OAAO,YAAY,QAAQ,KAAK,OAAO,OAAO;AAC9D,OAAK,WAAW,CAAC,OAAO,YAAY,SAAS,KAAK,OAAO,OAAO;AAChE,MAAI,OAAO;AACX,SAAO;AACT;AACA,eAAe,QAAQ,KAAK,OAAO,SAAS;AAC1C,QAAM,QAAQ,aAAa,KAAK,OAAO,EAAE,GAAG,SAAS;AACrD,MAAI,OAAO,MAAM,YAAY,YAAY;AACvC,WAAO,MAAM,MAAM,QAAO;AAAA,EAC5B,OAAO;AACL,WAAO,MAAM,UAAU,KAAK,MAAM,GAAG;AAAA,EACvC;AACF;AACA,SAAS,aAAa,KAAK,OAAO,SAAS;AACzC,MAAI,SAAS,OAAO,UAAU,UAAU;AACtC,UAAM,IAAI,UAAU,oCAAoC,OAAO,KAAK,KAAK,KAAK,UAAU,KAAK,CAAC,GAAG;AAAA,EACnG;AACA,MAAI,CAAC,SAAS,MAAM,WAAW,OAAO,GAAG;AACvC,WAAO;AAAA,MACL,KAAK;AAAA,IACX;AAAA,EACE;AACA,QAAM,EAAE,UAAU,SAAQ,IAAK,YAAY,KAAK,QAAQ,YAAY,IAAI,QAAQ,QAAQ;AACxF,QAAM,SAAS,UAAU,KAAK,QAAQ,MAAM;AAC5C,UAAQ,YAAY,KAAK,IAAI,QAAQ,iBAAiB,KAAK;AAC3D,MAAI,CAAC,SAAS,eAAe;AAC3B,eAAWF,SAAQ,IAAI,QAAQ,OAAO;AACpC,UAAI,MAAM,WAAWA,KAAI,GAAG;AAC1B,cAAM,QAAQ,IAAI,QAAQ,MAAMA,KAAI;AACpC,YAAI,OAAO;AACT,kBAAQ,QAAQ,OAAO,MAAM,MAAMA,MAAK,MAAM,CAAC;AAAA,QACjD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,SAAS,mBAAmB,YAAY,KAAK,GAAG;AAClD,UAAM,YAAY,SAAS,KAAK,EAAE;AAClC,QAAI,CAAC,IAAI,QAAQ,QAAQ,KAAK,CAAC,MAAM,MAAM,SAAS,GAAG;AACrD,aAAO;AAAA,QACL,KAAK;AAAA,MACb;AAAA,IACI;AAAA,EACF;AACA,QAAM,WAAW,KAAK,SAAS,QAAQ,QAAQ;AAC/C,WAAS,YAAY,EAAE,GAAG,SAAS,UAAS;AAC5C,QAAM,iBAAiB,SAAS,UAAU;AAC1C,MAAI,SAAS,WAAW,OAAO;AAC7B,aAAS,UAAU,QAAQ,UAAU,SAAS,UAAU,KAAK;AAAA,EAC/D;AACA,MAAI,SAAS,WAAW,QAAQ;AAC9B,aAAS,UAAU,SAAS,UAAU,SAAS,UAAU,MAAM;AAAA,EACjE;AACA,QAAM,QAAQ,SAAS,SAAS,OAAO,UAAU,GAAG;AACpD,QAAM,SAAS,MAAM,UAAU,kBAAkB;AACjD,SAAO;AACT;AACA,SAAS,YAAY,KAAK,MAAM;AAC9B,QAAM,WAAW,IAAI,QAAQ,UAAU,IAAI;AAC3C,MAAI,CAAC,UAAU;AACb,UAAM,IAAI,MAAM,uBAAuB,IAAI;AAAA,EAC7C;AACA,SAAO;AACT;AACA,SAAS,UAAU,KAAK,MAAM;AAC5B,MAAI,CAAC,MAAM;AACT,WAAO,CAAA;AAAA,EACT;AACA,MAAI,CAAC,IAAI,QAAQ,QAAQ,IAAI,GAAG;AAC9B,UAAM,IAAI,MAAM,qBAAqB,IAAI;AAAA,EAC3C;AACA,SAAO,IAAI,QAAQ,QAAQ,IAAI;AACjC;AACA,SAAS,SAAS,KAAK,OAAO,MAAM;AAClC,QAAM,QAAQ,UAAU,KAAK,WAAW,KAAK;AAC7C,QAAM,SAAS,UAAU,KAAK,WAAW,MAAM;AAC/C,QAAM,QAAQ,WAAW,KAAK,KAAK;AACnC,QAAM,YAAY,KAAK,WAAW,KAAI,IAAK,eAAe,KAAK,UAAU,KAAI,CAAE,IAAI,IAAI,QAAQ;AAC/F,iBAAe,SAAS;AACxB,QAAM,UAAU,SAAS,SAAS,SAAS,QAAQ;AACnD,QAAM,eAAe,CAAA;AACrB,QAAM,iBAAiB,CAAA;AACvB,MAAI,OAAO,KAAK,KAAK,EAAE,UAAU,GAAG;AAClC,eAAW,OAAO,OAAO;AACvB,YAAM,UAAU,gBAAgB,KAAK,OAAO,MAAM,GAAG,CAAC,GAAG,QAAQ,SAAS,GAAG;AAC7E,UAAI,YAAY,QAAQ;AACtB;AAAA,MACF;AACA,mBAAa,KAAK;AAAA,QAChB,MAAM,QAAQ;AAAA,QACd,gBAAgB,QAAQ;AAAA,QACxB,OAAO,eAAe,QAAQ,cAAc;AAAA,MACpD,CAAO;AACD,iBAAW,WAAW,WAAW;AAC/B,uBAAe,KAAK;AAAA,UAClB,OAAO,QAAQ,UAAU;AAAA,UACzB,KAAK,cAAc,KAAK,OAAO,MAAM,SAAS,OAAO;AAAA,QAC/D,CAAS;AAAA,MACH;AAAA,IACF;AACA,yBAAqB,YAAY;AAAA,EACnC,OAAO;AACL,eAAW,WAAW,WAAW;AAC/B,YAAM,MAAM,OAAO,KAAK,KAAK,EAAE,CAAC;AAChC,UAAI,UAAU,MAAM,gBAAgB,KAAK,OAAO,MAAM,GAAG,CAAC,GAAG,QAAQ,SAAS,GAAG,IAAI;AACrF,UAAI,YAAY,QAAQ;AACtB,kBAAU;AAAA,UACR,MAAM;AAAA,UACN,gBAAgB;AAAA,UAChB,SAAS,KAAK,WAAW;AAAA,UACzB,UAAU,KAAK,WAAW;AAAA,QACpC;AAAA,MACM;AACA,qBAAe,KAAK;AAAA,QAClB,OAAO;AAAA,QACP,KAAK,cAAc,KAAK,OAAO,MAAM,SAAS,OAAO;AAAA,MAC7D,CAAO;AAAA,IACH;AAAA,EACF;AACA,yBAAuB,cAAc;AACrC,QAAM,iBAAiB,eAAe,eAAe,SAAS,CAAC;AAC/D,QAAM,WAAW,aAAa,SAAS,aAAa,IAAI,CAAC,MAAM,GAAG,EAAE,QAAQ,EAAE,QAAQ,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,KAAK,IAAI,IAAI;AACxH,QAAM,SAAS,WAAW,MAAM;AAChC,QAAM,YAAY,eAAe,IAAI,CAAC,MAAM,GAAG,EAAE,GAAG,IAAI,EAAE,KAAK,GAAG,MAAM,EAAE,EAAE,KAAK,IAAI;AACrF,SAAO;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,KAAK,gBAAgB;AAAA,EACzB;AACA;AACA,SAAS,gBAAgB,KAAK,MAAM,QAAQ,SAAS,KAAK;AACxD,QAAM,iBAAiB,IAAI,QAAQ,WAAW,IAAI,QAAQ,QAAQ,GAAG,KAAK,OAAO,SAAS,GAAG;AAC7F,QAAM,UAAU,KAAK,SAAS,IAAI;AAClC,MAAI,CAAC,WAAW,QAAQ,KAAK,IAAI,GAAG;AAClC,WAAO,OAAO;AAAA,EAChB;AACA,MAAI,CAAC,WAAW,CAAC,KAAK,SAAS,IAAI,GAAG;AACpC,WAAO;AAAA,EACT;AACA,MAAI,UAAU,OAAO,SAAS,IAAI;AAClC,MAAI,CAAC,kBAAkB,CAAC,SAAS;AAC/B,WAAO;AAAA,EACT;AACA,MAAI,SAAS;AACX,cAAU,KAAK,MAAM,UAAU,MAAM,cAAc;AAAA,EACrD;AACA,QAAM,WAAW,UAAU,KAAK,MAAM,UAAU,OAAO,IAAI;AAC3D,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA;AACA,SAAS,cAAc,KAAK,OAAO,MAAM,SAAS,SAAS;AACzD,SAAO,IAAI;AAAA,IACT;AAAA,IACA;AAAA,MACE,GAAG,KAAK;AAAA,MACR,OAAO,QAAQ,UAAU,QAAQ,UAAU,UAAU;AAAA,MACrD,QAAQ,QAAQ,WAAW,QAAQ,WAAW,UAAU;AAAA,IAC9D;AAAA,IACI;AAAA,EACJ;AACA;AACA,SAAS,qBAAqB,cAAc;AAC1C,eAAa,KAAK,CAAC,IAAI,OAAO,GAAG,iBAAiB,GAAG,cAAc;AACnE,MAAI,gBAAgB;AACpB,WAAS,IAAI,aAAa,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,UAAM,cAAc,aAAa,CAAC;AAClC,QAAI,YAAY,UAAU,eAAe;AACvC,mBAAa,OAAO,GAAG,CAAC;AAAA,IAC1B;AACA,oBAAgB,YAAY;AAAA,EAC9B;AACA,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,iBAAa,CAAC,EAAE,QAAQ,aAAa,IAAI,CAAC,GAAG,SAAS;AAAA,EACxD;AACF;AACA,SAAS,uBAAuB,gBAAgB;AAC9C,iBAAe,KAAK,CAAC,IAAI,OAAO,GAAG,QAAQ,GAAG,KAAK;AACnD,MAAI,gBAAgB;AACpB,WAAS,IAAI,eAAe,SAAS,GAAG,KAAK,GAAG,KAAK;AACnD,UAAM,cAAc,eAAe,CAAC;AACpC,QAAI,YAAY,UAAU,eAAe;AACvC,qBAAe,OAAO,GAAG,CAAC;AAAA,IAC5B;AACA,oBAAgB,YAAY;AAAA,EAC9B;AACF;ACrNO,MAAM,sBAAsB,0BAA0B;AAAA,EAC3D,QAAQ;AAAA,IACN,QAAQ;AAAA,IACR,KAAK;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,YAAY;AAAA,EAChB;AAAA,EACE,UAAU;AAAA,EACV,WAAW,CAAC,KAAK,QAAQ,YAAY,GAAG,IAAI,MAAM,YAAY,GAAG;AACnE,CAAC;AACM,MAAM,WAAW,CAAC,KAAK,EAAE,YAAY,CAAA,GAAI,SAAAG,SAAO,IAAK,CAAA,GAAI,QAAQ;AACtE,MAAI,UAAU,SAAS,UAAU,QAAQ;AACvC,cAAU,SAAS,GAAG,UAAU,KAAK,IAAI,UAAU,MAAM;AACzD,WAAO,UAAU;AACjB,WAAO,UAAU;AAAA,EACnB;AACA,QAAM,SAAS,oBAAoB,SAAS,KAAK;AACjD,MAAI,CAACA,UAAS;AACZ,IAAAA,WAAU,QAAQ,IAAI,QAAQ,KAAK,SAAS,OAAO;AAAA,EACrD;AACA,SAAO;AAAA,IACL,KAAK,QAAQA,UAAS,QAAQ,WAAW,GAAG,CAAC;AAAA,EACjD;AACA;AACO,MAAM,kBAAkB;AACxB,MAAM,gBAAgB;;;;;;;;AC3BpB,MAAM,eAAe;AAAA,EAC1B,GAAG;AAAA,IACL,WAAW;AAAA,MACT,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,OAAO;AAAA,MACP,OAAO;AAAA,IACX;AAAA,IACE,WAAW,CAAA;AAAA,IACX,YAAY;AAAA,IACZ,WAAW,CAAA;AAAA,IACX,SAAS,CAAA;AAAA,IACT,aAAa;AAAA,MACX;AAAA,MACA;AAAA,IACJ;AAAA,IACE,UAAU;AAAA,MACR;AAAA,MACA;AAAA,IACJ;AAAA,IACE,WAAW;AAAA,EACb;AAAA,EACI,WAAW;AAAA,IACP,CAAC,KAAK,GAAG,EAAE,UAAU,0DAA0D,UAAU,CAAA,EAAE;AAAA,EACnG;AACA;AC5BO,MAAM,WAAW,CAAC,UAAU;AACjC,QAAM,SAAS,iCAAgB;AAC/B,QAAM,UAAU,WAAU;AAC1B,SAAO,QAAQ,QAAQ,QAAQ,SAAS,QAAQ,OAAO,YAAY;AAAA,IACjE,GAAG;AAAA,IACH,OAAgB,QAAQ,YAAY;AAAA,IACpC,MAAM;AAAA,MACJ,SAAS,OAAO,IAAI;AAAA,IAC1B;AAAA,IACI,eAAe;AAAA,EACnB,CAAG;AACH;ACXO,MAAM,iBAAiB;AAAA;AAAA,EAE5B,KAAK,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA;AAAA,EAEpC,QAAQ,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EACvC,SAAS,EAAE,MAAM,CAAC,QAAQ,MAAM,GAAG,UAAU,MAAK;AAAA,EAClD,YAAY,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EAC3C,KAAK,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EACpC,WAAW,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA;AAAA,EAE1C,QAAQ,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EACvC,UAAU,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EACzC,OAAO,EAAE,MAAM,CAAC,QAAQ,MAAM,GAAG,UAAU,MAAK;AAAA,EAChD,WAAW,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EAC1C,SAAS;AAAA,IACP,MAAM,CAAC,SAAS,MAAM;AAAA,IACtB,UAAU;AAAA,EACd;AAAA;AAAA,EAEE,OAAO,EAAE,MAAM,CAAC,QAAQ,MAAM,GAAG,UAAU,MAAK;AAAA,EAChD,QAAQ,EAAE,MAAM,CAAC,QAAQ,MAAM,GAAG,UAAU,MAAK;AAAA,EACjD,KAAK,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EACpC,gBAAgB,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EAC/C,QAAQ,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EACvC,UAAU,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EACzC,OAAO,EAAE,MAAM,SAAS,UAAU,MAAK;AAAA,EACvC,SAAS;AAAA,IACP,MAAM;AAAA,IACN,UAAU;AAAA,IACV,WAAW,CAAC,QAAQ,CAAC,QAAQ,OAAO,EAAE,SAAS,GAAG;AAAA,EACtD;AAAA,EACE,aAAa;AAAA,IACX,MAAM,CAAC,SAAS,MAAM;AAAA,IACtB,UAAU;AAAA,IACV,WAAW,CAAC,QAAQ,CAAC,aAAa,mBAAmB,IAAI,MAAM,KAAK,EAAE,SAAS,GAAG;AAAA,EACtF;AAAA,EACE,UAAU;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,WAAW,CAAC,QAAQ,CAAC,SAAS,QAAQ,MAAM,EAAE,SAAS,GAAG;AAAA,EAC9D;AAAA;AAAA,EAEE,OAAO,EAAE,MAAM,CAAC,MAAM,GAAG,UAAU,MAAK;AAC1C;AACO,MAAM,eAAe,CAAC,UAAU;AACrC,QAAM,UAAU,SAAS,MAAM;AAC7B,WAAO;AAAA,MACL,UAAU,MAAM;AAAA,MAChB,QAAQ,MAAM;AAAA,IACpB;AAAA,EACE,CAAC;AACD,QAAM,QAAQ,SAAS,MAAM;AAC3B,WAAO;AAAA,MACL,OAAO,UAAU,MAAM,KAAK;AAAA,MAC5B,QAAQ,UAAU,MAAM,MAAM;AAAA,MAC9B,KAAK,MAAM;AAAA,MACX,gBAAgB,MAAM;AAAA,MACtB,QAAQ,MAAM;AAAA,MACd,UAAU,MAAM;AAAA,MAChB,OAAO,MAAM;AAAA,MACb,aAAa,MAAM,gBAAgB,OAAO,cAAc,MAAM,eAAe;AAAA,MAC7E,SAAS,MAAM;AAAA,MACf,UAAU,MAAM;AAAA,MAChB,OAAO,MAAM;AAAA,IACnB;AAAA,EACE,CAAC;AACD,QAAM,OAAO,SAAQ;AACrB,QAAM,YAAY,SAAS,MAAM;AAC/B,WAAO;AAAA,MACL,GAAG,MAAM;AAAA,MACT,OAAO,UAAU,MAAM,KAAK;AAAA,MAC5B,QAAQ,UAAU,MAAM,MAAM;AAAA,MAC9B,QAAQ,MAAM;AAAA,MACd,SAAS,MAAM,WAAW,KAAK,QAAQ;AAAA,MACvC,YAAY,MAAM;AAAA,MAClB,KAAK,MAAM;AAAA,IACjB;AAAA,EACE,CAAC;AACD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA;AACO,MAAM,eAAe;AAAA,EAC1B,GAAG;AAAA,EACH,cAAc,EAAE,MAAM,QAAQ,SAAS,KAAI;AAAA,EAC3C,UAAU,EAAE,MAAM,QAAQ,SAAS,KAAI;AACzC;AACO,MAAM,WAAW;AAAA,EACtB,GAAG;AAAA,EACH,aAAa,EAAE,MAAM,CAAC,SAAS,QAAQ,QAAQ,KAAK,GAAG,UAAU,MAAK;AAAA,EACtE,kBAAkB,EAAE,MAAM,QAAQ,UAAU,MAAK;AAAA,EACjD,QAAQ,EAAE,MAAM,SAAS,UAAU,MAAK;AAC1C;;;;;;;AC1DA,UAAM,QAAQ;AAEd,UAAM,QAAQ,SAAA;AAOd,UAAM,WAAW;AAEjB,UAAM,OAAO,SAAA;AAEb,UAAM,EAAE,OAAO,WAAW,SAAS,aAAa,WAAW,cAAA,IAAkB,aAAa,KAAK;AAE/F,UAAM,iBAAiB,SAAS,MAAM,iBAAiB,MAAM,GAAG,CAAC;AAEjE,UAAM,gBAAgB,SAAS,MAAM,CAAC,OAAO,QAAQ,OAAO,KAAK,EAAE,SAAS,eAAe,KAAK,CAAC;AAEjG,UAAM,eAAe,SAAS,MAAM;AAClC,UAAI,MAAM,cAAc;AACtB,eAAO,MAAM;AAAA,MACf;AAEA,aAAO,cAAc,QAAQ,QAAQ;AAAA,IACvC,CAAC;AAID,UAAM,UAAU,SAAmB,MAAM;AACvC,YAAM,UAAU,MAAM,QAAQ,MAAM,GAAG,MAAM,eAAe,UAAU,QAAQ,CAAC,KAAK,IAAK,KAAK,QAAQ,QAAQ,SAAS,CAAC,GAAG,KAAK,QAAQ,MAAM,IAAI,CAAC,MAAM;AAEzJ,UAAI,QAAQ,CAAC,MAAM,OAAO;AACxB,eAAO,CAAC,EAAE,KAAK,MAAM,KAAM;AAAA,MAC7B;AAEA,UAAI,CAAC,QAAQ,SAAS,aAAa,KAAK,GAAG;AACzC,gBAAQ,KAAK,aAAa,KAAK;AAAA,MACjC,OACK;AACH,gBAAQ,OAAO,QAAQ,QAAQ,aAAa,KAAK,GAAG,CAAC;AACrD,gBAAQ,KAAK,aAAa,KAAK;AAAA,MACjC;AAEA,aAAO,QAAQ,IAAI,CAAC,WAAW;AAC7B,cAAM,EAAE,QAAQ,OAAO,IAAA,IAAQ,KAAK,SAAS,MAAM,KAAM;AAAA,UACvD,GAAG,YAAY;AAAA,UACf,OAAO,MAAM,SAAS,KAAK,QAAQ;AAAA,UACnC,WAAW,MAAM;AAAA,UACjB,WAAW,EAAE,GAAG,cAAc,OAAO,OAAA;AAAA,QAAO,CAC7C;AAED,eAAO,EAAE,KAAK,MAAM,SAAS,MAAM,IAAI,OAAO,OAAA;AAAA,MAChD,CAAC;AAAA,IACH,CAAC;AAED,UAAM,aAAa,SAAS,MAAM,QAAQ,MAAM,QAAQ,MAAM,SAAS,CAAC,CAAC;AAEzE,QAA0B,MAAM,SAAS;AACvC,cAAQ,EAAE,MAAM,MAAM;AACpB,cAAM,cAAc,QAAQ,MAAM,CAAC;AACnC,YAAI,CAAC,aAAa;AAChB,iBAAO,CAAA;AAAA,QACT;AAEA,cAAM,OAA0C;AAAA,UAC9C,KAAK;AAAA,UACL,IAAI;AAAA,UACJ,aAAa,YAAY;AAAA,UACzB,OAAO,MAAM;AAAA,UACb,GAAI,OAAO,MAAM,YAAY,aAAa,MAAM,SAAS,gBACrD,EAAE,eAAe,MAAM,QAAQ,cAAA,IAC/B,CAAA;AAAA,QAAC;AAGP,YAAI,QAAQ,QAAQ,CAAC,GAAG,OAAO;AAC7B,eAAK,aAAa,QAAQ,MAAM,CAAC,EAAE;AAAA,QACrC;AACA,eAAO,CAAC,IAAI;AAAA,MACd,GAAG;AAAA,IACL;AAGA,UAAM,WAAW,SAAS,MAAM;AAC9B,YAAM,SAA2C,EAAE,GAAG,MAAM,UAAU,iBAAiB,GAAA;AACvF,iBAAW,OAAO,OAAO;AACvB,YAAI,OAAO,kBAAkB,EAAE,OAAO,SAAS;AAC7C,iBAAO,GAAG,IAAI,MAAM,GAAG;AAAA,QACzB;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC;AAED,UAAM,QAAQ,IAAA;AAGd,QAA0B,YAAY,WAAW;AAC/C,iBAAW,OAAO,QAAQ,OAAO;AAC/B,8BAAsB,IAAI,KAAK,IAAI,QAAQ,iBAAiB;AAAA,MAC9D;AAAA,IACF;AAEA,UAAM,UAAU,WAAA;AACI,YAAQ;;;oBA3IL,QAAA,MAAQ,MAAK,GAAA,EAAA,GAAA,CAAvB,WAAM;sCAEZ,QAAM,OAAO,IAAI,kBACjB,SAAO,OAAO,KAAK,kBACnB,UAAQ,OAAO,MAAM;;;UAIhB,WAAA,OAAU;;mBACZ;AAAA,UAAJ,KAAI;AAAA,QAAA;aACiBC,MAAA,SAAA;AAAA,aAAuBA,MAAA,QAAA,IAAQ,EAAA,SAAA,qCAAA,IAAA,CAAA;AAAA,aAAyE,SAAA;AAAA,QAAA;UAK5H,KAAK,WAAA,MAAW;AAAA,UAChB,OAAO,WAAA,MAAW;AAAA,UAClB,QAAQ,WAAA,MAAW;AAAA,QAAA;;;;;;;;;;;;;;;;;;;;;ACkB1B,UAAM,QAAQ;AAEd,UAAM,QAAQ,SAAA;AAOd,UAAM,WAAW;AAEjB,UAAM,OAAO,SAAA;AAEb,UAAM,QAAQ,aAAa,KAAK;AAEhC,UAAM,oBAAoB,IAAI,KAAK;AACnC,UAAM,QAAQ,IAAA;AAQd,UAAM,QAAQ,SAAS,MAAM,KAAK,SAAS,MAAM,KAAM;AAAA,MACrD,GAAG,MAAM,QAAQ;AAAA,MACjB,OAAO,MAAM;AAAA,MACb,WAAW,MAAM;AAAA,MACjB,WAAW;AAAA,QACT,GAAG,MAAM,UAAU;AAAA,QACnB,OAAO,UAAU,MAAM,KAAK;AAAA,QAC5B,QAAQ,UAAU,MAAM,MAAM;AAAA,MAAA;AAAA,IAChC,CACD,CAAC;AAEF,UAAM,WAAW,SAAS,MAAM;AAC9B,YAAMC,SAAgB,EAAE,GAAG,MAAM,MAAM,OAAO,iBAAiB,GAAA;AAE/D,UAAI,CAAC,MAAM,eAAe,kBAAkB,OAAO;AACjDA,eAAM,QAAQ,MAAM,MAAM;AAC1BA,eAAM,SAAS,MAAM,MAAM;AAAA,MAC7B;AAEA,aAAOA;AAAAA,IACT,CAAC;AAED,UAAM,cAAc,SAAS,MAAM;AACjC,UAAIC,eAAc,MAAM;AAExB,UAAIA,iBAAgB,IAAI;AACtBA,uBAAc;AAAA,MAChB;AAEA,UAAI,CAACA,gBAAe,kBAAkB,OAAO;AAC3C,eAAO;AAAA,MACT;AAEA,UAAI,OAAOA,iBAAgB,UAAU;AACnC,eAAOA;AAAAA,MACT;AAEA,YAAM,OAAQ,MAAM,QAAQA,YAAW,IACnCA,eACC,OAAOA,iBAAgB,WAAW,CAACA,cAAaA,YAAW,IAAI,CAAC,IAAI,EAAE;AAE3E,aAAO,KAAK,MAAM,KAAM;AAAA,QACtB,GAAG,MAAM,UAAU;AAAA,QACnB,OAAO,KAAK,CAAC;AAAA,QACb,QAAQ,KAAK,CAAC;AAAA,QACd,SAAS,KAAK,CAAC,KAAK;AAAA,QACpB,MAAM,KAAK,CAAC,KAAK;AAAA,MAAA,GAChB,MAAM,QAAQ,KAAK;AAAA,IACxB,CAAC;AAED,UAAM,UAAU;AAAA,MAAS,MACvB,MAAM,QACF,MAAM,MAAM,MACZ,KAAK,MAAM,KAAM,MAAM,UAAU,OAAO,MAAM,QAAQ,KAAK;AAAA,IAAA;AAGjE,UAAM,MAAM,SAAS,MAAM,YAAY,QAAQ,YAAY,QAAQ,QAAQ,KAAK;AAEhF,QAA0B,MAAM,SAAS;AACvC,YAAM,eAAe,OAAO,OAAO,MAAM,KAAK,EAAE,MAAM,OAAK,CAAC;AAE5D,cAAQ;AAAA,QACN,MAAM,CAAC;AAAA,UACL,KAAK;AAAA,UACL,IAAI;AAAA,UACJ,OAAO,MAAM;AAAA,UACb,GAAI,CAAC,eACD,EAAE,MAAM,IAAI,UACZ;AAAA,YACE,MAAM,MAAM,MAAM;AAAA,YAClB,YAAY,MAAM,MAAM;AAAA,YACxB,aAAa,MAAM,MAAM;AAAA,UAAA;AAAA,UAE/B,GAAI,OAAO,MAAM,YAAY,aAAa,MAAM,QAAQ,gBACpD,EAAE,eAAe,MAAM,QAAQ,cAAA,IAC/B,CAAA;AAAA,QAAC,CACN;AAAA,MAAA,CACF;AAAA,IACH;AAGA,QAA0B,YAAY,WAAW;AAC/C,4BAAsB,IAAI,OAAO,MAAM,MAAM,QAAQ,iBAAiB;AAAA,IACxE;AAEA,UAAM,UAAU,WAAA;AAEI,YAAQ;;WAnJjBC,KAAAA,QAAM;;mBACT;AAAA,UAAJ,KAAI;AAAA,UACH,OAAO,YAAA,SAAW,CAAK,0BAAoBC,KAAAA,mBAAmB;AAAA,QAAA;aAC5CJ,MAAA,QAAA,IAAQ,EAAA,SAAA,qCAAA,IAAA,CAAA;AAAA,aAAsE,SAAA;AAAA,aAAmBA,MAAA,KAAA;AAAA,QAAA,GAKnH,EAAA,KAAK,IAAA,SAAG,MAAA,CAAA,CAAA,GAAA;AAAA;;aAIUA,MAAA,QAAA,IAAQ,EAAA,SAAA,qCAAA,IAAA,CAAA;AAAA;eAA0F,SAAA;AAAA,eAAqBA,MAAA,KAAA;AAAA,UAAA;AAAA,oBAAgC,kBAAA;AAAA,eAAyB,IAAA;AAAA,QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdhM,MAAM,gBAAgB,MAAM;AACjC,QAAM,SAAS,SAAmB,UAAU,MAAM,CAAA,CAAE;AAEpD,QAAM,WAAW,CAAC,UAAkB;AAClC,WAAO,MAAM,KAAK,KAAK;AAAA,EACzB;AAEA,QAAM,cAAc,MAAM;AACxB,WAAO,QAAQ,CAAA;AAAA,EACjB;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ;ACfY,MAAC,YAAY,MAAM,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC0B5C,UAAA,QAAA;AA0CA,UAAA,aAAA,cAAA;AACA,eAAA,SAAA,MAAA,GAAA;AAGA,UAAA,aAAA,IAAA;AACA,QAAA;AACA,QAAA;AAEA,QAAA,MAAA,QAAA;AACA,gBAAA,OAAA,MAAA,OAAA,MAAA,GAAA,EAAA,CAAA,CAAA;AACA,gBAAA,OAAA,MAAA,OAAA,MAAA,GAAA,EAAA,CAAA,CAAA;AAAA,IACA;AAEA,QAAA,YAAA,YAAA,MAAA,SAAA;AACA,gBAAA,OAAA,MAAA,QAAA,MAAA,GAAA,EAAA,CAAA,CAAA;AACA,gBAAA,OAAA,MAAA,QAAA,MAAA,GAAA,EAAA,CAAA,CAAA;AAAA,IACA;AAEA,eAAA,SAAA,UAAA,UAAA,KAAA,QAAA,CAAA;AAEA,UAAA,gBAAA,SAAA,MAAA,MAAA,SAAA,GAAA,WAAA,KAAA,MAAA,IAAA;AAEA,QAAA,MAAA,IAAA;AACE,cAAA;AAAA,QAAA,MAAA;AAAA,UAAA,EAAA,UAAA,YAAA,SAAA,MAAA,IAAA;AAAA,QAAA;AAAA,MAAA,CAAA;AAAA,IAGF;;;;;;;AA9Fa,UAAA,MAAA,KAAA;;;;AACE,YAAA,MAAA,QAAA;;;;;AAEH,YAAA,MAAA,SAAA,WAAA;;;;;;;YAML,aAAA,EAAA,WAAA,MAAA;AAAA;;;;;AAGK,YAAA,MAAA,SAAA,OAAA;;;;;;;YAMN,WAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHN,UAAM,eAAe,SAAS,MAAM;AAClC,aAAO,QAAA,QAAQ,OAAO,QAAA,YAAY,UAAU,KAAK,QAAQ,QAAA,OAAO;AAAA,IAClE,CAAC;;gEAjBiBK,KAAAA,GAAG,GAAAC,WAAA,EAAG,OAAON,MAAA,YAAA,EAAA,GAAY,MAAA,GAAA;AAAA,yBAAzC,CAEY,GAAAO,QAAAC,UAAA,aAAA;;;;;cADVC,WAAQ,KAAA,QAAA,SAAA;AAAA,YAAA;AAAA;;;;;;;;;;;;;;;;;;;;;ACAD,YAAA,WAAAC,eAAAJ,WAAA,EAAA,OAAM,iBAAa,MAAA,CAAA,CAAA,yFAAA;;QAIZ,OAAM;AAAA,QAAQ,KAAI;AAAA,QAAkB,KAAI;AAAA,MAAA;;QACxC,OAAM;AAAA,QAAW,KAAI;AAAA,QAAkB,KAAI;AAAA,MAAA;;;QAG1C,KAAI;AAAA,QAAoB,KAAI;AAAA,MAAA;;;QAI/B,KAAI;AAAA,QAAK,SAAQ;AAAA,QAAW,cAAA;AAAA,QAAW,mBAAA;AAAA,MAAA;yBAA7C,CAAuH,GAAAC,QAAAC,UAAA,aAAA;;;;;cAA1DG,YAA4B,gBAApB,aAAW;AAAA;cAAUA,YAAI,IAAA;AAAA,8BAAA,oBAAkB;AAAA,YAAA;AAAA;;;;;QAC1G,KAAI;AAAA,QAAI,SAAQ;AAAA,QAAQ,cAAA;AAAA,QAAW,mBAAA;AAAA,MAAA;yBAAzC,CAAiF,GAAAJ,QAAAC,UAAA,aAAA;;;;;8BAAxB,mBAAiB;AAAA,YAAA;AAAA;;;;;QACpE,KAAI;AAAA,QAAI,SAAQ;AAAA,QAAQ,cAAA;AAAA,QAAW,mBAAA;AAAA,MAAA;yBAAzC,CAAyH,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAhE,2DAAyD;AAAA,YAAA;AAAA;;;;;;;;;;;;;;;ACd5H,MAAMI,eAAa;AAAA,EACjB,OAAO;AAAA,EACP,MAAM;AAAA,EACN,SAAS;AACX;AAEO,SAASC,SAAO,MAAM,QAAQ;AACnC,SAAQC,UAAU,GAAIC,mBAAoB,OAAOH,cAAY,CAAC,GAAI,OAAO,CAAC,MAAM,OAAO,CAAC,IAAI;AAAA,IAC1FI,mBAAoB,QAAQ;AAAA,MAC1B,MAAM;AAAA,MACN,GAAG;AAAA,IACT,GAAO,MAAM,EAAE;AAAA,IACXA,mBAAoB,QAAQ;AAAA,MAC1B,MAAM;AAAA,MACN,GAAG;AAAA,IACT,GAAO,MAAM,EAAE;AAAA,EACf,EAAK,CAAC;AACN;AACA,MAAA,uBAAe,EAAE,QAAQH,SAAM;;;;;;;;;;;;;;;ACZ/B,UAAM,QAAQ;;;;;QAPP,OAAK,CAAC,aAAW,EAAA,cAAyB,MAAM,SAAQ,CAAA;AAAA;;QACjD,OAAM;AAAA,QAAQ,KAAI;AAAA,QAAgB,KAAI;AAAA;;;;;;;;;;;;;ACApD,MAAMD,eAAa;AAAA,EACjB,OAAO;AAAA,EACP,MAAM;AAAA,EACN,SAAS;AACX;AAEO,SAASC,SAAO,MAAM,QAAQ;AACnC,SAAQC,UAAU,GAAIC,mBAAoB,OAAOH,cAAY,CAAC,GAAI,OAAO,CAAC,MAAM,OAAO,CAAC,IAAI;AAAA,IAC1FI,mBAAoB,QAAQ;AAAA,MAC1B,QAAQ;AAAA,MACR,kBAAkB;AAAA,MAClB,gBAAgB;AAAA,MAChB,GAAG;AAAA,IACT,GAAO,MAAM,EAAE;AAAA,EACf,EAAK,CAAC;AACN;AACA,MAAA,uBAAe,EAAE,QAAQH,SAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACwB/B,UAAM,QAAQ;AA6Bd,UAAM,gBAAgB,eAAe,eAAe;AACpD,UAAM,SAAS,eAAe,QAAQ;;;AAvEpB,UAAA,MAAM,MAAI;;UACd,OAAK,CAAC,gBAAc,EAAA,UAAsC,QAAA,UAAS,CAAA;AAAA,UAA7C,IAAI,MAAM;AAAA;2BAA1C,CAiBW,GAAAN,QAAAC,UAAA,aAAA;;6CAdN,QAAM,MAAM,IAAI;gBACI,CAAA,MAAM,IAAI,GAAG,MAAM;AAAA,gBAAsB,MAAA,MAAM;AAAA,gBAAiB,CAAA,MAAM,OAAO,GAAG,MAAM;AAAA,gBAA6B,UAAA,MAAM;AAAA,gBAAqC,gBAAA,MAAM;AAAA;;;;;gBAH3LG,YAeS,UAAA;AAAA,kBAdP,QAAM,OAAK;AAAA,oBAEU,CAAA,MAAM,IAAI,GAAG,MAAM;AAAA,oBAAsB,MAAA,MAAM;AAAA,oBAAiB,CAAA,MAAM,OAAO,GAAG,MAAM;AAAA,oBAA6B,UAAA,MAAM;AAAA,oBAAqC,gBAAA,MAAM;AAAA;kBADxL,MAAM,MAAM;AAAA;kBAQbA,YAIO,QAAA;AAAA,6BAJG;AAAA,oBAAJ,KAAI;AAAA,oBAAgB,OAAM;AAAA;oBAC9BA,YAEO,QAAA;AAAA,+BAFG;AAAA,sBAAJ,KAAI;AAAA,sBAAS,OAAM;AAAA;sBACvBF,WAAQ,KAAA,QAAA,WAAA,CAAA,GAAA,QAAA,IAAA;AAAA;;;;;;;;;;UAQd,QAAM,OAAK;AAAA,YAEQ,CAAA,MAAM,IAAI,GAAG,MAAM;AAAA,YAAoB,MAAA,MAAM;AAAA,YAAe,CAAA,MAAM,OAAO,GAAG,MAAM;AAAA,YAA2B,UAAA,MAAM;AAAA,YAAmC,gBAAA,MAAM;AAAA;UAD9K,MAAM,MAAM;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACCnB,UAAM,QAAQ;;;QAxBJ,OAAK,CAAC,eAAa,EAAA,QAAmB,MAAM,YAAW,CAAA;AAAA,QAAI,MAAK;AAAA,QAAS,cAAW;AAAA;;;;;;;;;;;ACDvF,MAAM,kBAAkB,MAAM,SAAkB,qBAAqB,MAAM,KAAK;AAChF,MAAM,oBAAoB,MAAM,SAAgB,uBAAuB,MAAM,CAAA,CAAE;AAG/E,MAAM,mBAAmB,MAAM,SAAkB,sBAAsB,MAAM,KAAK;AAClF,MAAM,iBAAiB,MAAM,SAAkB,oBAAoB,MAAM,KAAK;AAC9E,MAAM,qBAAqB,MAAM,SAAiB,wBAAwB,MAAM,CAAC;ACyCxF,SAAS,kBAAkB,IAAI;AAC7B,MAAI,mBAAmB;AACrB,mBAAe,EAAE;AACjB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AA4CA,MAAM,4CAA4C,QAAA;AAElD,MAAM,yCAAyC,IAAI,SAAS;AAC1D,MAAI;AACJ,QAAM,MAAM,KAAK,CAAC;AAClB,QAAM,YAAY,KAAK,mBAAA,MAAyB,OAAO,SAAS,GAAG;AACnE,MAAI,YAAY,QAAQ,CAAC,oBAAA;AACvB,UAAM,IAAI,MAAM,qCAAqC;AACvD,MAAI,YAAY,sBAAsB,IAAI,QAAQ,KAAK,OAAO,sBAAsB,IAAI,QAAQ;AAC9F,WAAO,sBAAsB,IAAI,QAAQ,EAAE,GAAG;AAChD,SAAO,OAAO,GAAG,IAAI;AACvB;AA4LA,MAAM,WAAW;AACA,OAAO,sBAAsB,eAAe,sBAAsB;AAOnF,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,WAAW,CAAC,QAAQ,SAAS,KAAK,GAAG,MAAM;AAIjD,MAAMQ,SAAO,MAAM;AACnB;AAmNA,SAAS,iBAAiB,QAAQ,OAAO;AACvC,MAAI;AACJ,MAAI,OAAO,WAAW;AACpB,WAAO,SAAS;AAClB,QAAM,UAAU,KAAK,OAAO,MAAM,cAAc,MAAM,OAAO,SAAS,GAAG,CAAC,MAAM;AAChF,QAAM,OAAO,OAAO,MAAM,MAAM,MAAM;AACtC,QAAM,SAAS,OAAO,WAAW,KAAK,IAAI;AAC1C,MAAI,OAAO,MAAM,MAAM;AACrB,WAAO;AACT,SAAO,SAAS;AAClB;AACA,SAAS,QAAQ,IAAI;AACnB,SAAO,GAAG,SAAS,KAAK,IAAI,OAAO,WAAW,EAAE,IAAI,KAAK,OAAO,WAAW,EAAE;AAC/E;AAkBA,SAAS,QAAQ,OAAO;AACtB,SAAO,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AAC9C;AAgBA,SAAS,mBAAmB,QAAQ;AAClC,SAAiB,mBAAA;AACnB;AA2PA,SAAS,aAAa,IAAI,OAAO,MAAM,QAAQ;AAC7C,QAAM,WAAW,mBAAyB;AAC1C,MAAI;AACF;AAAA,WACO;AACP,OAAA;AAAA;AAEA,aAAS,EAAE;AACf;AAuXA,SAAS,cAAc,IAAI,WAAW,KAAK,UAAU,CAAA,GAAI;AACvD,QAAM;AAAA,IACJ,YAAY;AAAA,IACZ,oBAAoB;AAAA,EAAA,IAClB;AACJ,MAAI,QAAQ;AACZ,QAAM,WAAW,WAAW,KAAK;AACjC,WAAS,QAAQ;AACf,QAAI,OAAO;AACT,oBAAc,KAAK;AACnB,cAAQ;AAAA,IACV;AAAA,EACF;AACA,WAAS,QAAQ;AACf,aAAS,QAAQ;AACjB,UAAA;AAAA,EACF;AACA,WAAS,SAAS;AAChB,UAAM,gBAAgBC,QAAU,QAAQ;AACxC,QAAI,iBAAiB;AACnB;AACF,aAAS,QAAQ;AACjB,QAAI;AACF,SAAA;AACF,UAAA;AACA,QAAI,SAAS;AACX,cAAQ,YAAY,IAAI,aAAa;AAAA,EACzC;AAGA,MAAI,MAAM,QAAQ,KAAK,OAAO,aAAa,YAAY;AACrD,UAAM,YAAY,MAAM,UAAU,MAAM;AACtC,UAAI,SAAS,SAAS;AACpB;AAAA,IACJ,CAAC;AACD,sBAAkB,SAAS;AAAA,EAC7B;AACA,oBAAkB,KAAK;AACvB,SAAO;AAAA,IACL,UAAU,gBAAgB,QAAQ;AAAA,IAClC;AAAA,IACA;AAAA,EAAA;AAEJ;AAqSA,SAAS,eAAe,QAAQ,IAAI,SAAS;AAC3C,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,MACE,GAAG;AAAA,MACH,WAAW;AAAA,IAAA;AAAA,EACb;AAEJ;AC91CA,MAAM,gBAAoC;AAK1C,SAAS,aAAa,OAAO;AAC3B,MAAI;AACJ,QAAM,QAAQ,QAAQ,KAAK;AAC3B,UAAQ,KAAK,SAAS,OAAO,SAAS,MAAM,QAAQ,OAAO,KAAK;AAClE;AAEA,SAAS,oBAAoB,MAAM;AACjC,QAAM,WAAW,CAAA;AACjB,QAAM,UAAU,MAAM;AACpB,aAAS,QAAQ,CAAC,OAAO,GAAA,CAAI;AAC7B,aAAS,SAAS;AAAA,EACpB;AACA,QAAM,WAAW,CAAC,IAAI,OAAO,UAAU,YAAY;AACjD,OAAG,iBAAiB,OAAO,UAAU,OAAO;AAC5C,WAAO,MAAM,GAAG,oBAAoB,OAAO,UAAU,OAAO;AAAA,EAC9D;AACA,QAAM,oBAAoB,SAAS,MAAM;AACvC,UAAM,OAAO,QAAQ,QAAQ,KAAK,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,KAAK,IAAI;AAC9D,WAAO,KAAK,MAAM,CAAC,MAAM,OAAO,MAAM,QAAQ,IAAI,OAAO;AAAA,EAC3D,CAAC;AACD,QAAM,YAAY;AAAA,IAChB,MAAM;AACJ,UAAI,IAAI;AACR,aAAO;AAAA,SACJ,MAAM,KAAK,kBAAkB,UAAU,OAAO,SAAS,GAAG,IAAI,CAAC,MAAM,aAAa,CAAC,CAAC,MAAM,OAAO,KAAK,CAAC,aAAa,EAAE,OAAO,CAAC,MAAM,KAAK,IAAI;AAAA,QAC9I,QAAQ,QAAQ,kBAAkB,QAAQ,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;AAAA,QAC5D,QAAQ,MAAM,kBAAkB,QAAQ,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;AAAA;AAAA,QAE1D,QAAQ,kBAAkB,QAAQ,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC;AAAA,MAAA;AAAA,IAEvD;AAAA,IACA,CAAC,CAAC,aAAa,YAAY,eAAe,WAAW,MAAM;AACzD,cAAA;AACA,UAAI,EAAE,eAAe,OAAO,SAAS,YAAY,WAAW,EAAE,cAAc,OAAO,SAAS,WAAW,WAAW,EAAE,iBAAiB,OAAO,SAAS,cAAc;AACjK;AACF,YAAM,eAAe,SAAS,WAAW,IAAI,EAAE,GAAG,gBAAgB;AAClE,eAAS;AAAA,QACP,GAAG,YAAY;AAAA,UACb,CAAC,OAAO,WAAW;AAAA,YACjB,CAAC,UAAU,cAAc,IAAI,CAAC,aAAa,SAAS,IAAI,OAAO,UAAU,YAAY,CAAC;AAAA,UAAA;AAAA,QACxF;AAAA,MACF;AAAA,IAEJ;AAAA,IACA,EAAE,OAAO,OAAA;AAAA,EAAO;AAElB,QAAM,OAAO,MAAM;AACjB,cAAA;AACA,YAAA;AAAA,EACF;AACA,oBAAkB,OAAO;AACzB,SAAO;AACT;AAGA,SAAS,eAAe,QAAQ,SAAS,UAAU,CAAA,GAAI;AACrD,QAAM,EAAE,QAAAC,UAAS,eAAe,SAAS,CAAA,GAAI,UAAU,MAAM,eAAe,OAAO,WAAW,UAAU;AACxG,MAAI,CAACA,SAAQ;AACX,WAAO,WAAW,EAAE,MAAMF,QAAM,QAAQA,QAAM,SAASA,WAASA;AAAAA,EAClE;AAOA,MAAI,eAAe;AACnB,QAAM,eAAe,CAAC,UAAU;AAC9B,WAAO,QAAQ,MAAM,EAAE,KAAK,CAAC,YAAY;AACvC,UAAI,OAAO,YAAY,UAAU;AAC/B,eAAO,MAAM,KAAKE,QAAO,SAAS,iBAAiB,OAAO,CAAC,EAAE,KAAK,CAAC,OAAO,OAAO,MAAM,UAAU,MAAM,eAAe,SAAS,EAAE,CAAC;AAAA,MACpI,OAAO;AACL,cAAM,KAAK,aAAa,OAAO;AAC/B,eAAO,OAAO,MAAM,WAAW,MAAM,MAAM,aAAA,EAAe,SAAS,EAAE;AAAA,MACvE;AAAA,IACF,CAAC;AAAA,EACH;AACA,WAAS,iBAAiB,SAAS;AACjC,UAAM,KAAK,QAAQ,OAAO;AAC1B,WAAO,MAAM,GAAG,EAAE,QAAQ,cAAc;AAAA,EAC1C;AACA,WAAS,mBAAmB,SAAS,OAAO;AAC1C,UAAM,KAAK,QAAQ,OAAO;AAC1B,UAAM,WAAW,GAAG,EAAE,WAAW,GAAG,EAAE,QAAQ;AAC9C,QAAI,YAAY,QAAQ,CAAC,MAAM,QAAQ,QAAQ;AAC7C,aAAO;AACT,WAAO,SAAS,KAAK,CAAC,UAAU,MAAM,OAAO,MAAM,UAAU,MAAM,aAAA,EAAe,SAAS,MAAM,EAAE,CAAC;AAAA,EACtG;AACA,QAAM,WAAW,CAAC,UAAU;AAC1B,UAAM,KAAK,aAAa,MAAM;AAC9B,QAAI,MAAM,UAAU;AAClB;AACF,QAAI,EAAE,cAAc,YAAY,iBAAiB,MAAM,KAAK,mBAAmB,QAAQ,KAAK;AAC1F;AACF,QAAI,CAAC,MAAM,OAAO,MAAM,UAAU,MAAM,aAAA,EAAe,SAAS,EAAE;AAChE;AACF,QAAI,YAAY,SAAS,MAAM,WAAW;AACxC,qBAAe,CAAC,aAAa,KAAK;AACpC,QAAI,CAAC,cAAc;AACjB,qBAAe;AACf;AAAA,IACF;AACA,YAAQ,KAAK;AAAA,EACf;AACA,MAAI,oBAAoB;AACxB,QAAM,UAAU;AAAA,IACd,iBAAiBA,SAAQ,SAAS,CAAC,UAAU;AAC3C,UAAI,CAAC,mBAAmB;AACtB,4BAAoB;AACpB,mBAAW,MAAM;AACf,8BAAoB;AAAA,QACtB,GAAG,CAAC;AACJ,iBAAS,KAAK;AAAA,MAChB;AAAA,IACF,GAAG,EAAE,SAAS,MAAM,SAAS;AAAA,IAC7B,iBAAiBA,SAAQ,eAAe,CAAC,MAAM;AAC7C,YAAM,KAAK,aAAa,MAAM;AAC9B,qBAAe,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,EAAE,aAAA,EAAe,SAAS,EAAE;AAAA,IAC3E,GAAG,EAAE,SAAS,MAAM;AAAA,IACpB,gBAAgB,iBAAiBA,SAAQ,QAAQ,CAAC,UAAU;AAC1D,iBAAW,MAAM;AACf,YAAI;AACJ,cAAM,KAAK,aAAa,MAAM;AAC9B,cAAM,KAAKA,QAAO,SAAS,kBAAkB,OAAO,SAAS,GAAG,aAAa,YAAY,EAAE,MAAM,OAAO,SAAS,GAAG,SAASA,QAAO,SAAS,aAAa,IAAI;AAC5J,kBAAQ,KAAK;AAAA,QACf;AAAA,MACF,GAAG,CAAC;AAAA,IACN,GAAG,EAAE,SAAS,KAAA,CAAM;AAAA,EAAA,EACpB,OAAO,OAAO;AAChB,QAAM,OAAO,MAAM,QAAQ,QAAQ,CAAC,OAAO,IAAI;AAC/C,MAAI,UAAU;AACZ,WAAO;AAAA,MACL;AAAA,MACA,QAAQ,MAAM;AACZ,uBAAe;AAAA,MACjB;AAAA,MACA,SAAS,CAAC,UAAU;AAClB,uBAAe;AACf,iBAAS,KAAK;AACd,uBAAe;AAAA,MACjB;AAAA,IAAA;AAAA,EAEJ;AACA,SAAO;AACT;AAAA;AAGA,SAAS,aAAa;AACpB,QAAM,YAAY,WAAW,KAAK;AACjB,qBAAA;AAMjB,SAAO;AACT;AAAA;AAGA,SAAS,aAAa,UAAU;AAC9B,QAAM,YAAY,2BAAA;AAClB,SAAO,SAAS,MAAM;AACpB,cAAU;AACV,WAAO,QAAQ,UAAU;AAAA,EAC3B,CAAC;AACH;AAoFA,SAAS,mBAAmB,WAAW;AACrC,MAAI,OAAO,cAAc;AACvB,WAAO;AAAA,WACA,OAAO,cAAc;AAC5B,WAAO,CAAC,UAAU,MAAM,QAAQ;AAAA,WACzB,MAAM,QAAQ,SAAS;AAC9B,WAAO,CAAC,UAAU,UAAU,SAAS,MAAM,GAAG;AAChD,SAAO,MAAM;AACf;AACA,SAAS,eAAe,MAAM;AAC5B,MAAI;AACJ,MAAI;AACJ,MAAI,UAAU,CAAA;AACd,MAAI,KAAK,WAAW,GAAG;AACrB,UAAM,KAAK,CAAC;AACZ,cAAU,KAAK,CAAC;AAChB,cAAU,KAAK,CAAC;AAAA,EAClB,WAAW,KAAK,WAAW,GAAG;AAC5B,QAAI,OAAO,KAAK,CAAC,MAAM,UAAU;AAC/B,YAAM;AACN,gBAAU,KAAK,CAAC;AAChB,gBAAU,KAAK,CAAC;AAAA,IAClB,OAAO;AACL,YAAM,KAAK,CAAC;AACZ,gBAAU,KAAK,CAAC;AAAA,IAClB;AAAA,EACF,OAAO;AACL,UAAM;AACN,cAAU,KAAK,CAAC;AAAA,EAClB;AACA,QAAM;AAAA,IACJ,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,SAAS;AAAA,EAAA,IACP;AACJ,QAAM,YAAY,mBAAmB,GAAG;AACxC,QAAM,WAAW,CAAC,MAAM;AACtB,QAAI,EAAE,UAAU,QAAQ,MAAM;AAC5B;AACF,QAAI,UAAU,CAAC;AACb,cAAQ,CAAC;AAAA,EACb;AACA,SAAO,iBAAiB,QAAQ,WAAW,UAAU,OAAO;AAC9D;AAyzBA,MAAM,iBAAiB,OAAO,kBAAkB;AAAA;AAEhD,SAAS,cAAc;AACrB,QAAM,WAAW,oBAAA,IAAwB,4BAAY,gBAAgB,IAAI,IAAI;AAC7E,SAAO,OAAO,aAAa,WAAW,WAAW;AACnD;AASA,SAAS,cAAc,OAAO,UAAU,IAAI;AAC1C,QAAM,EAAE,QAAAA,UAAS,eAAe,WAAW,4BAAA,MAAkB;AAC7D,QAAM,2CAA2B,MAAMA,WAAU,gBAAgBA,WAAU,OAAOA,QAAO,eAAe,UAAU;AAClH,QAAM,aAAa,WAAW,OAAO,aAAa,QAAQ;AAC1D,QAAM,aAAa,WAAA;AACnB,QAAM,UAAU,WAAW,KAAK;AAChC,QAAM,UAAU,CAAC,UAAU;AACzB,YAAQ,QAAQ,MAAM;AAAA,EACxB;AACA,cAAY,MAAM;AAChB,QAAI,WAAW,OAAO;AACpB,iBAAW,QAAQ,CAAC,YAAY;AAChC,YAAM,eAAe,QAAQ,KAAK,EAAE,MAAM,GAAG;AAC7C,cAAQ,QAAQ,aAAa,KAAK,CAAC,gBAAgB;AACjD,cAAM,MAAM,YAAY,SAAS,SAAS;AAC1C,cAAM,WAAW,YAAY,MAAM,gDAAgD;AACnF,cAAM,WAAW,YAAY,MAAM,gDAAgD;AACnF,YAAI,MAAM,QAAQ,YAAY,QAAQ;AACtC,YAAI,YAAY,KAAK;AACnB,gBAAM,YAAY,QAAQ,SAAS,CAAC,CAAC;AAAA,QACvC;AACA,YAAI,YAAY,KAAK;AACnB,gBAAM,YAAY,QAAQ,SAAS,CAAC,CAAC;AAAA,QACvC;AACA,eAAO,MAAM,CAAC,MAAM;AAAA,MACtB,CAAC;AACD;AAAA,IACF;AACA,QAAI,CAAC,YAAY;AACf;AACF,eAAW,QAAQA,QAAO,WAAW,QAAQ,KAAK,CAAC;AACnD,YAAQ,QAAQ,WAAW,MAAM;AAAA,EACnC,CAAC;AACD,mBAAiB,YAAY,UAAU,SAAS,EAAE,SAAS,MAAM;AACjE,SAAO,SAAS,MAAM,QAAQ,KAAK;AACrC;AAAA;AAoFA,SAAS,eAAe,aAAa,UAAU,IAAI;AACjD,WAASC,UAAS,GAAG,OAAO;AAC1B,QAAI,IAAI,QAAQ,YAAY,QAAQ,CAAC,CAAC,CAAC;AACvC,QAAI,SAAS;AACX,UAAI,iBAAiB,GAAG,KAAK;AAC/B,QAAI,OAAO,MAAM;AACf,UAAI,GAAG,CAAC;AACV,WAAO;AAAA,EACT;AACA,QAAM,EAAE,QAAAD,UAAS,eAAe,WAAW,aAAa,WAAW,4BAAA,EAAY,IAAM;AACrF,QAAM,aAAa,OAAO,aAAa;AACvC,QAAM,UAAU,aAAa,WAAW,KAAK,IAAI,EAAE,OAAO,KAAA;AAC1D,MAAI,YAAY;AACd,iBAAa,MAAM,QAAQ,QAAQ,CAAC,CAACA,OAAM;AAAA,EAC7C;AACA,WAAS,MAAM,OAAO,MAAM;AAC1B,QAAI,CAAC,QAAQ,SAAS,YAAY;AAChC,aAAO,UAAU,QAAQ,YAAY,QAAQ,IAAI,IAAI,YAAY,QAAQ,IAAI;AAAA,IAC/E;AACA,QAAI,CAACA;AACH,aAAO;AACT,WAAOA,QAAO,WAAW,IAAI,KAAK,WAAW,IAAI,GAAG,EAAE;AAAA,EACxD;AACA,QAAM,iBAAiB,CAAC,MAAM;AAC5B,WAAO,cAAc,MAAM,eAAeC,UAAS,CAAC,CAAC,KAAK,OAAO;AAAA,EACnE;AACA,QAAM,iBAAiB,CAAC,MAAM;AAC5B,WAAO,cAAc,MAAM,eAAeA,UAAS,CAAC,CAAC,KAAK,OAAO;AAAA,EACnE;AACA,QAAM,kBAAkB,OAAO,KAAK,WAAW,EAAE,OAAO,CAAC,WAAW,MAAM;AACxE,WAAO,eAAe,WAAW,GAAG;AAAA,MAClC,KAAK,MAAM,aAAa,cAAc,eAAe,CAAC,IAAI,eAAe,CAAC;AAAA,MAC1E,YAAY;AAAA,MACZ,cAAc;AAAA,IAAA,CACf;AACD,WAAO;AAAA,EACT,GAAG,CAAA,CAAE;AACL,WAAS,UAAU;AACjB,UAAM,SAAS,OAAO,KAAK,WAAW,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,gBAAgB,CAAC,GAAG,QAAQA,UAAS,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;AAC5H,WAAO,SAAS,MAAM,OAAO,OAAO,CAAC,CAAA,EAAG,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;AAAA,EACzE;AACA,SAAO,OAAO,OAAO,iBAAiB;AAAA,IACpC;AAAA,IACA;AAAA,IACA,QAAQ,GAAG;AACT,aAAO,cAAc,MAAM,eAAeA,UAAS,GAAG,GAAG,CAAC,KAAK,OAAO;AAAA,IACxE;AAAA,IACA,QAAQ,GAAG;AACT,aAAO,cAAc,MAAM,eAAeA,UAAS,GAAG,IAAI,CAAC,KAAK,OAAO;AAAA,IACzE;AAAA,IACA,QAAQ,GAAG,GAAG;AACZ,aAAO,cAAc,MAAM,eAAeA,UAAS,CAAC,CAAC,qBAAqBA,UAAS,GAAG,IAAI,CAAC,KAAK,OAAO;AAAA,IACzG;AAAA,IACA,UAAU,GAAG;AACX,aAAO,MAAM,OAAOA,UAAS,GAAG,GAAG,CAAC;AAAA,IACtC;AAAA,IACA,iBAAiB,GAAG;AAClB,aAAO,MAAM,OAAOA,UAAS,CAAC,CAAC;AAAA,IACjC;AAAA,IACA,UAAU,GAAG;AACX,aAAO,MAAM,OAAOA,UAAS,GAAG,IAAI,CAAC;AAAA,IACvC;AAAA,IACA,iBAAiB,GAAG;AAClB,aAAO,MAAM,OAAOA,UAAS,CAAC,CAAC;AAAA,IACjC;AAAA,IACA,YAAY,GAAG,GAAG;AAChB,aAAO,MAAM,OAAOA,UAAS,CAAC,CAAC,KAAK,MAAM,OAAOA,UAAS,GAAG,IAAI,CAAC;AAAA,IACpE;AAAA,IACA;AAAA,IACA,SAAS;AACP,YAAM,MAAM,QAAA;AACZ,aAAO,SAAS,MAAM,IAAI,MAAM,WAAW,IAAI,KAAK,IAAI,MAAM,GAAG,aAAa,cAAc,KAAK,CAAC,CAAC;AAAA,IACrG;AAAA,EAAA,CACD;AACH;ACn+CA,SAAS,kBAAkB,QAAQ,OAAO;AAAE,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAAE,QAAI,aAAa,MAAM,CAAC;AAAG,eAAW,aAAa,WAAW,cAAc;AAAO,eAAW,eAAe;AAAM,QAAI,WAAW,WAAY,YAAW,WAAW;AAAM,WAAO,eAAe,QAAQ,WAAW,KAAK,UAAU;AAAA,EAAG;AAAE;AAE5T,SAAS,aAAa,aAAa,YAAY,aAAa;AAAE,MAAI,WAAY,mBAAkB,YAAY,WAAW,UAAU;AAAiE,SAAO;AAAa;AAEtN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA,IAAIC,QACAC,gBAEAC,QACAC,QACAC,UACAC,SACA,UACA,cACAC,iBACAC,SACAC,eACA,aACAC,YACAC,aAAW,SAASA,YAAW;AACjC,SAAOV,UAAQ;AACjB,GAEI,aAAa,IACb,aAAa,CAAA,GACb,WAAW,CAAA,GACXW,aAAW,KAAK,KAChB,UAAU,SAASC,SAAQ,MAAM,OAAO;AAC1C,SAAO;AACT,GACI,aAAa,SAASC,cAAa;AACrC,MAAI,OAAOP,gBAAc,MACrB,OAAO,KAAK,UAAU,CAAA,GACtB,YAAY,KAAK,YACjB,UAAU,KAAK;AACnB,YAAU,KAAK,MAAM,WAAW,UAAU;AAC1C,UAAQ,KAAK,MAAM,SAAS,QAAQ;AACpC,eAAa;AACb,aAAW;AAEX,YAAU,SAASM,SAAQ,MAAM,OAAO;AACtC,WAAO,KAAK,IAAI,EAAE,KAAK;AAAA,EACzB;AACF,GACI,gBAAgB,SAASE,eAAc,SAAS,UAAU;AAC5D,SAAO,CAAC,SAAS,QAAQ,OAAO,KAAK,SAAS,SAAS,QAAQ,OAAO,IAAI,CAAC,EAAE,QAAQ;AACvF,GACIC,gBAAc,SAASA,aAAY,IAAI;AACzC,SAAO,CAAC,CAAC,CAACR,QAAM,QAAQ,EAAE;AAC5B,GACIS,iBAAe,SAASA,cAAa,SAAS,MAAM,MAAM,SAAS,SAAS;AAC9E,SAAO,QAAQ,iBAAiB,MAAM,MAAM;AAAA,IAC1C,SAAS,YAAY;AAAA,IACrB,SAAS,CAAC,CAAC;AAAA,EAAA,CACZ;AACH,GACIC,oBAAkB,SAASA,iBAAgB,SAAS,MAAM,MAAM,SAAS;AAC3E,SAAO,QAAQ,oBAAoB,MAAM,MAAM,CAAC,CAAC,OAAO;AAC1D,GACI,cAAc,cACd,aAAa,aACbC,cAAY,SAASA,aAAY;AACnC,SAAOV,iBAAeA,cAAY,aAAa,WAAW;AAC5D,GACI,mBAAmB,SAASW,kBAAiB,GAAG,YAAY;AAC9D,MAAI,cAAc,SAASC,aAAY,OAAO;AAE5C,QAAI,SAAS,UAAU,GAAG;AACxB,MAAalB,OAAK,QAAQ,oBAAoB;AAE9C,UAAI,gBAAgBM,iBAAeA,cAAY;AAC/C,cAAQY,aAAY,IAAI,KAAK,MAAM,KAAK,MAAMZ,iBAAeA,cAAY,MAAM,IAAI;AAEnF,QAAE,KAAK;AACPY,mBAAY,UAAU,WAAW;AACjC,uBAAiB,QAAQ,MAAM,KAAK;AAAA,IACtC,WAAW,cAAc,WAAW,UAAUA,aAAY,WAAW,QAAQ,KAAK,GAAG;AACnFA,mBAAY,UAAU,WAAW;AACjCA,mBAAY,IAAI,EAAA;AAAA,IAClB;AAEA,WAAOA,aAAY,IAAIA,aAAY;AAAA,EACrC;AAEA,cAAY,SAAS;AACrB,SAAO,KAAK;AACd,GACI,cAAc;AAAA,EAChB,GAAG;AAAA,EACH,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,GAAG;AAAA,EACH,IAAI,iBAAiB,SAAU,OAAO;AACpC,WAAO,UAAU,SAASlB,OAAK,SAAS,OAAO,UAAU,IAAI,IAAIA,OAAK,eAAeC,OAAK,WAAW,KAAKC,SAAO,WAAW,KAAKC,QAAM,WAAW,KAAK;AAAA,EACzJ,CAAC;AACH,GACI,YAAY;AAAA,EACd,GAAG;AAAA,EACH,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI,iBAAiB,SAAU,OAAO;AACpC,WAAO,UAAU,SAASH,OAAK,SAAS,YAAY,GAAA,GAAM,KAAK,IAAIA,OAAK,eAAeC,OAAK,UAAU,KAAKC,SAAO,UAAU,KAAKC,QAAM,UAAU,KAAK;AAAA,EACxJ,CAAC;AACH,GACI,aAAa,SAASgB,YAAW,GAAG,MAAM;AAC5C,UAAQ,QAAQ,KAAK,QAAQ,KAAK,KAAK,YAAYrB,OAAK,MAAM,SAAS,CAAC,EAAE,CAAC,MAAM,OAAO,MAAM,YAAYA,OAAK,OAAA,EAAS,mBAAmB,QAAQ,QAAQ,KAAK,sBAAsB,CAAC,IAAI;AAC7L,GACI,YAAY,SAASsB,WAAU,SAAS,MAAM;AAEhD,MAAI,IAAI,KAAK;AAEb,SAAO,KAAK;AACV,QAAI,KAAK,CAAC,MAAM,WAAW,KAAK,CAAC,EAAE,SAAS,OAAO,GAAG;AACpD,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT,GACI,iBAAiB,SAASC,gBAAe,SAAS,MAAM;AAC1D,MAAI,IAAI,KAAK,GACT,KAAK,KAAK;AAEdR,gBAAY,OAAO,MAAM,UAAUZ,OAAK,oBAAoBC;AAE5D,MAAI,IAAI,WAAW,QAAQ,OAAO,GAC9B,SAAS,OAAO,UAAU,KAAK,IAAI;AAEvC,GAAC,CAAC,MAAM,IAAI,WAAW,KAAK,OAAO,IAAI;AACvC,aAAW,IAAI,MAAM,KAAKY,eAAa,SAAS,UAAUE,WAAS;AAEnE,MAAI,OAAO,WAAW,IAAI,MAAM,GAC5B,OAAO,SAAS,WAAW,IAAI,MAAM,IAAI,iBAAiB,cAAc,SAAS,CAAC,GAAG,IAAI,MAAMH,cAAY,OAAO,IAAI,KAAK,iBAAiB,SAAU,OAAO;AAC/J,WAAO,UAAU,SAAS,QAAQ,CAAC,IAAI,QAAQ,QAAQ,CAAC;AAAA,EAC1D,CAAC;AACD,OAAK,SAAS;AACd,WAAS,KAAK,SAASf,OAAK,YAAY,SAAS,gBAAgB,MAAM;AAEvE,SAAO;AACT,GACI,mBAAmB,SAASwB,kBAAiB,OAAO,gBAAgB,UAAU;AAChF,MAAI,KAAK,OACL,KAAK,OACL,KAAKb,WAAA,GACL,KAAK,IACL,MAAM,kBAAkB,IACxB,iBAAiB,KAAK,IAAI,KAAK,MAAM,CAAC,GACtC,SAAS,SAASc,QAAOC,QAAO,OAAO;AACzC,QAAI,IAAIf,WAAA;AAER,QAAI,SAAS,IAAI,KAAK,KAAK;AACzB,WAAK;AACL,WAAKe;AACL,WAAK;AACL,WAAK;AAAA,IACP,WAAW,UAAU;AACnB,YAAMA;AAAAA,IACR,OAAO;AAEL,WAAK,MAAMA,SAAQ,OAAO,IAAI,OAAO,KAAK;AAAA,IAC5C;AAAA,EACF,GACI,QAAQ,SAASC,SAAQ;AAC3B,SAAK,KAAK,WAAW,IAAI;AACzB,SAAK,KAAK;AAAA,EACZ,GACI,cAAc,SAASC,aAAY,aAAa;AAClD,QAAI,OAAO,IACP,OAAO,IACP,IAAIjB,WAAA;AAER,KAAC,eAAe,gBAAgB,MAAM,gBAAgB,MAAM,OAAO,WAAW;AAC9E,WAAO,OAAO,MAAM,IAAI,KAAK,iBAAiB,KAAK,MAAM,WAAW,OAAO,CAAC,WAAW,WAAW,IAAI,MAAM,QAAQ;AAAA,EACtH;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ,GACI,YAAY,SAASkB,WAAU,GAAG,gBAAgB;AACpD,oBAAkB,CAAC,EAAE,cAAc,EAAE,eAAA;AACrC,SAAO,EAAE,iBAAiB,EAAE,eAAe,CAAC,IAAI;AAClD,GACI,kBAAkB,SAASC,iBAAgB,GAAG;AAChD,MAAI,MAAM,KAAK,IAAI,MAAM,MAAM,CAAC,GAC5B,MAAM,KAAK,IAAI,MAAM,MAAM,CAAC;AAChC,SAAO,KAAK,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,IAAI,MAAM;AAChD,GACI,oBAAoB,SAASC,qBAAoB;AACnDzB,oBAAgBN,OAAK,KAAK,QAAA,EAAU;AACpCM,qBAAiBA,gBAAc,QAAQ,WAAA;AACzC,GACI,YAAY,SAAS0B,WAAU,MAAM;AACvChC,WAAO,QAAQU,WAAA;AAyBf,SAAOT;AACT;AAEA,YAAY,KAAK;AACjB,WAAW,QAAQ;AACZ,IAAI,WAAwB,4BAAY;AAC7C,WAASgC,UAAS,MAAM;AACtB,SAAK,KAAK,IAAI;AAAA,EAChB;AAEA,MAAI,SAASA,UAAS;AAEtB,SAAO,OAAO,SAAS,KAAK,MAAM;AAChB,cAAUjC,MAAI,KAAK,QAAQ,KAAK,sCAAsC;AACtFM,uBAAiB,kBAAA;AACjB,QAAI,YAAY,KAAK,WACjB,cAAc,KAAK,aACnB,OAAO,KAAK,MACZ,SAAS,KAAK,QACd,aAAa,KAAK,YAClB,WAAW,KAAK,UAChB,iBAAiB,KAAK,gBACtB,SAAS,KAAK,QACd,cAAc,KAAK,aACnB,SAAS,KAAK,QACd,aAAa,KAAK,YAClB,QAAQ,KAAK,OACb,cAAc,KAAK,aACnB,YAAY,KAAK,WACjB,SAAS,KAAK,QACd,UAAU,KAAK,SACf,YAAY,KAAK,WACjB,UAAU,KAAK,SACf,SAAS,KAAK,QACd,OAAO,KAAK,MACZ,SAAS,KAAK,QACd,YAAY,KAAK,WACjB,YAAY,KAAK,WACjB,WAAW,KAAK,UAChB,YAAY,KAAK,WACjB,YAAY,KAAK,WACjB,UAAU,KAAK,SACf,aAAa,KAAK,YAClB,SAAS,KAAK,QACd,cAAc,KAAK,aACnB,eAAe,KAAK,cACpB,iBAAiB,KAAK,gBACtB,eAAe,KAAK,cACpB,UAAU,KAAK,SACf,WAAW,KAAK,UAChB,YAAY,KAAK,WACjB,UAAU,KAAK,SACf,cAAc,KAAK,aACnB,UAAU,KAAK,SACf,cAAc,KAAK,aACnB,WAAW,KAAK,UAChB,aAAa,KAAK;AACtB,SAAK,SAAS,SAAS,WAAW,MAAM,KAAKF;AAC7C,SAAK,OAAO;AACZ,eAAW,SAASJ,OAAK,MAAM,QAAQ,MAAM;AAC7C,gBAAY,aAAa;AACzB,kBAAc,eAAe;AAC7B,iBAAa,cAAc;AAC3B,kBAAc,eAAe;AAC7B,WAAO,QAAQ;AACf,eAAW,aAAa;AACxB,mBAAe,aAAa,WAAWE,OAAK,iBAAiBG,OAAK,EAAE,UAAU,KAAK;AAEnF,QAAI,IACA,mBACA,SACA,OACA,SACA,QACA,MACA,OAAO,MACP,aAAa,GACb,aAAa,GACb,UAAU,KAAK,WAAW,CAAC,kBAAkB,KAAK,YAAY,OAC9D,cAAc,eAAe,QAAQ,WAAW,GAChD,cAAc,eAAe,QAAQ,SAAS,GAC9C,UAAU,YAAA,GACV,UAAU,eACV,eAAe,CAAC,KAAK,QAAQ,OAAO,KAAK,CAAC,CAAC,KAAK,QAAQ,SAAS,KAAK,YAAY,CAAC,MAAM,eAE7F,aAAaU,cAAY,MAAM,GAC3B,WAAW,OAAO,iBAAiBZ,QACnC,SAAS,CAAC,GAAG,GAAG,CAAC,GAErB,SAAS,CAAC,GAAG,GAAG,CAAC,GACb,cAAc,GACd,eAAe,SAAS+B,gBAAe;AACzC,aAAO,cAAcvB,WAAA;AAAA,IACvB,GACI,eAAe,SAASwB,cAAa,GAAG,kBAAkB;AAC5D,cAAQ,KAAK,QAAQ,MAAM,UAAU,UAAU,EAAE,QAAQ,MAAM,KAAK,oBAAoB,gBAAgB,EAAE,gBAAgB,WAAW,eAAe,YAAY,GAAG,gBAAgB;AAAA,IACrL,GACI,aAAa,SAASC,cAAa;AACrC,WAAK,IAAI,MAAA;AAET,WAAK,IAAI,MAAA;AAET,wBAAkB,MAAA;AAClB,gBAAU,OAAO,IAAI;AAAA,IACvB,GACI,SAAS,SAASX,UAAS;AAC7B,UAAI,KAAK,KAAK,SAAS,gBAAgB,MAAM,GACzC,KAAK,KAAK,SAAS,gBAAgB,MAAM,GACzC,WAAW,KAAK,IAAI,EAAE,KAAK,WAC3B,WAAW,KAAK,IAAI,EAAE,KAAK;AAE/B,mBAAa,YAAY,aAAa,SAAS,MAAM,IAAI,IAAI,QAAQ,MAAM;AAE3E,UAAI,UAAU;AACZ,mBAAW,KAAK,SAAS,KAAK,QAAQ,IAAI;AAC1C,kBAAU,KAAK,SAAS,KAAK,OAAO,IAAI;AACxC,qBAAa,UAAU,IAAI;AAC3B,qBAAa,KAAK,SAAS,MAAM,aAAa,KAAK,UAAU,IAAI;AACjE,qBAAa,KAAK;AAClB,eAAO,CAAC,IAAI,OAAO,CAAC,IAAI,OAAO,CAAC,IAAI;AAAA,MACtC;AAEA,UAAI,UAAU;AACZ,kBAAU,KAAK,SAAS,KAAK,OAAO,IAAI;AACxC,gBAAQ,KAAK,SAAS,KAAK,KAAK,IAAI;AACpC,qBAAa,UAAU,IAAI;AAC3B,qBAAa,KAAK,SAAS,MAAM,aAAa,KAAK,UAAU,IAAI;AACjE,qBAAa,KAAK;AAClB,eAAO,CAAC,IAAI,OAAO,CAAC,IAAI,OAAO,CAAC,IAAI;AAAA,MACtC;AAEA,UAAI,SAAS,SAAS;AACpB,kBAAU,OAAO,IAAI;AAErB,YAAI,SAAS;AACX,yBAAe,YAAY,KAAK,YAAY,IAAI;AAChD,oBAAU,OAAO,IAAI;AACrB,oBAAU;AAAA,QACZ;AAEA,gBAAQ;AAAA,MACV;AAEA,gBAAU,EAAE,SAAS,UAAU,cAAc,WAAW,IAAI;AAE5D,UAAI,SAAS;AACX,gBAAQ,IAAI;AACZ,kBAAU;AAAA,MACZ;AAEA,WAAK;AAAA,IACP,GACI,UAAU,SAASY,SAAQ,GAAG,GAAG,OAAO;AAC1C,aAAO,KAAK,KAAK;AACjB,aAAO,KAAK,KAAK;AAEjB,WAAK,IAAI,OAAO,CAAC;AAEjB,WAAK,IAAI,OAAO,CAAC;AAEjB,iBAAW,OAAO,KAAK,sBAAsB,MAAM,KAAK,OAAA;AAAA,IAC1D,GACI,wBAAwB,SAASC,uBAAsB,GAAG,GAAG;AAC/D,UAAI,YAAY,CAAC,MAAM;AACrB,aAAK,OAAO,OAAO,KAAK,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,MAAM;AACrD,iBAAS;AAAA,MACX;AAEA,UAAI,SAAS,KAAK;AAChB,eAAO,CAAC,KAAK;AAEb,aAAK,IAAI,OAAO,GAAG,IAAI;AAAA,MAEzB;AAEA,UAAI,SAAS,KAAK;AAChB,eAAO,CAAC,KAAK;AAEb,aAAK,IAAI,OAAO,GAAG,IAAI;AAAA,MACzB;AAEA,iBAAW,OAAO,KAAK,sBAAsB,MAAM,KAAK,OAAA;AAAA,IAC1D,GACI,UAAU,SAASC,SAAQ,GAAG;AAChC,UAAI,aAAa,GAAG,CAAC,GAAG;AACtB;AAAA,MACF;AAEA,UAAI,UAAU,GAAG,cAAc;AAC/B,UAAI,IAAI,EAAE,SACN,IAAI,EAAE,SACN,KAAK,IAAI,KAAK,GACd,KAAK,IAAI,KAAK,GACd,aAAa,KAAK;AACtB,WAAK,IAAI;AACT,WAAK,IAAI;AAET,UAAI,eAAe,MAAM,QAAQ,KAAK,IAAI,KAAK,SAAS,CAAC,KAAK,eAAe,KAAK,IAAI,KAAK,SAAS,CAAC,KAAK,cAAc;AACtH,kBAAU,aAAa,IAAI;AAE3B,uBAAe,KAAK,aAAa;AACjC,8BAAsB,IAAI,EAAE;AAAA,MAC9B;AAAA,IACF,GACI,WAAW,KAAK,UAAU,SAAU,GAAG;AACzC,UAAI,aAAa,GAAG,CAAC,KAAK,KAAK,EAAE,QAAQ;AACvC;AAAA,MACF;AAEA,WAAK,OAAO,OAAO;AACnB,wBAAkB,MAAA;AAClB,WAAK,YAAY;AACjB,UAAI,UAAU,CAAC;AAEf,mBAAa,aAAa;AAC1B,WAAK,SAAS,KAAK,IAAI,EAAE;AACzB,WAAK,SAAS,KAAK,IAAI,EAAE;AAEzB,WAAK,IAAI,MAAA;AAGT,WAAK,IAAI,MAAA;AAETvB,qBAAa,eAAe,SAAS,UAAU,YAAY,CAAC,GAAG,SAAS,SAAS,IAAI;AAErF,WAAK,SAAS,KAAK,SAAS;AAC5B,iBAAW,QAAQ,IAAI;AAAA,IACzB,GACI,aAAa,KAAK,YAAY,SAAU,GAAG;AAC7C,UAAI,aAAa,GAAG,CAAC,GAAG;AACtB;AAAA,MACF;AAEAC,wBAAgB,eAAe,SAAS,UAAU,YAAY,CAAC,GAAG,SAAS,IAAI;AAE/E,UAAI,iBAAiB,CAAC,MAAM,KAAK,IAAI,KAAK,MAAM,GAC5C,cAAc,KAAK,YACnB,iBAAiB,gBAAgB,KAAK,IAAI,KAAK,IAAI,KAAK,MAAM,IAAI,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,MAAM,IAAI,IAE5G,YAAY,UAAU,CAAC;AAEvB,UAAI,CAAC,kBAAkB,gBAAgB;AACrC,aAAK,IAAI,MAAA;AAET,aAAK,IAAI,MAAA;AAGT,YAAI,kBAAkB,aAAa;AACjCjB,iBAAK,YAAY,MAAM,WAAY;AAEjC,gBAAIW,eAAa,cAAc,OAAO,CAAC,EAAE,kBAAkB;AACzD,kBAAI,EAAE,OAAO,OAAO;AAElB,kBAAE,OAAO,MAAA;AAAA,cACX,WAAW,SAAS,aAAa;AAC/B,oBAAI,iBAAiB,SAAS,YAAY,aAAa;AACvD,+BAAe,eAAe,SAAS,MAAM,MAAMT,QAAM,GAAG,UAAU,SAAS,UAAU,SAAS,UAAU,SAAS,UAAU,SAAS,OAAO,OAAO,OAAO,OAAO,GAAG,IAAI;AAC3K,kBAAE,OAAO,cAAc,cAAc;AAAA,cACvC;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAEA,WAAK,aAAa,KAAK,cAAc,KAAK,YAAY;AACtD,gBAAU,eAAe,CAAC,gBAAgB,kBAAkB,QAAQ,IAAI;AACxE,iBAAW,OAAA;AAEX,mBAAa,eAAe,UAAU,IAAI;AAC1C,mBAAa,UAAU,MAAM,cAAc;AAAA,IAC7C,GACI,kBAAkB,SAASsC,iBAAgB,GAAG;AAChD,aAAO,EAAE,WAAW,EAAE,QAAQ,SAAS,MAAM,KAAK,cAAc,SAAS,eAAe,GAAG,KAAK,UAAU;AAAA,IAC5G,GACI,gBAAgB,SAASC,iBAAgB;AAC3C,cAAQ,KAAK,cAAc,UAAU,aAAa,IAAI;AAAA,IACxD,GACI,WAAW,SAASC,UAAS,GAAG;AAClC,UAAI,aAAa,CAAC,GAAG;AACnB;AAAA,MACF;AAEA,UAAI,IAAI,eACJ,IAAI,YAAA;AACR,eAAS,IAAI,WAAW,cAAc,IAAI,WAAW,aAAa,CAAC;AACnE,gBAAU;AACV,gBAAU;AACV,gBAAU,kBAAkB,QAAQ,IAAI;AAAA,IAC1C,GACI,WAAW,SAASC,UAAS,GAAG;AAClC,UAAI,aAAa,CAAC,GAAG;AACnB;AAAA,MACF;AAEA,UAAI,UAAU,GAAG,cAAc;AAC/B,kBAAY,UAAU;AACtB,UAAI,cAAc,EAAE,cAAc,IAAI,aAAa,EAAE,cAAc,IAAIzC,OAAK,cAAc,KAAK;AAC/F,cAAQ,EAAE,SAAS,YAAY,EAAE,SAAS,YAAY,CAAC;AACvD,gBAAU,CAAC,gBAAgB,kBAAkB,QAAQ,IAAI;AAAA,IAC3D,GACI,UAAU,SAAS0C,SAAQ,GAAG;AAChC,UAAI,aAAa,CAAC,GAAG;AACnB;AAAA,MACF;AAEA,UAAI,IAAI,EAAE,SACN,IAAI,EAAE,SACN,KAAK,IAAI,KAAK,GACd,KAAK,IAAI,KAAK;AAClB,WAAK,IAAI;AACT,WAAK,IAAI;AACT,cAAQ;AACR,gBAAU,kBAAkB,QAAQ,IAAI;AACxC,OAAC,MAAM,OAAO,sBAAsB,IAAI,EAAE;AAAA,IAC5C,GACI,WAAW,SAASC,UAAS,GAAG;AAClC,WAAK,QAAQ;AACb,cAAQ,IAAI;AAAA,IACd,GACI,cAAc,SAASC,aAAY,GAAG;AACxC,WAAK,QAAQ;AACb,iBAAW,IAAI;AAAA,IACjB,GACI,WAAW,SAASC,UAAS,GAAG;AAClC,aAAO,aAAa,CAAC,KAAK,UAAU,GAAG,cAAc,KAAK,QAAQ,IAAI;AAAA,IACxE;AAEA,wBAAoB,KAAK,MAAM/C,OAAK,YAAY,eAAe,MAAM,UAAU,EAAE,MAAA;AACjF,SAAK,SAAS,KAAK,SAAS;AAC5B,SAAK,MAAM,iBAAiB,GAAG,IAAI,IAAI;AACvC,SAAK,MAAM,iBAAiB,GAAG,IAAI,IAAI;AACvC,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,aAAa,KAAK,cAAc,KAAK,YAAY;AAEtDS,eAAS,IAAI;AAEb,SAAK,SAAS,SAAU,GAAG;AACzB,UAAI,CAAC,KAAK,WAAW;AACnBO,uBAAa,aAAa,WAAW,QAAQ,UAAUE,WAAS;AAEhE,aAAK,QAAQ,QAAQ,KAAK,KAAKF,eAAa,aAAa,WAAW,QAAQ,UAAU,UAAU,SAAS,OAAO;AAChH,aAAK,QAAQ,OAAO,KAAK,KAAKA,eAAa,QAAQ,SAAS,UAAU,SAAS,OAAO;AAEtF,YAAI,KAAK,QAAQ,OAAO,KAAK,KAAK,YAAY,KAAK,QAAQ,SAAS,KAAK,GAAG;AAC1EA,yBAAa,QAAQ,YAAY,CAAC,GAAG,UAAU,SAAS,OAAO;AAE/DA,yBAAa,UAAU,YAAY,CAAC,GAAG,UAAU;AAEjDA,yBAAa,UAAU,YAAY,CAAC,GAAG,UAAU;AAEjD,yBAAeA,eAAa,QAAQ,SAAS,cAAc,MAAM,IAAI;AACrE,qBAAWA,eAAa,QAAQ,SAAS,QAAQ;AACjD,4BAAkBA,eAAa,UAAU,gBAAgB,eAAe;AACxE,0BAAgBA,eAAa,UAAU,cAAc,aAAa;AAClE,qBAAWA,eAAa,QAAQ,eAAe,SAAS,QAAQ;AAChE,wBAAcA,eAAa,QAAQ,eAAe,SAAS,WAAW;AACtE,oBAAUA,eAAa,QAAQ,eAAe,QAAQ,OAAO;AAAA,QAC/D;AAEA,aAAK,YAAY;AACjB,aAAK,aAAa,KAAK,cAAc,KAAK,YAAY,QAAQ,UAAU;AAExE,aAAK,IAAI,MAAA;AAET,aAAK,IAAI,MAAA;AAET,kBAAU,YAAA;AACV,kBAAU,YAAA;AACV,aAAK,EAAE,QAAQ,SAAS,CAAC;AACzB,oBAAY,SAAS,IAAI;AAAA,MAC3B;AAEA,aAAO;AAAA,IACT;AAEA,SAAK,UAAU,WAAY;AACzB,UAAI,KAAK,WAAW;AAElB,mBAAW,OAAO,SAAU,GAAG;AAC7B,iBAAO,MAAM,QAAQD,cAAY,EAAE,MAAM;AAAA,QAC3C,CAAC,EAAE,UAAUE,kBAAgB,aAAa,WAAW,QAAQ,UAAUC,WAAS;AAEhF,YAAI,KAAK,WAAW;AAClB,eAAK,IAAI,MAAA;AAET,eAAK,IAAI,MAAA;AAETD,4BAAgB,eAAe,SAAS,UAAU,YAAY,CAAC,GAAG,SAAS,IAAI;AAAA,QACjF;AAEAA,0BAAgB,aAAa,WAAW,QAAQ,UAAU,UAAU,OAAO;AAE3EA,0BAAgB,QAAQ,SAAS,UAAU,OAAO;AAElDA,0BAAgB,QAAQ,YAAY,CAAC,GAAG,UAAU,OAAO;AAEzDA,0BAAgB,UAAU,YAAY,CAAC,GAAG,UAAU;AAEpDA,0BAAgB,UAAU,YAAY,CAAC,GAAG,UAAU;AAEpDA,0BAAgB,QAAQ,SAAS,cAAc,IAAI;AAEnDA,0BAAgB,QAAQ,SAAS,QAAQ;AAEzCA,0BAAgB,UAAU,gBAAgB,eAAe;AAEzDA,0BAAgB,UAAU,cAAc,aAAa;AAErDA,0BAAgB,QAAQ,eAAe,SAAS,QAAQ;AAExDA,0BAAgB,QAAQ,eAAe,SAAS,WAAW;AAE3DA,0BAAgB,QAAQ,eAAe,QAAQ,OAAO;AAEtD,aAAK,YAAY,KAAK,YAAY,KAAK,aAAa;AACpD,qBAAa,UAAU,IAAI;AAAA,MAC7B;AAAA,IACF;AAEA,SAAK,OAAO,KAAK,SAAS,WAAY;AACpC,WAAK,QAAA;AAEL,UAAI,IAAI,WAAW,QAAQ,IAAI;AAE/B,WAAK,KAAK,WAAW,OAAO,GAAG,CAAC;AAChCT,wBAAgB,SAASA,gBAAc;AAAA,IACzC;AAEA,eAAW,KAAK,IAAI;AAEpB,oBAAgBO,cAAY,MAAM,MAAMP,gBAAc;AACtD,SAAK,OAAO,KAAK;AAAA,EACnB;AAEA,eAAayB,WAAU,CAAC;AAAA,IACtB,KAAK;AAAA,IACL,KAAK,SAAS,MAAM;AAClB,aAAO,KAAK,IAAI,YAAA;AAAA,IAClB;AAAA,EAAA,GACC;AAAA,IACD,KAAK;AAAA,IACL,KAAK,SAAS,MAAM;AAClB,aAAO,KAAK,IAAI,YAAA;AAAA,IAClB;AAAA,EAAA,CACD,CAAC;AAEF,SAAOA;AACT,GAAA;AACA,SAAS,UAAU;AAEnB,SAAS,SAAS,SAAU,MAAM;AAChC,SAAO,IAAI,SAAS,IAAI;AAC1B;AAEA,SAAS,WAAW;AAEpB,SAAS,SAAS,WAAY;AAC5B,SAAO,WAAW,MAAA;AACpB;AAEA,SAAS,UAAU,SAAU,IAAI;AAC/B,SAAO,WAAW,OAAO,SAAU,GAAG;AACpC,WAAO,EAAE,KAAK,OAAO;AAAA,EACvB,CAAC,EAAE,CAAC;AACN;AAEAvB,gBAAcV,OAAK,eAAe,QAAQ;AClsB1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA,IAAI,MACA,cACA,MACA,MACA,QACA,OACA,OACA,cACA,UACA,QACA,QACA,eACA,aACA,gBACA,gBACA,IACA,YACA,aACA,cACA,OACA,qBACA,eACA,aACA,qBACA,mBACA,kBACA,YACA,UACA,oBACA,WACA,QACA,aACA,cACA,iBAEJ,WAAW,GACP,WAAW,KAAK,KAChB,SAAS,SAAA,GACT,kBAAkB,GAClB,WAAW,GACX,cAAc,SAASgD,aAAY,OAAO,MAAM,MAAM;AACxD,MAAI,QAAQ,UAAU,KAAK,MAAM,MAAM,OAAO,GAAG,CAAC,MAAM,YAAY,MAAM,QAAQ,KAAK,IAAI;AAC3F,OAAK,MAAM,OAAO,OAAO,IAAI;AAC7B,SAAO,QAAQ,MAAM,OAAO,GAAG,MAAM,SAAS,CAAC,IAAI;AACrD,GACI,aAAa,SAASC,YAAW,OAAO,OAAO;AACjD,SAAO,UAAU,CAAC,UAAU,KAAK,KAAK,MAAM,OAAO,GAAG,CAAC,MAAM,YAAY,WAAW,QAAQ,MAAM;AACpG,GACI,aAAa,SAASC,cAAa;AACrC,SAAO,YAAY,sBAAsBA,WAAU;AACrD,GAEA,sBAAsB,SAASC,uBAAsB;AACnD,SAAO,iBAAiB;AAC1B,GACI,oBAAoB,SAASC,qBAAoB;AACnD,SAAO,iBAAiB;AAC1B,GACI,eAAe,SAASC,cAAa,GAAG;AAC1C,SAAO;AACT,GACI,SAAS,SAASC,QAAO,OAAO;AAClC,SAAO,KAAK,MAAM,QAAQ,GAAM,IAAI,OAAU;AAChD,GACI,gBAAgB,SAASC,iBAAgB;AAC3C,SAAO;AACT,GACI,WAAW,SAAS7C,aAAW;AACjC,SAAO,QAAQ,cAAA;AACjB,GACI,cAAc,SAASK,cAAY,GAAG;AACxC,SAAO,CAAC,CAAC,CAAC,MAAM,QAAQ,CAAC;AAC3B,GACI,wBAAwB,SAASyC,uBAAsB,mBAAmB;AAC5E,UAAQ,sBAAsB,WAAW,SAAS,KAAK,UAAU,iBAAiB,MAAM,OAAO,WAAW,iBAAiB,KAAK,MAAM,WAAW,iBAAiB;AACpK,GACI,iBAAiB,SAASC,gBAAe,SAAS;AACpD,SAAO,cAAc,SAAS,uBAAuB,MAAM,YAAY,OAAO,IAAI,WAAY;AAC5F,gBAAY,QAAQ,KAAK;AACzB,gBAAY,SAAS;AACrB,WAAO;AAAA,EACT,IAAI,WAAY;AACd,WAAO,WAAW,OAAO;AAAA,EAC3B;AACF,GACI,eAAe,SAASC,cAAa,UAAU,YAAY,MAAM;AACnE,MAAI,IAAI,KAAK,GACT,KAAK,KAAK,IACV,IAAI,KAAK;AACb,UAAQ,IAAI,cAAc,UAAU,uBAAuB,KAAK,WAAY;AAC1E,WAAO,EAAA,EAAI,CAAC;AAAA,EACd,IAAI,WAAY;AACd,YAAQ,aAAa,sBAAsB,EAAE,IAAI,SAAS,WAAW,EAAE,MAAM;AAAA,EAC/E;AACF,GACI,kBAAkB,SAASC,iBAAgB,SAAS,YAAY;AAClE,SAAO,CAAC,cAAc,CAAC,SAAS,QAAQ,OAAO,IAAI,eAAe,OAAO,IAAI,WAAY;AACvF,WAAO;AAAA,EACT;AACF,GACI,aAAa,SAASC,YAAW,SAAS,OAAO;AACnD,MAAI,IAAI,MAAM,GACV,KAAK,MAAM,IACX,IAAI,MAAM,GACV,IAAI,MAAM;AACd,SAAO,KAAK,IAAI,IAAI,IAAI,WAAW,QAAQ,IAAI,cAAc,SAAS,CAAC,KAAK,EAAA,IAAM,eAAe,OAAO,IAAI,CAAC,IAAI,YAAY,OAAO,KAAK,OAAO,CAAC,KAAK,MAAM,CAAC,KAAK,sBAAsB,EAAE,IAAI,QAAQ,CAAC,IAAI,QAAQ,WAAW,EAAE,CAAC;AACnO,GACI,sBAAsB,SAASC,qBAAoB,MAAM,QAAQ;AACnE,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK,GAAG;AAC/C,KAAC,CAAC,UAAU,CAAC,OAAO,QAAQ,aAAa,IAAI,CAAC,CAAC,MAAM,KAAK,aAAa,CAAC,GAAG,aAAa,IAAI,CAAC,GAAG,aAAa,IAAI,CAAC,CAAC;AAAA,EACrH;AACF,GACI,YAAY,SAASC,WAAU,OAAO;AACxC,SAAO,OAAO,UAAU;AAC1B,GACI,cAAc,SAASC,aAAY,OAAO;AAC5C,SAAO,OAAO,UAAU;AAC1B,GACI,YAAY,SAASC,WAAU,OAAO;AACxC,SAAO,OAAO,UAAU;AAC1B,GACI,YAAY,SAASC,WAAU,OAAO;AACxC,SAAO,OAAO,UAAU;AAC1B,GACI,gBAAgB,SAASC,eAAc,WAAW,UAAU,OAAO;AACrE,SAAO,aAAa,UAAU,SAAS,WAAW,IAAI,CAAC,KAAK,SAAS,UAAU,MAAA;AACjF,GACI,YAAY,SAASC,WAAU,MAAM,MAAM;AAC7C,MAAI,KAAK,SAAS;AAChB,QAAI,SAAS,KAAK,OAAO,KAAK,KAAK,IAAI,WAAY;AACjD,aAAO,KAAK,IAAI;AAAA,IAClB,CAAC,IAAI,KAAK,IAAI;AACd,cAAU,OAAO,cAAc,KAAK,oBAAoB;AAAA,EAC1D;AACF,GACI,OAAO,KAAK,KACZ,QAAQ,QACR,OAAO,OACP,SAAS,SACT,UAAU,UACV,SAAS,SACT,UAAU,UACV,SAAS,SACT,QAAQ,QACR,OAAO,OACP,UAAU,UACV,WAAW,WACX,UAAU,UACV,SAAS,SACT,UAAU,UACV,MAAM,MACN,oBAAoB,SAASC,mBAAkB,SAAS;AAC1D,SAAO,KAAK,iBAAiB,OAAO;AACtC,GACI,oBAAoB,SAASC,mBAAkB,SAAS;AAE1D,MAAI,WAAW,kBAAkB,OAAO,EAAE;AAE1C,UAAQ,MAAM,WAAW,aAAa,cAAc,aAAa,UAAU,WAAW;AACxF,GACI,eAAe,SAASC,cAAa,KAAK,UAAU;AACtD,WAAS,KAAK,UAAU;AACtB,SAAK,QAAQ,IAAI,CAAC,IAAI,SAAS,CAAC;AAAA,EAClC;AAEA,SAAO;AACT,GACI,aAAa,SAASC,YAAW,SAAS,mBAAmB;AAC/D,MAAI,QAAQ,qBAAqB,kBAAkB,OAAO,EAAE,cAAc,MAAM,8BAA8B,KAAK,GAAG,SAAS;AAAA,IAC7H,GAAG;AAAA,IACH,GAAG;AAAA,IACH,UAAU;AAAA,IACV,UAAU;AAAA,IACV,UAAU;AAAA,IACV,WAAW;AAAA,IACX,WAAW;AAAA,IACX,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,EAAA,CACR,EAAE,SAAS,CAAC,GACT,SAAS,QAAQ,sBAAA;AACrB,WAAS,MAAM,SAAS,CAAC,EAAE,KAAA;AAC3B,SAAO;AACT,GACI,WAAW,SAASC,UAAS,SAAS,OAAO;AAC/C,MAAI,KAAK,MAAM;AACf,SAAO,QAAQ,WAAW,EAAE,KAAK,QAAQ,WAAW,EAAE,KAAK;AAC7D,GACI,sBAAsB,SAASC,qBAAoB,UAAU;AAC/D,MAAI,IAAI,IACJ,SAAS,SAAS,QAClB,WAAW,SAAS,SAAA,GACpB;AAEJ,OAAK,KAAK,QAAQ;AAChB,MAAE,KAAK,OAAO,CAAC,IAAI,QAAQ;AAAA,EAC7B;AAEA,SAAO;AACT,GACI,mBAAmB,SAASC,kBAAiB,WAAW;AAC1D,SAAO,SAAU,OAAO;AACtB,WAAO,KAAK,MAAM,KAAK,oBAAoB,SAAS,GAAG,KAAK;AAAA,EAC9D;AACF,GACI,mBAAmB,SAASC,kBAAiB,sBAAsB;AACrE,MAAI,OAAO,KAAK,MAAM,KAAK,oBAAoB,GAC3C,IAAI,MAAM,QAAQ,oBAAoB,KAAK,qBAAqB,MAAM,CAAC,EAAE,KAAK,SAAUC,IAAG,GAAG;AAChG,WAAOA,KAAI;AAAA,EACb,CAAC;AACD,SAAO,IAAI,SAAU,OAAO,WAAW,WAAW;AAChD,QAAI,cAAc,QAAQ;AACxB,kBAAY;AAAA,IACd;AAEA,QAAI;AAEJ,QAAI,CAAC,WAAW;AACd,aAAO,KAAK,KAAK;AAAA,IACnB;AAEA,QAAI,YAAY,GAAG;AACjB,eAAS;AAET,WAAK,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAC7B,YAAI,EAAE,CAAC,KAAK,OAAO;AACjB,iBAAO,EAAE,CAAC;AAAA,QACZ;AAAA,MACF;AAEA,aAAO,EAAE,IAAI,CAAC;AAAA,IAChB,OAAO;AACL,UAAI,EAAE;AACN,eAAS;AAET,aAAO,KAAK;AACV,YAAI,EAAE,CAAC,KAAK,OAAO;AACjB,iBAAO,EAAE,CAAC;AAAA,QACZ;AAAA,MACF;AAAA,IACF;AAEA,WAAO,EAAE,CAAC;AAAA,EACZ,IAAI,SAAU,OAAO,WAAW,WAAW;AACzC,QAAI,cAAc,QAAQ;AACxB,kBAAY;AAAA,IACd;AAEA,QAAI,UAAU,KAAK,KAAK;AACxB,WAAO,CAAC,aAAa,KAAK,IAAI,UAAU,KAAK,IAAI,aAAa,UAAU,QAAQ,MAAM,YAAY,IAAI,UAAU,KAAK,YAAY,IAAI,QAAQ,uBAAuB,QAAQ,oBAAoB;AAAA,EAClM;AACF,GACI,uBAAuB,SAASC,sBAAqB,UAAU;AACjE,SAAO,SAAU,OAAO,IAAI;AAC1B,WAAO,iBAAiB,oBAAoB,QAAQ,CAAC,EAAE,OAAO,GAAG,SAAS;AAAA,EAC5E;AACF,GACI,iBAAiB,SAASC,gBAAe,MAAM,SAAS,OAAO,UAAU;AAC3E,SAAO,MAAM,MAAM,GAAG,EAAE,QAAQ,SAAU,MAAM;AAC9C,WAAO,KAAK,SAAS,MAAM,QAAQ;AAAA,EACrC,CAAC;AACH,GACI,eAAe,SAAS9D,eAAa,SAAS,MAAM,MAAM,YAAY,SAAS;AACjF,SAAO,QAAQ,iBAAiB,MAAM,MAAM;AAAA,IAC1C,SAAS,CAAC;AAAA,IACV,SAAS,CAAC,CAAC;AAAA,EAAA,CACZ;AACH,GACI,kBAAkB,SAASC,kBAAgB,SAAS,MAAM,MAAM,SAAS;AAC3E,SAAO,QAAQ,oBAAoB,MAAM,MAAM,CAAC,CAAC,OAAO;AAC1D,GACI,iBAAiB,SAAS8D,gBAAe,MAAM,IAAI,YAAY;AACjE,eAAa,cAAc,WAAW;AAEtC,MAAI,YAAY;AACd,SAAK,IAAI,SAAS,UAAU;AAC5B,SAAK,IAAI,aAAa,UAAU;AAAA,EAClC;AACF,GACI,kBAAkB;AAAA,EACpB,YAAY;AAAA,EACZ,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,YAAY;AACd,GACI,YAAY;AAAA,EACd,eAAe;AAAA,EACf,eAAe;AACjB,GACI,YAAY;AAAA,EACd,KAAK;AAAA,EACL,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AACT,GACI,cAAc,SAASC,aAAY,OAAO,MAAM;AAClD,MAAI,UAAU,KAAK,GAAG;AACpB,QAAI,UAAU,MAAM,QAAQ,GAAG,GAC3B,WAAW,CAAC,UAAU,EAAE,MAAM,OAAO,UAAU,CAAC,IAAI,KAAK,WAAW,MAAM,OAAO,UAAU,CAAC,CAAC,IAAI;AAErG,QAAI,CAAC,SAAS;AACZ,YAAM,QAAQ,GAAG,IAAI,YAAY,YAAY,OAAO;AACpD,cAAQ,MAAM,OAAO,GAAG,UAAU,CAAC;AAAA,IACrC;AAEA,YAAQ,YAAY,SAAS,YAAY,UAAU,KAAK,IAAI,OAAO,CAAC,MAAM,QAAQ,GAAG,IAAI,WAAW,KAAK,IAAI,OAAO,MAAM,WAAW,KAAK,KAAK;AAAA,EACjJ;AAEA,SAAO;AACT,GACI,gBAAgB,SAASC,eAAc,MAAM,MAAM,WAAW,WAAW,OAAO,QAAQ,cAAc,oBAAoB;AAC5H,MAAI,aAAa,MAAM,YACnB,WAAW,MAAM,UACjB,WAAW,MAAM,UACjB,SAAS,MAAM,QACf,aAAa,MAAM;AAEvB,MAAI,IAAI,KAAK,cAAc,KAAK,GAC5B,mBAAmB,YAAY,SAAS,KAAK,cAAc,WAAW,SAAS,MAAM,SACrF,aAAa,KAAK,QAAQ,UAAU,MAAM,IAC1C,SAAS,mBAAmB,QAAQ,WACpC,UAAU,KAAK,QAAQ,OAAO,MAAM,IACpCC,SAAQ,UAAU,aAAa,UAC/B,MAAM,kBAAkBA,SAAQ,gBAAgB,WAAW,YAAYA,SAAQ,kBAAkB,aAAa;AAElH,SAAO,gBAAgB,cAAc,uBAAuB,mBAAmB,WAAW;AAC1F,GAAC,cAAc,sBAAsB,CAAC,sBAAsB,QAAQ,cAAc,YAAY,SAAS,WAAW,OAAO,SAAS,WAAW,MAAM,KAAK;AACxJ,mBAAiB,OAAO,iDAAiD,aAAa,cAAc;AACpG,IAAE,WAAW;AACb,IAAE,aAAa,SAAS,iBAAiB,QAAQ,OAAO,aAAa,OAAO,GAAG;AAC/E,IAAE,MAAM,UAAU;AAClB,IAAE,YAAY,QAAQ,SAAS,IAAI,OAAO,MAAM,OAAO;AACvD,SAAO,SAAS,CAAC,IAAI,OAAO,aAAa,GAAG,OAAO,SAAS,CAAC,CAAC,IAAI,OAAO,YAAY,CAAC;AACtF,IAAE,UAAU,EAAE,WAAW,UAAU,GAAG,EAAE;AAExC,kBAAgB,GAAG,GAAG,WAAW,OAAO;AAExC,SAAO;AACT,GACI,kBAAkB,SAASC,iBAAgB,QAAQ,OAAO,WAAW,SAAS;AAChF,MAAI,OAAO;AAAA,IACT,SAAS;AAAA,EAAA,GAEP,OAAO,UAAU,UAAU,QAAQ,IAAI,GACvC,eAAe,UAAU,UAAU,OAAO,KAAK;AACnD,SAAO,aAAa;AACpB,OAAK,UAAU,IAAI,SAAS,IAAI,UAAU,OAAO;AACjD,OAAK,UAAU,CAAC,IAAI,UAAU,QAAQ;AACtC,OAAK,WAAW,OAAO,MAAM,IAAI;AACjC,OAAK,WAAW,eAAe,MAAM,IAAI;AACzC,OAAK,UAAU,CAAC,IAAI,QAAQ;AAC5B,OAAK,IAAI,QAAQ,IAAI;AACvB,GACI,YAAY,CAAA,GACZ,OAAO,CAAA,GACP,QACA,QAAQ,SAASC,SAAQ;AAC3B,SAAO,aAAa,kBAAkB,OAAO,WAAW,SAAS,sBAAsB,UAAU;AACnG,GACI,YAAY,SAASlE,cAAY;AAEnC,MAAI,CAAC,eAAe,CAAC,YAAY,aAAa,YAAY,SAAS,MAAM,aAAa;AAEpF,eAAW;AAEX,QAAI,aAAa;AACf,iBAAW,SAAS,sBAAsB,UAAU;AAAA,IACtD,OAAO;AACL,iBAAA;AAAA,IAEF;AAEA,uBAAmB,UAAU,aAAa;AAC1C,sBAAkB,SAAA;AAAA,EACpB;AACF,GACI,qBAAqB,SAASmE,sBAAqB;AACrD,qBAAmB,KAAK;AACxB,sBAAoB,KAAK;AAC3B,GACI,YAAY,SAASC,WAAU,OAAO;AACxC,aAAW;AACX,GAAC,UAAU,QAAQ,CAAC,eAAe,CAAC,iBAAiB,CAAC,KAAK,qBAAqB,CAAC,KAAK,4BAA4B,CAAC,uBAAuB,qBAAqB,KAAK,cAAc,KAAK,IAAI,KAAK,cAAc,iBAAiB,IAAI,KAAK,cAAc,UAAU,aAAa,QAAQ,IAAI;AAC3R,GAEA,aAAa,CAAA,GACT,cAAc,CAAA,GACd,eAAe,SAASC,gBAAe;AACzC,SAAO,gBAAgB,eAAe,aAAaA,aAAY,KAAK,YAAY,IAAI;AACtF,GACI,YAAY,SAASC,WAAU,MAAM;AACvC,SAAO,WAAW,IAAI,KAAK,WAAW,IAAI,EAAE,IAAI,SAAU,GAAG;AAC3D,WAAO,EAAA;AAAA,EACT,CAAC,KAAK;AACR,GACI,eAAe,CAAA,GAEnB,kBAAkB,SAASC,iBAAgB,OAAO;AAChD,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK,GAAG;AAC/C,QAAI,CAAC,SAAS,aAAa,IAAI,CAAC,KAAK,aAAa,IAAI,CAAC,EAAE,UAAU,OAAO;AACxE,mBAAa,CAAC,EAAE,MAAM,UAAU,aAAa,IAAI,CAAC;AAClD,mBAAa,CAAC,EAAE,WAAW,aAAa,CAAC,EAAE,aAAa,aAAa,aAAa,IAAI,CAAC,KAAK,EAAE;AAC9F,mBAAa,IAAI,CAAC,EAAE,UAAU;AAAA,IAChC;AAAA,EACF;AACF,GACI,aAAa,SAASC,YAAW,MAAM,OAAO;AAChD,MAAI;AAEJ,OAAK,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AACxC,cAAU,UAAU,EAAE;AAEtB,QAAI,YAAY,CAAC,SAAS,QAAQ,SAAS,QAAQ;AACjD,UAAI,MAAM;AACR,gBAAQ,KAAK,CAAC;AAAA,MAChB,OAAO;AACL,gBAAQ,OAAO,MAAM,IAAI;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AAEA,gBAAc;AACd,WAAS,gBAAgB,KAAK;AAC9B,WAAS,UAAU,QAAQ;AAC7B,GACI,qBAAqB,SAASC,oBAAmB,mBAAmB,OAAO;AAE7E,aAAW;AACX,GAAC,SAAS,CAAC,mBAAmB,WAAW,QAAQ,SAAU,KAAK;AAC9D,WAAO,YAAY,GAAG,KAAK,IAAI,cAAc,IAAI,MAAM;AAAA,EACzD,CAAC;AACD,YAAU,iBAAiB,MAAM,KAAK,QAAQ,oBAAoB,qBAAqB;AACzF,GACI,gBACA,aAAa,GACb,iBACA,mBAAmB,SAASC,oBAAmB;AAEjD,MAAI,oBAAoB,YAAY;AAClC,QAAI,KAAK,kBAAkB;AAC3B,0BAAsB,WAAY;AAChC,aAAO,OAAO,cAAc,YAAY,IAAI;AAAA,IAC9C,CAAC;AAAA,EACH;AACF,GACI,gBAAgB,SAASC,iBAAgB;AAC3C,QAAM,YAAY,SAAS;AAE3B,WAAS,CAAC,eAAe,UAAU,gBAAgB,KAAK;AAExD,QAAM,YAAY,SAAS;AAC7B,GACI,kBAAkB,SAASC,iBAAgB,MAAM;AACnD,SAAO,SAAS,8FAA8F,EAAE,QAAQ,SAAU,IAAI;AACpI,WAAO,GAAG,MAAM,UAAU,OAAO,SAAS;AAAA,EAC5C,CAAC;AACH,GACI,cAAc,SAASC,aAAY,OAAO,YAAY;AACxD,WAAS,KAAK;AAEd,UAAQ,KAAK;AACb,UAAQ,CAAC,MAAM,MAAM,QAAQ,KAAK;AAElC,MAAI,mBAAmB,CAAC,SAAS,CAAC,aAAa;AAC7C,iBAAa,eAAe,aAAa,YAAY;AAErD;AAAA,EACF;AAEA,gBAAA;AAEA,mBAAiB,cAAc,eAAe;AAE9C,aAAW,QAAQ,SAAU,KAAK;AAChC,WAAO,YAAY,GAAG,KAAK,EAAE,IAAI,YAAY,IAAI,MAAM;EACzD,CAAC;AAGD,MAAI,eAAe,UAAU,aAAa;AAE1C,WAAS,cAAc,KAAA;AACvB,gBAAc,WAAA;AAEd,aAAW,QAAQ,SAAU,KAAK;AAChC,QAAI,YAAY,GAAG,GAAG;AACpB,UAAI,WAAW,IAAI,OAAO,MAAM,iBAAiB;AAEjD,UAAI,CAAC;AAAA,IACP;AAAA,EACF,CAAC;AAED,YAAU,MAAM,CAAC,EAAE,QAAQ,SAAU,GAAG;AACtC,WAAO,EAAE,QAAA;AAAA,EACX,CAAC;AAGD,gBAAc;AAEd,YAAU,QAAQ,SAAU,GAAG;AAE7B,QAAI,EAAE,iBAAiB,EAAE,KAAK;AAC5B,UAAI,OAAO,EAAE,KAAK,aAAa,gBAAgB,gBAC3C,WAAW,EAAE,IAAI,IAAI;AACzB,QAAE,OAAO,MAAM,CAAC;AAChB,QAAE,iBAAiB,EAAE,IAAI,IAAI,IAAI,QAAQ;AACzC,QAAE,QAAA;AAAA,IACJ;AAAA,EACF,CAAC;AAED,iBAAe;AAEf,kBAAgB,IAAI;AAEpB,YAAU,QAAQ,SAAU,GAAG;AAE7B,QAAI,MAAM,WAAW,EAAE,UAAU,EAAE,IAAI,GACnC,WAAW,EAAE,KAAK,QAAQ,SAAS,EAAE,aAAa,EAAE,MAAM,KAC1D,aAAa,EAAE,eAAe,EAAE,SAAS;AAE7C,KAAC,YAAY,eAAe,EAAE,aAAa,aAAa,MAAM,IAAI,EAAE,OAAO,WAAW,KAAK,IAAI,aAAa,MAAM,EAAE,QAAQ,GAAG,GAAG,IAAI,EAAE,KAAK,IAAI;AAAA,EACnJ,CAAC;AAED,kBAAgB,KAAK;AAErB,iBAAe;AACf,eAAa,QAAQ,SAAU,QAAQ;AACrC,WAAO,UAAU,OAAO,UAAU,OAAO,OAAO,EAAE;AAAA,EACpD,CAAC;AAED,aAAW,QAAQ,SAAU,KAAK;AAChC,QAAI,YAAY,GAAG,GAAG;AACpB,UAAI,UAAU,sBAAsB,WAAY;AAC9C,eAAO,IAAI,OAAO,MAAM,iBAAiB;AAAA,MAC3C,CAAC;AACD,UAAI,OAAO,IAAI,IAAI,GAAG;AAAA,IACxB;AAAA,EACF,CAAC;AAED,qBAAmB,oBAAoB,CAAC;AAExC,eAAa,MAAA;AAEb;AACA,mBAAiB;AAEjB,aAAW,CAAC;AAEZ,YAAU,QAAQ,SAAU,GAAG;AAC7B,WAAO,YAAY,EAAE,KAAK,SAAS,KAAK,EAAE,KAAK,UAAU,CAAC;AAAA,EAC5D,CAAC;AAED,mBAAiB,cAAc,eAAe;AAE9C,YAAU,SAAS;AACrB,GACI,cAAc,GACd,aAAa,GACb,UACA,aAAa,SAASC,YAAW,OAAO;AAC1C,MAAI,UAAU,KAAK,CAAC,kBAAkB,CAAC,aAAa;AAElD,kBAAc,aAAa;AAC3B,gBAAY,SAAS,OAAO,CAAC;AAE7B,QAAI,IAAI,UAAU,QACd,OAAO,YACP,iBAAiB,OAAO,UAAU,IAClC,SAAS,KAAK,UAAU,CAAC,EAAE,OAAA;AAE/B,iBAAa,cAAc,SAAS,KAAK;AACzC,uBAAmB,cAAc;AAEjC,QAAI,gBAAgB;AAClB,UAAI,mBAAmB,CAAC,kBAAkB,OAAO,kBAAkB,KAAK;AACtE,0BAAkB;AAElB,kBAAU,WAAW;AAAA,MACvB;AAEA,eAAS;AACT,eAAS;AAAA,IACX;AAEA,QAAI,aAAa,GAAG;AAClB,WAAK;AAEL,aAAO,OAAO,GAAG;AACf,kBAAU,EAAE,KAAK,UAAU,EAAE,EAAE,OAAO,GAAG,cAAc;AAAA,MACzD;AAEA,mBAAa;AAAA,IACf,OAAO;AACL,WAAK,KAAK,GAAG,KAAK,GAAG,MAAM;AACzB,kBAAU,EAAE,KAAK,UAAU,EAAE,EAAE,OAAO,GAAG,cAAc;AAAA,MACzD;AAAA,IACF;AAEA,kBAAc,aAAa;AAAA,EAC7B;AAEA,WAAS;AACX,GACI,mBAAmB,CAAC,OAAO,MAAM,SAAS,QAAQ,UAAU,SAAS,UAAU,QAAQ,UAAU,MAAM,UAAU,OAAO,WAAW,cAAc,SAAS,UAAU,mBAAmB,iBAAiB,gBAAgB,cAAc,YAAY,eAAe,aAAa,aAAa,OAAO,GAClS,cAAc,iBAAiB,OAAO,CAAC,QAAQ,SAAS,aAAa,QAAQ,QAAQ,QAAQ,SAAS,YAAY,SAAS,UAAU,WAAW,MAAM,WAAW,QAAQ,WAAW,SAAS,WAAW,KAAK,CAAC,GAC9M,cAAc,SAASC,aAAY,KAAK,QAAQ,OAAO;AACzD,YAAU,KAAK;AAEf,MAAI,QAAQ,IAAI;AAEhB,MAAI,MAAM,gBAAgB;AACxB,cAAU,MAAM,WAAW;AAAA,EAC7B,WAAW,IAAI,MAAM,WAAW;AAC9B,QAAI,SAAS,OAAO;AAEpB,QAAI,QAAQ;AACV,aAAO,aAAa,KAAK,MAAM;AAC/B,aAAO,YAAY,MAAM;AAAA,IAC3B;AAAA,EACF;AAEA,MAAI,MAAM,YAAY;AACxB,GACI,aAAa,SAASC,YAAW,KAAK,QAAQ,IAAI,aAAa;AACjE,MAAI,CAAC,IAAI,MAAM,WAAW;AACxB,QAAI,IAAI,iBAAiB,QACrB,cAAc,OAAO,OACrB,WAAW,IAAI,OACf;AAEJ,WAAO,KAAK;AACV,UAAI,iBAAiB,CAAC;AACtB,kBAAY,CAAC,IAAI,GAAG,CAAC;AAAA,IACvB;AAEA,gBAAY,WAAW,GAAG,aAAa,aAAa,aAAa;AACjE,OAAG,YAAY,aAAa,YAAY,UAAU;AAClD,aAAS,OAAO,IAAI,SAAS,MAAM,IAAI;AACvC,gBAAY,YAAY,GAAG,aAAa;AACxC,gBAAY,WAAW;AACvB,gBAAY,YAAY;AACxB,gBAAY,MAAM,IAAI,SAAS,KAAK,WAAW,IAAI;AACnD,gBAAY,OAAO,IAAI,SAAS,KAAK,SAAS,IAAI;AAClD,gBAAY,QAAQ,IAAI,SAAS,OAAO,IAAI,SAAS,IAAI,IAAI,SAAS,KAAK,IAAI;AAE/E,cAAU,WAAW;AAErB,aAAS,MAAM,IAAI,SAAS,QAAQ,MAAM,IAAI,GAAG,MAAM;AACvD,aAAS,OAAO,IAAI,SAAS,QAAQ,OAAO,IAAI,GAAG,OAAO;AAC1D,aAAS,QAAQ,IAAI,GAAG,QAAQ;AAEhC,QAAI,IAAI,eAAe,QAAQ;AAC7B,UAAI,WAAW,aAAa,QAAQ,GAAG;AACvC,aAAO,YAAY,GAAG;AAAA,IACxB;AAEA,QAAI,MAAM,YAAY;AAAA,EACxB;AACF,GACI,WAAW,YACX,YAAY,SAASC,WAAU,OAAO;AACxC,MAAI,OAAO;AACT,QAAI,QAAQ,MAAM,EAAE,OAChB,IAAI,MAAM,QACV,IAAI,GACJ,GACA;AACJ,KAAC,MAAM,EAAE,SAAS,KAAK,KAAK,SAAS,MAAM,CAAC,GAAG,UAAU;AAEzD,WAAO,IAAI,GAAG,KAAK,GAAG;AACpB,cAAQ,MAAM,IAAI,CAAC;AACnB,UAAI,MAAM,CAAC;AAEX,UAAI,OAAO;AACT,cAAM,CAAC,IAAI;AAAA,MACb,WAAW,MAAM,CAAC,GAAG;AACnB,cAAM,eAAe,EAAE,QAAQ,UAAU,KAAK,EAAE,aAAa;AAAA,MAC/D;AAAA,IACF;AAAA,EACF;AACF,GACI,YAAY,SAASC,WAAU,SAAS;AAE1C,MAAI,IAAI,YAAY,QAChB,QAAQ,QAAQ,OAChB,QAAQ,IACR,IAAI;AAER,SAAO,IAAI,GAAG,KAAK;AACjB,UAAM,KAAK,YAAY,CAAC,GAAG,MAAM,YAAY,CAAC,CAAC,CAAC;AAAA,EAClD;AAEA,QAAM,IAAI;AACV,SAAO;AACT,GACI,aAAa,SAASC,YAAW,OAAO,UAAU,aAAa;AACjE,MAAI,SAAS,IACT,IAAI,MAAM,QACV,IAAI,cAAc,IAAI,GAE1B;AAEA,SAAO,IAAI,GAAG,KAAK,GAAG;AACpB,QAAI,MAAM,CAAC;AACX,WAAO,KAAK,GAAG,KAAK,WAAW,SAAS,CAAC,IAAI,MAAM,IAAI,CAAC,CAAC;AAAA,EAC3D;AAEA,SAAO,IAAI,MAAM;AACjB,SAAO;AACT,GACI,cAAc;AAAA,EAChB,MAAM;AAAA,EACN,KAAK;AACP,GASA,iBAAiB,SAASC,gBAAe,OAAO,SAAS,cAAc,WAAW,QAAQ,QAAQ,gBAAgB,MAAM,gBAAgB,aAAa,kBAAkB,aAAa,oBAAoB,eAAe;AACrN,cAAY,KAAK,MAAM,QAAQ,MAAM,IAAI;AAEzC,MAAI,UAAU,KAAK,KAAK,MAAM,OAAO,GAAG,CAAC,MAAM,OAAO;AACpD,YAAQ,eAAe,MAAM,OAAO,CAAC,MAAM,MAAM,YAAY,MAAM,MAAM,OAAO,CAAC,GAAG,YAAY,IAAI;AAAA,EACtG;AAEA,MAAI,OAAO,qBAAqB,mBAAmB,SAAS,GACxD,IACA,IACA;AACJ,wBAAsB,mBAAmB,KAAK,CAAC;AAC/C,QAAM,KAAK,MAAM,QAAQ,CAAC;AAE1B,MAAI,CAAC,UAAU,KAAK,GAAG;AACrB,gBAAY,OAAO,MAAM,UAAU,QAAQ,IAAI;AAC/C,QAAI,WAAW,SAAS,KAAK,MAAM,GAAG,GAClC,QACA,aACA,cACA;AACJ,cAAU,WAAW,SAAS,IAAI,KAAK;AACvC,aAAS,WAAW,OAAO,KAAK,CAAA;AAEhC,SAAK,CAAC,UAAU,CAAC,OAAO,QAAQ,CAAC,OAAO,QAAQ,kBAAkB,OAAO,EAAE,YAAY,QAAQ;AAE7F,gBAAU,QAAQ,MAAM;AACxB,cAAQ,MAAM,UAAU;AACxB,eAAS,WAAW,OAAO;AAC3B,gBAAU,QAAQ,MAAM,UAAU,UAAU,QAAQ,MAAM,eAAe,SAAS;AAAA,IACpF;AAEA,kBAAc,YAAY,QAAQ,CAAC,GAAG,OAAO,UAAU,CAAC,CAAC;AACzD,mBAAe,YAAY,QAAQ,CAAC,KAAK,KAAK,YAAY;AAC1D,YAAQ,OAAO,UAAU,CAAC,IAAI,eAAe,UAAU,CAAC,IAAI,cAAc,cAAc,SAAS;AACjG,sBAAkB,gBAAgB,gBAAgB,cAAc,WAAW,eAAe,eAAe,MAAM,eAAe,YAAY,eAAe,EAAE;AAC3J,oBAAgB,eAAe;AAAA,EACjC,OAAO;AACL,2BAAuB,QAAQ,KAAK,MAAM,SAAS,mBAAmB,cAAc,OAAO,mBAAmB,cAAc,KAAK,GAAG,aAAa,KAAK;AACtJ,sBAAkB,gBAAgB,gBAAgB,cAAc,WAAW,IAAI;AAAA,EACjF;AAEA,MAAI,eAAe;AACjB,SAAK,aAAa,IAAI,SAAS;AAC/B,YAAQ,MAAM,QAAQ;AAAA,EACxB;AAEA,MAAI,QAAQ;AACV,QAAI,WAAW,QAAQ,cACnB,UAAU,OAAO;AACrB,SAAK,WAAW,UAAU;AAE1B,oBAAgB,QAAQ,UAAU,WAAW,WAAW,WAAW,MAAM,CAAC,YAAY,mBAAmB,KAAK,IAAI,MAAM,EAAE,GAAG,OAAO,EAAE,CAAC,IAAI,OAAO,WAAW,EAAE,MAAM,WAAW,CAAC;AAEjL,QAAI,kBAAkB;AACpB,uBAAiB,WAAW,cAAc;AAC1C,2BAAqB,OAAO,MAAM,UAAU,GAAG,CAAC,IAAI,eAAe,UAAU,GAAG,CAAC,IAAI,UAAU,GAAG,IAAI,OAAO,UAAU;AAAA,IACzH;AAAA,EACF;AAEA,MAAI,sBAAsB,SAAS;AACjC,SAAK,WAAW,OAAO;AACvB,uBAAmB,KAAK,WAAW;AACnC,SAAK,WAAW,OAAO;AACvB,uBAAmB,gBAAgB,GAAG,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC;AACnE,YAAQ,QAAQ,mBAAmB,gBAAgB;AAAA,EACrD;AAEA,wBAAsB,mBAAmB,KAAK,IAAI;AAClD,SAAO,qBAAqB,QAAQ,KAAK,MAAM,KAAK;AACtD,GACI,aAAa,sCACb,YAAY,SAASC,WAAU,SAAS,QAAQ,KAAK,MAAM;AAC7D,MAAI,QAAQ,eAAe,QAAQ;AACjC,QAAI,QAAQ,QAAQ,OAChB,GACA;AAEJ,QAAI,WAAW,OAAO;AACpB,cAAQ,UAAU,MAAM;AAExB,WAAK,kBAAkB,OAAO;AAE9B,WAAK,KAAK,IAAI;AAEZ,YAAI,CAAC,CAAC,KAAK,CAAC,WAAW,KAAK,CAAC,KAAK,GAAG,CAAC,KAAK,OAAO,MAAM,CAAC,MAAM,YAAY,MAAM,KAAK;AACpF,gBAAM,CAAC,IAAI,GAAG,CAAC;AAAA,QACjB;AAAA,MACF;AAEA,YAAM,MAAM;AACZ,YAAM,OAAO;AAAA,IACf,OAAO;AACL,YAAM,UAAU,QAAQ;AAAA,IAC1B;AAEA,SAAK,KAAK,SAAS,OAAO,EAAE,UAAU;AACtC,WAAO,YAAY,OAAO;AAAA,EAC5B;AACF,GACI,uBAAuB,SAASC,sBAAqB,cAAc,cAAc,aAAa;AAChG,MAAI,QAAQ,cACR,QAAQ;AACZ,SAAO,SAAU,OAAO;AACtB,QAAI,UAAU,KAAK,MAAM,aAAA,CAAc;AAEvC,QAAI,YAAY,SAAS,YAAY,SAAS,KAAK,IAAI,UAAU,KAAK,IAAI,KAAK,KAAK,IAAI,UAAU,KAAK,IAAI,GAAG;AAE5G,cAAQ;AACR,qBAAe,YAAA;AAAA,IACjB;AAEA,YAAQ;AACR,YAAQ,KAAK,MAAM,KAAK;AACxB,WAAO;AAAA,EACT;AACF,GACI,eAAe,SAASC,cAAa,QAAQ,WAAW,OAAO;AACjE,MAAI,OAAO,CAAA;AACX,OAAK,UAAU,CAAC,IAAI,OAAO;AAC3B,OAAK,IAAI,QAAQ,IAAI;AACvB,GAQA,mBAAmB,SAASC,kBAAiB,UAAU,WAAW;AAChE,MAAI,YAAY,eAAe,UAAU,SAAS,GAC9C,OAAO,YAAY,UAAU,IAEjC,WAAW,SAASC,UAAS,UAAU,MAAM,cAAc,SAAS,SAAS;AAC3E,QAAI,QAAQA,UAAS,OACjB,aAAa,KAAK,YAClB,YAAY,CAAA;AAChB,mBAAe,gBAAgB,UAAA;AAE/B,QAAI,uBAAuB,qBAAqB,WAAW,cAAc,WAAY;AACnF,YAAM,KAAA;AACNA,gBAAS,QAAQ;AAAA,IACnB,CAAC;AAED,cAAU,WAAW,WAAW;AAEhC,cAAU,WAAW,WAAW;AAChC,aAAS,MAAM,KAAA;AACf,SAAK,IAAI,IAAI;AACb,SAAK,UAAU;AACf,SAAK,YAAY;AAEjB,cAAU,IAAI,IAAI,WAAY;AAC5B,aAAO,qBAAqB,eAAe,UAAU,MAAM,QAAQ,UAAU,MAAM,QAAQ,MAAM,KAAK;AAAA,IACxG;AAEA,SAAK,WAAW,WAAY;AAC1B,iBAAW;AACXA,gBAAS,SAAS,WAAA;AAAA,IACpB;AAEA,SAAK,aAAa,WAAY;AAC5BA,gBAAS,QAAQ;AACjB,oBAAc,WAAW,KAAK,KAAK;AAAA,IACrC;AAEA,YAAQA,UAAS,QAAQ,KAAK,GAAG,UAAU,IAAI;AAC/C,WAAO;AAAA,EACT;AAEA,WAAS,IAAI,IAAI;AAEjB,YAAU,eAAe,WAAY;AACnC,WAAO,SAAS,SAAS,SAAS,MAAM,WAAW,SAAS,QAAQ;AAAA,EACtE;AAEA,eAAa,UAAU,SAAS,UAAU,YAAY;AAGtD,gBAAc,WAAW,aAAa,UAAU,aAAa,UAAU,YAAY;AACnF,SAAO;AACT;AAEO,IAAI,gBAA6B,4BAAY;AAClD,WAASrG,eAAc,MAAM,WAAW;AACtC,oBAAgBA,eAAc,SAAS,IAAI,KAAK,QAAQ,KAAK,2CAA2C;AAExG,aAAS,IAAI;AAEb,SAAK,KAAK,MAAM,SAAS;AAAA,EAC3B;AAEA,MAAI,SAASA,eAAc;AAE3B,SAAO,OAAO,SAAS,KAAK,MAAM,WAAW;AAC3C,SAAK,WAAW,KAAK,QAAQ;AAC7B,SAAK,QAAQ,KAAK,KAAK,MAAM,IAAI;AAEjC,QAAI,CAAC,UAAU;AACb,WAAK,SAAS,KAAK,UAAU,KAAK,OAAO;AACzC;AAAA,IACF;AAEA,WAAO,aAAa,UAAU,IAAI,KAAK,UAAU,IAAI,KAAK,KAAK,WAAW;AAAA,MACxE,SAAS;AAAA,IAAA,IACP,MAAM,SAAS;AAEnB,QAAI,QAAQ,MACR,WAAW,MAAM,UACjB,cAAc,MAAM,aACpB,KAAK,MAAM,IACX,WAAW,MAAM,UACjB,YAAY,MAAM,WAClB,QAAQ,MAAM,OACd,UAAU,MAAM,SAChB,MAAM,MAAM,KACZ,aAAa,MAAM,YACnB,sBAAsB,MAAM,qBAC5B,gBAAgB,MAAM,eACtB,kBAAkB,MAAM,iBACxB,iBAAiB,MAAM,gBACvB,OAAO,MAAM,MACb,OAAO,MAAM,MACb,cAAc,MAAM,aACpB,YAAY,MAAM,WAClB,qBAAqB,MAAM,oBAC3B,gBAAgB,MAAM,eACtB,kBAAkB,MAAM,iBACxB,YAAY,KAAK,cAAc,KAAK,sBAAsB,KAAK,eAAe,QAAQ,cAAc,WACpG,WAAW,CAAC,SAAS,UAAU,GAC/B,WAAW,WAAW,KAAK,YAAY,IAAI,GAC3C,gBAAgB,KAAK,KAAK,SAAS,QAAQ,GAC3C,aAAa,YAAY,QAAQ,GACjC,oBAAoB,aAAa,OAAO,KAAK,UAAU,cAAc,UAAU,SAAS,KAAK,cAAc,aAAa,SACxH,YAAY,CAAC,KAAK,SAAS,KAAK,SAAS,KAAK,aAAa,KAAK,WAAW,GAC3E,gBAAgB,YAAY,KAAK,cAAc,MAAM,GAAG,GACxD,UAAU,aAAa,OAAO,KAAK,UAAU,UAAU,SACvD,cAAc,aAAa,IAAI,WAAW,kBAAkB,QAAQ,EAAE,WAAW,UAAU,KAAK,MAAM,CAAC,KAAK,GAC5G,OAAO,MACP,gBAAgB,KAAK,iBAAiB,WAAY;AACpD,aAAO,KAAK,cAAc,IAAI;AAAA,IAChC,GACI,kBAAkB,aAAa,UAAU,YAAY,SAAS,GAC9D,qBAAqB,gBAAgB,UAAU,UAAU,GACzD,WAAW,GACX,cAAc,GACd,eAAe,GACf,aAAa,eAAe,UAAU,SAAS,GAC/C,SACA,UACA,UACA,SACA,SACA,OACA,KACA,aACA,WACA,oBACA,kBACA,YACA,oBACA,QACA,kBACA,gBACA,UACA,QACA,QACA,WACA,WACA,UACA,WACA,cACA,aACA,mBACA,UACA,iBACA,IACA,OACA,OACA,YACA,aACA,cACA,iBACA,YACA,kBACA,gBACA;AAGJ,SAAK,cAAc,KAAK,YAAY;AACpC,SAAK,OAAO;AACZ,qBAAiB;AACjB,SAAK,WAAW;AAChB,SAAK,SAAS,qBAAqB,mBAAmB,KAAK,KAAK,kBAAkB,IAAI;AACtF,cAAU,WAAA;AACV,SAAK,OAAO;AACZ,gBAAY,aAAa,KAAK;AAE9B,QAAI,qBAAqB,MAAM;AAC7B,cAAQ;AACR,WAAK,oBAAoB,UAAU,WAAW;AAAA,IAChD;AAEA,kBAAc,cAAc,cAAc,eAAe;AAAA,MACvD,KAAK,iBAAiB,UAAU,SAAS;AAAA,MACzC,MAAM,iBAAiB,UAAU,WAAW;AAAA,IAAA;AAE9C,SAAK,UAAU,UAAU,cAAc,YAAY,UAAU,CAAC;AAE9D,SAAK,gBAAgB,SAAU,OAAO;AACpC,oBAAc,UAAU,KAAK,KAAK;AAElC,UAAI,CAAC,aAAa;AAChB,sBAAc,WAAW,SAAS,CAAC,EAAE,KAAA;AACrC,qBAAa;AAAA,MACf,OAAO;AACL,qBAAa,WAAW,SAAS,KAAK,IAAI,aAAa,KAAK,GAAG,WAAW;AAAA,UACxE,MAAM;AAAA,UACN,eAAe;AAAA,UACf,SAAS;AAAA,UACT,UAAU;AAAA,UACV,QAAQ;AAAA,UACR,YAAY,SAAS,aAAa;AAChC,mBAAO,mBAAmB,gBAAgB,IAAI;AAAA,UAChD;AAAA,QAAA,CACD;AAAA,MACH;AAAA,IACF;AAEA,QAAI,WAAW;AACb,gBAAU,KAAK,OAAO;AACtB,gBAAU,YAAY,CAAC,KAAK,cAAc,UAAU,KAAK,oBAAoB,SAAS,KAAK,oBAAoB,SAAS,UAAU,SAAA,KAAc,UAAU,OAAO,GAAG,MAAM,IAAI;AAE9K,WAAK,YAAY,UAAU,MAAA;AAC3B,gBAAU,gBAAgB;AAC1B,WAAK,cAAc,KAAK;AACxB,cAAQ;AACR,aAAO,KAAK,UAAU,KAAK;AAAA,IAC7B;AAEA,QAAI,MAAM;AAER,UAAI,CAAC,UAAU,IAAI,KAAK,KAAK,MAAM;AACjC,eAAO;AAAA,UACL,QAAQ;AAAA,QAAA;AAAA,MAEZ;AAEA,0BAAoB,MAAM,SAAS,KAAK,IAAI,aAAa,CAAC,OAAO,MAAM,IAAI,UAAU;AAAA,QACnF,gBAAgB;AAAA,MAAA,CACjB;AAED,iBAAW,QAAQ,SAAU,GAAG;AAC9B,eAAO,YAAY,CAAC,KAAK,EAAE,YAAY,aAAa,KAAK,oBAAoB,SAAS,cAAc,EAAE,SAAS;AAAA,MACjH,CAAC;AAGD,iBAAW,YAAY,KAAK,MAAM,IAAI,KAAK,SAAS,KAAK,WAAW,WAAW,iBAAiB,SAAS,IAAI,KAAK,WAAW,sBAAsB,qBAAqB,SAAS,IAAI,KAAK,gBAAgB,QAAQ,SAAU,OAAO,IAAI;AACrO,eAAO,iBAAiB,KAAK,MAAM,EAAE,OAAO,aAAa,cAAc,MAAM,IAAI,GAAG,SAAS;AAAA,MAC/F,IAAI,KAAK,MAAM,KAAK,KAAK,MAAM;AAC/B,qBAAe,KAAK,YAAY;AAAA,QAC9B,KAAK;AAAA,QACL,KAAK;AAAA,MAAA;AAEP,qBAAe,UAAU,YAAY,IAAI,OAAO,aAAa,KAAK,aAAa,GAAG,IAAI,OAAO,cAAc,YAAY;AACvH,wBAAkB,KAAK,YAAY,KAAK,SAAS,cAAc,KAAK,KAAK,WAAY;AACnF,YAAI,SAAS,cACT,oBAAoB,aAAa,cAAc,KAC/C,QAAQ,QAAQ;AAEpB,aAAK,qBAAqB,KAAK,IAAI,KAAK,YAAA,CAAa,IAAI,OAAO,CAAC,SAAS,CAAC,kBAAkB,aAAa,QAAQ;AAChH,cAAI,YAAY,SAAS,SAAS,QAC9B,gBAAgB,aAAa,CAAC,WAAW,UAAU,cAAA,IAAkB,UACrE,WAAW,oBAAoB,KAAK,gBAAgB,UAAU,SAAA,IAAa,UAAU,OAAQ,GAC7F,UAAU,KAAK,MAAM,MAAM,CAAC,UAAU,IAAI,UAAU,KAAK,WAAW,CAAC,IAAI,WAAW,KAAK,GACzF,aAAa,YAAY,KAAK,YAAY,QAAQ,IAAI,UACtD,UACA,WACA,QAAQ,MACR,UAAU,MAAM,SAChB,eAAe,MAAM,aACrB,cAAc,MAAM;AACxB,qBAAW,SAAS,YAAY,IAAI;AACpC,oBAAU,QAAQ,MAAM,WAAW;AAEnC,sBAAY,KAAK,IAAI,GAAG,KAAK,MAAM,QAAQ,WAAW,MAAM,CAAC;AAE7D,cAAI,UAAU,OAAO,UAAU,SAAS,cAAc,QAAQ;AAC5D,gBAAI,SAAS,CAAC,MAAM,YAAY,MAAM,QAAQ,KAAK,YAAY,MAAM,GAAG;AAEtE;AAAA,YACF;AAEA,gBAAI,KAAK,YAAY,OAAO;AAC1B,wBAAU,WAAW;AAAA,YACvB;AAEA,oBAAQ,WAAW;AAAA,cACjB,UAAU,aAAa,KAAK,KAAK,IAAI,KAAK,aAAa,aAAa,GAAG,KAAK,WAAW,aAAa,CAAC,IAAI,QAAQ,WAAW,QAAQ,CAAC,CAAC;AAAA,cACtI,MAAM,KAAK,QAAQ;AAAA,cACnB,MAAM,KAAK,YAAY,MAAM;AAAA;AAAA,cAE7B,aAAa,SAAS,cAAc;AAClC,uBAAO,gBAAgB,QAAQ,IAAI,KAAK,gBAAgB,aAAa,IAAI;AAAA,cAC3E;AAAA,cACA,YAAY,SAAS,aAAa;AAChC,qBAAK,OAAA;AACL,2BAAW,WAAA;AAEX,oBAAI,aAAa,CAAC,UAAU;AAE1B,+BAAa,WAAW,QAAQ,iBAAiB,UAAU,UAAU,SAAS,UAAU,KAAK,IAAI,UAAU,SAAS,QAAQ;AAAA,gBAC9H;AAEA,wBAAQ,QAAQ,aAAa,CAAC,WAAW,UAAU,cAAA,IAAkB,KAAK;AAC1E,kCAAkB,eAAe,IAAI;AACrC,+BAAe,YAAY,IAAI;AAAA,cACjC;AAAA,YAAA,GACC,QAAQ,UAAU,QAAQ,YAAY,SAAS,UAAU,MAAM;AAClE,uBAAW,QAAQ,MAAM,QAAQ,KAAK;AAAA,UACxC;AAAA,QACF,WAAW,KAAK,YAAY,aAAa,QAAQ;AAC/C,0BAAgB,QAAQ,IAAI;AAAA,QAC9B;AAAA,MACF,CAAC,EAAE,MAAA;AAAA,IACL;AAEA,WAAO,KAAK,EAAE,IAAI;AAClB,cAAU,KAAK,UAAU,WAAW,WAAW,QAAQ,QAAQ,GAAG;AAElE,yBAAqB,WAAW,QAAQ,SAAS,QAAQ,MAAM;AAC/D,2BAAuB,qBAAqB,mBAAmB,IAAI;AACnE,UAAM,QAAQ,OAAO,UAAU,WAAW,GAAG;AAC7C,cAAU,WAAW,MAAM,cAAc;AAAA,MACvC,SAAS;AAAA,MACT,WAAW;AAAA,IAAA;AAGb,QAAI,KAAK;AACP,qBAAe,SAAS,eAAe,YAAY,aAAa,CAAC,cAAc,IAAI,cAAc,IAAI,WAAW,SAAS,kBAAkB,IAAI,UAAU,EAAE,YAAY,SAAS,QAAQ;AAExL,WAAK,MAAM;AACX,iBAAW,KAAK,KAAK,SAAS,GAAG;AAEjC,UAAI,CAAC,SAAS,QAAQ;AAEpB,YAAI,WAAW;AACb,sBAAY,WAAW,SAAS;AAChC,uBAAa,CAAC,UAAU,aAAa,YAAY,UAAU,WAAW,UAAU;AAEhF,mBAAS,iBAAiB,CAAC,CAAC;AAC5B,wBAAc,SAAS,cAAc,UAAU,SAAS;AAAA,QAC1D;AAEA,iBAAS,SAAS,SAAS,aAAa,KAAK,cAAc,KAAK;AAChE,eAAO,UAAU,IAAI,YAAY;AACjC,cAAM,OAAO,UAAU,IAAI,gBAAgB,EAAE;AAC7C,iBAAS,WAAW,mBAAmB,UAAU,GAAG;AAAA,MACtD,OAAO;AACL,2BAAmB,SAAS;AAAA,MAC9B;AAEA,WAAK,YAAY,SAAS,KAAK,IAAI,KAAK;AAAA,QACtC,SAAS;AAAA,MAAA,CACV;AACD,WAAK,SAAS,SAAS,SAAS;AAChC,WAAK,kBAAkB,GAAG;AAC1B,qBAAe,GAAG,aAAa,UAAU,GAAG;AAC5C,kBAAY,KAAK,YAAY,GAAG;AAChC,kBAAY,KAAK,YAAY,KAAK,UAAU,GAAG,GAAG;AAElD,iBAAW,KAAK,QAAQ,EAAE;AAE1B,iBAAW,UAAU,GAAG;AAAA,IAC1B;AAEA,QAAI,SAAS;AACX,mBAAa,UAAU,OAAO,IAAI,aAAa,SAAS,eAAe,IAAI;AAC3E,2BAAqB,cAAc,kBAAkB,IAAI,UAAU,WAAW,YAAY,CAAC;AAC3F,yBAAmB,cAAc,gBAAgB,IAAI,UAAU,WAAW,YAAY,GAAG,kBAAkB;AAC3G,eAAS,mBAAmB,WAAW,UAAU,GAAG,EAAE;AAEtD,UAAI,UAAU,WAAW,cAAc,UAAU,SAAS,KAAK,QAAQ;AAEvE,oBAAc,KAAK,cAAc,cAAc,SAAS,IAAI,SAAS,WAAW,YAAY,QAAQ,GAAG,kBAAkB;AACzH,kBAAY,KAAK,YAAY,cAAc,OAAO,IAAI,SAAS,WAAW,YAAY,QAAQ,GAAG,kBAAkB;AACnH,6BAAuB,iBAAiB,KAAK,YAAY,CAAC,aAAa,SAAS,GAAG,UAAU,GAAG,GAAG;AAEnG,UAAI,CAAC,oBAAoB,EAAE,SAAS,UAAU,cAAc,UAAU,cAAc,MAAM,OAAO;AAC/F,0BAAkB,aAAa,QAAQ,QAAQ;AAE/C,aAAK,IAAI,CAAC,oBAAoB,gBAAgB,GAAG;AAAA,UAC/C,SAAS;AAAA,QAAA,CACV;AACD,4BAAoB,KAAK,YAAY,oBAAoB,UAAU,GAAG,GAAG;AACzE,0BAAkB,KAAK,YAAY,kBAAkB,UAAU,GAAG,GAAG;AAAA,MACvE;AAAA,IACF;AAEA,QAAI,oBAAoB;AACtB,UAAI,cAAc,mBAAmB,KAAK,UACtC,YAAY,mBAAmB,KAAK;AACxC,yBAAmB,cAAc,YAAY,WAAY;AACvD,aAAK,OAAO,GAAG,GAAG,CAAC;AACnB,uBAAe,YAAY,MAAM,oBAAoB,aAAa,CAAA,CAAE;AAAA,MACtE,CAAC;AAAA,IACH;AAEA,SAAK,WAAW,WAAY;AAC1B,aAAO,UAAU,UAAU,QAAQ,IAAI,IAAI,CAAC;AAAA,IAC9C;AAEA,SAAK,OAAO,WAAY;AACtB,aAAO,UAAU,UAAU,QAAQ,IAAI,IAAI,CAAC;AAAA,IAC9C;AAEA,SAAK,SAAS,SAAU,QAAQ,MAAM;AACpC,UAAI,CAAC,MAAM;AACT,eAAO,KAAK,KAAK,IAAI;AAAA,MACvB;AAGA,UAAI,IAAI,WAAW,SAAS,CAAC,KAAK,SAC9B,iBAAiB;AAErB,UAAI,MAAM,KAAK,YAAY;AACzB,YAAI,GAAG;AACL,uBAAa,KAAK,IAAI,WAAA,GAAc,KAAK,OAAO,OAAO,CAAC;AAExD,yBAAe,KAAK;AACpB,6BAAmB,aAAa,UAAU,SAAA;AAAA,QAC5C;AAEA,uBAAe,CAAC,aAAa,WAAW,oBAAoB,gBAAgB,EAAE,QAAQ,SAAU,GAAG;AACjG,iBAAO,EAAE,MAAM,UAAU,IAAI,SAAS;AAAA,QACxC,CAAC;AAED,YAAI,GAAG;AACL,wBAAc;AACd,eAAK,OAAO,CAAC;AAAA,QACf;AAEA,YAAI,QAAQ,CAAC,eAAe,CAAC,KAAK,WAAW;AAC3C,cAAI,GAAG;AACL,wBAAY,KAAK,QAAQ,gBAAgB;AAAA,UAC3C,OAAO;AACL,uBAAW,KAAK,QAAQ,kBAAkB,GAAG,GAAG,WAAW;AAAA,UAC7D;AAAA,QACF;AAEA,aAAK,KAAK,OAAO,CAAC;AAElB,sBAAc;AAEd,aAAK,aAAa;AAAA,MACpB;AAAA,IACF;AAEA,SAAK,UAAU,SAAU,MAAM,OAAO,UAAU,WAAW;AAEzD,WAAK,eAAe,CAAC,KAAK,YAAY,CAAC,OAAO;AAC5C;AAAA,MACF;AAEA,UAAI,OAAO,QAAQ,iBAAiB;AAClC,qBAAaA,gBAAe,aAAa,YAAY;AAErD;AAAA,MACF;AAEA,OAAC,kBAAkB,iBAAiB,cAAc,IAAI;AACtD,oBAAc;AAEd,UAAI,QAAQ,SAAS,CAAC,UAAU;AAE9B,gBAAQ,MAAM,KAAA;AACd,gBAAQ,QAAQ;AAAA,MAClB;AAEA,oBAAc,WAAW,MAAA;AAEzB,UAAI,uBAAuB,WAAW;AACpC,kBAAU,OAAO;AAAA,UACf,MAAM;AAAA,QAAA,CACP,EAAE,WAAA;AACH,kBAAU,eAAe,UAAU,YAAY,MAAM,MAAM,KAAK,EAAE,QAAQ,SAAU,GAAG;AACrF,iBAAO,EAAE,KAAK,mBAAmB,EAAE,OAAO,GAAG,MAAM,IAAI;AAAA,QACzD,CAAC;AAAA,MACH;AAEA,WAAK,cAAc,KAAK,OAAO,MAAM,IAAI;AACzC,WAAK,gBAAgB;AAErB,UAAI,OAAO,gBAAA,GACP,iBAAiB,mBAAA,GACjB,MAAM,qBAAqB,mBAAmB,aAAa,WAAW,UAAU,SAAS,GACzF,iBAAiB,UAAU,QAAQ,CAAC,QACpCsG,UAAS,GACT,iBAAiB,aAAa,GAC9B,YAAY,UAAU,QAAQ,IAAI,SAAS,MAAM,KAAK,KACtD,mBAAmB,KAAK,cAAc,SACtC,cAAc,UAAU,QAAQ,IAAI,SAAS,QAAQ,KAAK,UAAU,KAAK,UAAU,KAAK,CAAC,UAAU,IAAI,MAAM,QAAQ,WACrH,kBAAkB,KAAK,kBAAkB,KAAK,mBAAmB,WAAW,KAAK,iBAAiB,IAAI,GACtG,eAAe,WAAW,KAAK,IAAI,GAAG,UAAU,QAAQ,IAAI,CAAC,KAAK,GAClE,IAAI,cACJC,KACA,QACA,QACA,YACA,UACA,YACA,QACA,gBACA,SACA,cACA,gBACA,mBACA;AAEJ,UAAI,WAAW,UAAU,QAAQ,GAAG;AAElC,4BAAoB,KAAK,YAAY,oBAAoB,UAAU,CAAC;AACpE,0BAAkB,KAAK,YAAY,kBAAkB,UAAU,CAAC;AAAA,MAClE;AAEA,aAAO,MAAM,GAAG;AAEd,qBAAa,UAAU,CAAC;AACxB,mBAAW,OAAO,WAAW,QAAQ,GAAG,CAAC,MAAM,cAAc;AAE7D,iBAAS,WAAW;AAEpB,YAAI,WAAW,WAAW,WAAW,WAAW,OAAO,WAAW,oBAAoB,CAAC,WAAW,YAAY;AAC5G,2BAAiB,eAAe;AAChC,uBAAa,QAAQ,UAAU;AAE/B,qBAAW,OAAO,MAAM,IAAI;AAAA,QAC9B;AAEA,YAAI,eAAe,UAAU,CAAC,GAAG;AAE/B;AACA;AAAA,QACF;AAAA,MACF;AAEA,kBAAY,WAAW,MAAM,cAAc,YAAY,IAAI;AAC3D,oBAAc,YAAY,aAAa,SAAS,IAAI;AACpD,cAAQ,eAAe,aAAa,SAAS,MAAM,WAAW,WAAA,GAAc,aAAa,oBAAoB,MAAM,gBAAgB,aAAa,kBAAkB,KAAK,oBAAoB,KAAK,eAAe,aAAa,MAAM,MAAM,QAAS;AACjP,kBAAY,SAAS,MAAM,YAAY,UAAU,IAAI;AAErD,UAAI,UAAU,SAAS,KAAK,CAAC,UAAU,QAAQ,IAAI,GAAG;AACpD,YAAI,CAAC,UAAU,QAAQ,GAAG,GAAG;AAC3B,uBAAa,UAAU,WAAW,IAAI,YAAY,MAAM,GAAG,EAAE,CAAC,IAAI,MAAM;AAAA,QAC1E,OAAO;AACLD,oBAAS,YAAY,UAAU,OAAO,CAAC,GAAG,IAAI;AAC9C,sBAAY,UAAU,WAAW,IAAI,eAAe,qBAAqB,KAAK,MAAM,SAAS,GAAG,mBAAmB,YAAY,mBAAmB,cAAc,OAAO,mBAAmB,cAAc,KAAK,KAAK,IAAI,SAASA;AAE/N,6BAAmB;AAAA,QACrB;AAAA,MACF;AAEA,kBAAY,YAAY,WAAW,OAAO,IAAI;AAC9C,YAAM,KAAK,IAAI,OAAO,eAAe,cAAc,mBAAmB,WAAW,MAAM,kBAAkB,MAAM,WAAW,WAAA,IAAeA,SAAQ,WAAW,kBAAkB,MAAM,gBAAgB,aAAa,kBAAkB,KAAK,oBAAoB,KAAK,aAAa,WAAW,CAAC,KAAK;AAC/RA,gBAAS;AACT,UAAI;AAEJ,aAAO,KAAK;AACV,qBAAa,UAAU,CAAC;AACxB,iBAAS,WAAW;AAEpB,YAAI,UAAU,WAAW,QAAQ,WAAW,YAAY,SAAS,CAAC,sBAAsB,WAAW,MAAM,GAAG;AAC1GC,gBAAK,WAAW,OAAO,KAAK,cAAc,KAAK,IAAI,GAAG,WAAW,KAAK,IAAI,WAAW;AAErF,eAAK,WAAW,WAAW,WAAW,QAAQ,WAAW,WAAW,SAAS,WAAW,oBAAoB,MAAM,WAAW,GAAG;AAE9HD,uBAAUC,OAAM,IAAI,WAAW;AAAA,UACjC;AAEA,qBAAW,QAAQ,kBAAkBA;AAAAA,QACvC;AAAA,MACF;AAEA,eAASD;AACT,aAAOA;AACP,WAAK,gBAAgB,KAAK,eAAeA;AAEzC,UAAI,KAAK,aAAa,CAAC,gBAAgB;AACrC,aAAK,YAAY,OAAO;AACxB,cAAM,KAAK,IAAI,KAAK,WAAW,UAAU,SAAS,CAAC;AAAA,MACrD;AAEA,eAAS,MAAM,UAAU,SAAS,SAAS;AAE3C,UAAI,gBAAgB;AAElB,uBAAe,KAAK,MAAM,MAAM,GAAG,GAAG,KAAK,MAAM,UAAU,OAAO,KAAK,UAAU,CAAC;AAAA,MACpF;AAEA,WAAK,WAAW;AAEhB,UAAI,eAAeA,SAAQ;AAEzBC,cAAK,CAAA;AACLA,YAAG,UAAU,CAAC,IAAI,OAAOD;AACzB,4BAAoBC,IAAG,UAAU,CAAC,IAAI,OAAO;AAC7C,aAAK,IAAI,CAAC,aAAa,SAAS,GAAGA,GAAE;AAAA,MACvC;AAEA,UAAI,OAAO,EAAE,gBAAgB,KAAK,OAAO,WAAW,UAAU,SAAS,IAAI;AACzEA,cAAK,kBAAkB,GAAG;AAC1B,qBAAa,cAAc;AAC3B,iBAAS,WAAA;AAET,mBAAW,WAAW,UAAU,UAAU,CAAC,CAAC,IAAI;AAEhD,YAAI,CAAC,OAAO,MAAM,GAAG;AAEnB,4BAAkB,aAAa,KAAK,oBAAoB,SAAS,UAAU;AAC3E,2BAAiB;AAAA,YACf,OAAO;AAAA,YACP,OAAO,eAAe,aAAa,UAAU,EAAE,aAAa;AAAA,UAAA;AAG9D,cAAI,cAAc,kBAAkB,KAAK,EAAE,aAAa,UAAU,EAAE,aAAa,MAAM,UAAU;AAE/F,2BAAe,MAAM,aAAa,UAAU,EAAE,YAAA,CAAa,IAAI;AAAA,UACjE;AAAA,QACF;AAEA,mBAAW,KAAK,QAAQA,GAAE;AAE1B,mBAAW,UAAU,GAAG;AAExB,iBAAS,WAAW,KAAK,IAAI;AAC7B,yBAAiB,oBAAoB,eAAe,UAAU,aAAa,cAAc,SAAS,EAAA;AAElG,YAAI,YAAY;AACd,wBAAc,CAAC,aAAa,UAAU,KAAK,SAAS,iBAAiB,GAAG;AACxE,sBAAY,IAAI;AAChB,cAAI,eAAe,WAAW,SAAS,KAAK,SAAS,IAAI,SAAS,iBAAiB;AAEnF,cAAI,GAAG;AACL,wBAAY,KAAK,UAAU,GAAG,IAAI,GAAG;AAErC,mBAAO,MAAM,cAAc,WAAW,OAAO,MAAM,YAAY,IAAI;AAAA,UACrE;AAEA,oBAAU,WAAW;AAErB,cAAI,iBAAiB;AAEnB,sBAAU,QAAQ,SAAU,GAAG;AAC7B,kBAAI,EAAE,QAAQ,mBAAmB,EAAE,KAAK,eAAe,OAAO;AAC5D,kBAAE,gBAAgB;AAAA,cACpB;AAAA,YACF,CAAC;AAAA,UACH;AAEA,8BAAoB,WAAW,UAAU;AAAA,QAC3C,OAAO;AACL,cAAI,SAAS,KAAK,SAAS;AAC3B,eAAK,OAAO,MAAM,cAAc,WAAW,OAAO,MAAM,YAAY,IAAI;AAAA,QAC1E;AAEA,YAAI,kBAAkB;AACpB,qBAAW;AAAA,YACT,KAAK,OAAO,OAAO,aAAa,SAAS,QAAQ,kBAAkB;AAAA,YACnE,MAAM,OAAO,QAAQ,aAAa,iBAAiB,SAAS,SAAS;AAAA,YACrE,WAAW;AAAA,YACX,UAAU;AAAA,UAAA;AAEZ,mBAAS,MAAM,IAAI,SAAS,QAAQ,MAAM,IAAI,KAAK,KAAK,OAAO,KAAK,IAAI;AACxE,mBAAS,OAAO,IAAI,SAAS,QAAQ,OAAO,IAAI,KAAK,KAAK,OAAO,MAAM,IAAI;AAC3E,mBAAS,OAAO,IAAI,SAAS,UAAU,IAAI,IAAI,SAAS,UAAU,MAAM,IAAI,SAAS,UAAU,OAAO,IAAI,SAAS,UAAU,KAAK,IAAI;AACtI,mBAAS,QAAQ,IAAIA,IAAG,QAAQ;AAChC,mBAAS,WAAW,IAAI,IAAIA,IAAG,WAAW,IAAI;AAC9C,mBAAS,WAAW,MAAM,IAAIA,IAAG,WAAW,MAAM;AAClD,mBAAS,WAAW,OAAO,IAAIA,IAAG,WAAW,OAAO;AACpD,mBAAS,WAAW,KAAK,IAAIA,IAAG,WAAW,KAAK;AAChD,2BAAiB,WAAW,kBAAkB,UAAU,WAAW;AACnE,4BAAkB,WAAW,CAAC;AAAA,QAChC;AAEA,YAAI,WAAW;AAEb,oBAAU,UAAU;AAEpB,8BAAoB,CAAC;AAErB,oBAAU,OAAO,UAAU,SAAA,GAAY,MAAM,IAAI;AACjD,sBAAY,UAAU,UAAU,CAAC,IAAI,WAAW,SAAS;AACzD,qBAAW,KAAK,IAAI,SAAS,SAAS,IAAI;AAC1C,8BAAoB,YAAY,eAAe,OAAO,eAAe,SAAS,GAAG,CAAC;AAElF,oBAAU,OAAO,GAAG,MAAM,IAAI;AAC9B,qBAAW,UAAU,WAAW,IAAI;AACpC,oBAAU,UAAU,UAAU,UAAU,UAAU,WAAW;AAE7D,8BAAoB,CAAC;AAAA,QACvB,OAAO;AACL,sBAAY;AAAA,QACd;AAEA,2BAAmB,eAAe,QAAQ,eAAe,MAAM,aAAa,UAAU,EAAE,YAAA,CAAa,IAAI,eAAe,QAAQ,eAAe,MAAM,eAAe,cAAc,UAAU,CAAC;AAAA,MAC/L,WAAW,WAAW,WAAA,KAAgB,CAAC,oBAAoB;AAEzD,iBAAS,QAAQ;AAEjB,eAAO,UAAU,WAAW,OAAO;AACjC,cAAI,OAAO,YAAY;AACrB,qBAAS,OAAO;AAChB,mBAAO,OAAO;AAAA,UAChB;AAEA,mBAAS,OAAO;AAAA,QAClB;AAAA,MACF;AAEA,sBAAgB,aAAa,QAAQ,SAAU,GAAG;AAChD,eAAO,EAAE,OAAO,OAAO,IAAI;AAAA,MAC7B,CAAC;AACD,WAAK,QAAQ;AACb,WAAK,MAAM;AACX,gBAAU,UAAU,iBAAiB,aAAa,WAAA;AAElD,UAAI,CAAC,sBAAsB,CAAC,gBAAgB;AAC1C,kBAAU,cAAc,WAAW,UAAU;AAC7C,aAAK,OAAO,MAAM;AAAA,MACpB;AAEA,WAAK,OAAO,OAAO,IAAI;AACvB,oBAAc,SAAA;AAEd,UAAI,iBAAiB;AACnB,mBAAW;AAGX,wBAAgB,QAAQ,IAAI;AAAA,MAC9B;AAEA,oBAAc;AACd,mBAAa,aAAa,UAAU,YAAY,qBAAqB,UAAU,SAAA,MAAe,oBAAoB,UAAU,SAAS,oBAAoB,GAAG,IAAI,EAAE,OAAO,UAAU,KAAA,GAAQ,MAAM,IAAI;AAErM,UAAI,kBAAkB,iBAAiB,KAAK,YAAY,sBAAsB,uBAAuB,aAAa,CAAC,UAAU,UAAU;AAErI,qBAAa,CAAC,aAAa,UAAU,YAAY,gBAAgB,UAAU,KAAK,oBAAoB,UAAU,UAAU,cAAc,sBAAsB,QAAQ,SAAU,CAAC,eAAe,KAAK,MAAM,UAAU,OAAO,KAAK,CAAC,IAAI,cAAc,IAAI;AAEtP,aAAK,WAAW,mBAAmB,UAAU,SAAS,WAAW,eAAe,IAAI;AAAA,MACtF;AAEA,aAAO,eAAe,OAAO,aAAa,KAAK,MAAM,KAAK,WAAW,SAAS;AAC9E,oBAAc,WAAW,WAAA;AAEzB,UAAI,CAAC,MAAM,iBAAiB,GAAG;AAE7B,6BAAqB,KAAK,YAAY,oBAAoB,UAAU,CAAC;AACrE,2BAAmB,KAAK,YAAY,kBAAkB,UAAU,CAAC;AAEjE,qBAAa,oBAAoB,WAAW,iBAAiB;AAE7D,qBAAa,aAAa,WAAW,qBAAqB,aAAa,EAAE;AAEzE,qBAAa,kBAAkB,WAAW,eAAe;AAEzD,qBAAa,WAAW,WAAW,mBAAmB,aAAa,EAAE;AAAA,MACvE;AAEA,wBAAkB,CAAC,kBAAkB,KAAK,OAAA;AAE1C,UAAI,aAAa,CAAC,kBAAkB,CAAC,oBAAoB;AAEvD,6BAAqB;AACrB,kBAAU,IAAI;AACd,6BAAqB;AAAA,MACvB;AAAA,IACF;AAEA,SAAK,cAAc,WAAY;AAC7B,cAAQ,eAAe,YAAY,SAAA,IAAa,UAAU,OAAQ;AAAA,IACpE;AAEA,SAAK,eAAe,WAAY;AAC9B,oBAAc,KAAK,iBAAiB;AAEpC,UAAI,WAAW;AACb,qBAAa,WAAW,SAAS,CAAC,IAAI,CAAC,UAAU,WAAW,cAAc,WAAW,UAAU,SAAA,CAAU,IAAI,YAAY,cAAc,WAAW,KAAK,YAAY,GAAG,CAAC;AAAA,MACzK;AAAA,IACF;AAEA,SAAK,gBAAgB,SAAU,OAAO;AACpC,aAAO,aAAa,UAAU,WAAW,SAAS,KAAK,QAAA,KAAa,SAAS,UAAU,OAAO,KAAK,IAAI,UAAU,SAAA,IAAa,UAAU;AAAA,IAC1I;AAEA,SAAK,cAAc,SAAU,MAAM;AACjC,UAAI,IAAI,UAAU,QAAQ,IAAI,GAC1B,IAAI,KAAK,YAAY,IAAI,UAAU,MAAM,GAAG,CAAC,EAAE,QAAA,IAAY,UAAU,MAAM,IAAI,CAAC;AAEpF,cAAQ,UAAU,IAAI,IAAI,EAAE,OAAO,SAAU,GAAG;AAC9C,eAAO,EAAE,KAAK,oBAAoB;AAAA,MACpC,CAAC,IAAI,GAAG,OAAO,SAAU,GAAG;AAC1B,eAAO,KAAK,YAAY,IAAI,EAAE,OAAO,QAAQ,EAAE,SAAS;AAAA,MAC1D,CAAC;AAAA,IACH;AAEA,SAAK,SAAS,SAAU,OAAO,gBAAgB,WAAW;AACxD,UAAI,sBAAsB,CAAC,aAAa,CAAC,OAAO;AAC9C;AAAA,MACF;AAEA,UAAI,SAAS,mBAAmB,OAAO,aAAa,KAAK,UACrD,IAAI,QAAQ,KAAK,SAAS,SAAS,QACnC,UAAU,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,GACvCC,gBAAe,KAAK,UACpB,UACA,WACA,aACA,QACA,cACA,SACA,SACA;AAEJ,UAAI,gBAAgB;AAClB,kBAAU;AACV,kBAAU,qBAAqB,eAAe;AAE9C,YAAI,MAAM;AACR,kBAAQ;AACR,kBAAQ,aAAa,CAAC,WAAW,UAAU,kBAAkB;AAAA,QAC/D;AAAA,MACF;AAGA,UAAI,iBAAiB,OAAO,CAAC,eAAe,CAAC,YAAY,iBAAiB;AACxE,YAAI,CAAC,WAAW,QAAQ,UAAU,SAAS,YAAY,SAAA,IAAa,UAAU,eAAe;AAC3F,oBAAU;AAAA,QACZ,WAAW,YAAY,KAAK,MAAM,UAAU,SAAS,YAAY,SAAA,IAAa,UAAU,eAAe;AACrG,oBAAU;AAAA,QACZ;AAAA,MACF;AAEA,UAAI,YAAYA,iBAAgB,KAAK,SAAS;AAC5C,mBAAW,KAAK,WAAW,CAAC,CAAC,WAAW,UAAU;AAClD,oBAAY,CAAC,CAACA,iBAAgBA,gBAAe;AAC7C,kBAAU,aAAa;AACvB,uBAAe,WAAW,CAAC,CAAC,YAAY,CAAC,CAACA;AAE1C,aAAK,YAAY,UAAUA,gBAAe,IAAI;AAC9C,aAAK,WAAW;AAEhB,YAAI,gBAAgB,CAAC,aAAa;AAChC,wBAAc,WAAW,CAACA,gBAAe,IAAI,YAAY,IAAI,IAAIA,kBAAiB,IAAI,IAAI;AAE1F,cAAI,UAAU;AACZ,qBAAS,CAAC,WAAW,cAAc,cAAc,CAAC,MAAM,UAAU,cAAc,cAAc,CAAC,KAAK,cAAc,WAAW;AAE7H,6BAAiB,cAAc,WAAW,cAAc,WAAW,WAAW,UAAU;AAAA,UAC1F;AAAA,QACF;AAEA,4BAAoB,WAAW,oBAAoB,kBAAkB,SAAS,CAAC,eAAe,YAAY,eAAe,IAAI,gBAAgB,IAAI,IAAI,KAAK,YAAY,eAAe,EAAE,QAAQ,SAAU,GAAG;AAC1M,iBAAO,EAAE,aAAA;AAAA,QACX,CAAC;AAED,YAAI,CAAC,UAAU;AACb,cAAI,cAAc,CAAC,eAAe,CAAC,UAAU;AAC3C,uBAAW,IAAI,QAAQ,WAAW,WAAW,WAAW,SAAS,WAAW,OAAO,WAAW,IAAI,QAAQ,WAAW,MAAM;AAE3H,gBAAI,WAAW,SAAS;AACtB,yBAAW,QAAQ,iBAAiB,SAAS,UAAU,SAAS,UAAU,KAAK;AAAA,YACjF,OAAO;AAEL,yBAAW,KAAK,gBAAgB;AAChC,yBAAW,WAAA,EAAa,QAAA;AAAA,YAC1B;AAAA,UACF,WAAW,WAAW;AACpB,sBAAU,cAAc,SAAS,CAAC,EAAE,gBAAgB,eAAe,OAAO;AAAA,UAC5E;AAAA,QACF;AAEA,YAAI,KAAK;AACP,mBAAS,eAAe,OAAO,MAAM,aAAa,UAAU,GAAG,IAAI;AAEnE,cAAI,CAAC,kBAAkB;AACrB,sBAAU,OAAO,WAAW,YAAY,OAAO,CAAC;AAAA,UAClD,WAAW,cAAc;AACvB,sBAAU,CAAC,SAAS,UAAUA,iBAAgB,MAAM,IAAI,UAAU,SAAS,KAAK,WAAW,UAAU,SAAS;AAE9G,gBAAI,aAAa;AACf,kBAAI,CAAC,UAAU,YAAY,UAAU;AACnC,oBAAI,SAAS,WAAW,KAAK,IAAI,GAC7B,UAAU,SAAS;AAEvB,0BAAU,KAAK,OAAO,OAAO,OAAO,cAAc,YAAY,UAAU,KAAK,KAAK,OAAO,QAAQ,cAAc,YAAY,IAAI,WAAW,GAAG;AAAA,cAC/I,OAAO;AACL,0BAAU,KAAK,MAAM;AAAA,cACvB;AAAA,YACF;AAEA,sBAAU,YAAY,UAAU,iBAAiB,QAAQ;AAEzD,wBAAY,UAAU,KAAK,YAAY,UAAU,YAAY,YAAY,KAAK,CAAC,UAAU,YAAY,EAAE;AAAA,UACzG;AAAA,QACF;AAEA,gBAAQ,CAAC,QAAQ,SAAS,CAAC,eAAe,CAAC,YAAY,gBAAgB,QAAQ,IAAI;AACnF,wBAAgB,WAAW,QAAQ,YAAY,UAAU,KAAK,CAAC,qBAAqB,SAAS,YAAY,OAAO,EAAE,QAAQ,SAAU,IAAI;AACtI,iBAAO,GAAG,UAAU,YAAY,OAAO,QAAQ,QAAQ,EAAE,YAAY,SAAS;AAAA,QAChF,CAAC;AAED,oBAAY,CAAC,YAAY,CAAC,SAAS,SAAS,IAAI;AAEhD,YAAI,gBAAgB,CAAC,aAAa;AAChC,cAAI,UAAU;AACZ,gBAAI,gBAAgB;AAClB,kBAAI,WAAW,YAAY;AACzB,0BAAU,MAAA,EAAQ,cAAc,CAAC;AAAA,cACnC,WAAW,WAAW,SAAS;AAC7B,0BAAU,QAAQ,IAAI,EAAE,MAAA;AAAA,cAC1B,WAAW,WAAW,WAAW;AAC/B,0BAAU,QAAQ,IAAI;AAAA,cACxB,OAAO;AACL,0BAAU,MAAM,EAAA;AAAA,cAClB;AAAA,YACF;AAEA,wBAAY,SAAS,IAAI;AAAA,UAC3B;AAEA,cAAI,WAAW,CAAC,iBAAiB;AAE/B,wBAAY,WAAW,UAAU,MAAM,QAAQ;AAC/C,sBAAU,WAAW,KAAK,UAAU,MAAM,UAAU,WAAW,CAAC;AAChE,qBAAS,YAAY,IAAI,KAAK,KAAK,OAAO,CAAC,IAAI,UAAU,WAAW,IAAI;AAExE,gBAAI,CAAC,SAAS;AAEZ,4BAAc,YAAY,IAAI,IAAI;AAClC,wBAAU,WAAW,KAAK,UAAU,MAAM,UAAU,WAAW,CAAC;AAAA,YAClE;AAAA,UACF;AAEA,cAAI,iBAAiB,CAAC,YAAY,KAAK,IAAI,KAAK,YAAA,CAAa,KAAK,UAAU,aAAa,IAAI,gBAAgB,OAAO;AAClH,0BAAc,KAAK,iBAAiB;AAEpC,yBAAa,WAAW,SAAS,CAAC,IAAI,cAAc,WAAW,WAAW,YAAY,IAAI,CAAC,SAAS,CAAC;AAAA,UACvG;AAAA,QACF,WAAW,YAAY,YAAY,CAAC,aAAa;AAC/C,mBAAS,IAAI;AAAA,QACf;AAAA,MACF;AAGA,UAAI,iBAAiB;AACnB,YAAI,IAAI,qBAAqB,SAAS,mBAAmB,cAAc,mBAAmB,iBAAiB,KAAK;AAChH,0BAAkB,KAAK,mBAAmB,aAAa,IAAI,EAAE;AAC7D,wBAAgB,CAAC;AAAA,MACnB;AAEA,wBAAkB,eAAe,CAAC,SAAS,mBAAmB,cAAc,mBAAmB,iBAAiB,EAAE;AAAA,IACpH;AAEA,SAAK,SAAS,SAAU,OAAO,SAAS;AACtC,UAAI,CAAC,KAAK,SAAS;AACjB,aAAK,UAAU;AAEf,qBAAa,UAAU,UAAU,SAAS;AAE1C,sBAAc,aAAa,UAAU,UAAU,SAAS;AACxD,yBAAiB,aAAaxG,gBAAe,eAAe,aAAa;AAEzE,YAAI,UAAU,OAAO;AACnB,eAAK,WAAW,eAAe;AAC/B,oBAAU,UAAU,WAAW,WAAA;AAAA,QACjC;AAEA,oBAAY,SAAS,KAAK,QAAA;AAAA,MAC5B;AAAA,IACF;AAEA,SAAK,WAAW,SAAUyG,OAAM;AAC9B,aAAOA,SAAQ,UAAU,QAAQ,QAAQ;AAAA,IAC3C;AAEA,SAAK,eAAe,SAAU,UAAU,QAAQ,WAAW,WAAW;AAEpE,UAAI,oBAAoB;AAEtB,YAAI,KAAK,mBAAmB,eACxB,WAAW,mBAAmB,YAC9B,UAAU,GAAG,MAAM,GAAG;AAE1B,mBAAW,GAAG,QAAQ,UAAU,WAAW;AAC3C,iBAAS,GAAG,QAAQ,UAAU,SAAS;AAAA,MACzC;AAEA,WAAK,QAAQ,OAAO,OAAO;AAAA,QACzB,OAAO,WAAW,UAAU,aAAa,CAAC,CAAC,KAAK,WAAW;AAAA,QAC3D,KAAK,WAAW,QAAQ,aAAa,CAAC,CAAC,KAAK,SAAS;AAAA,MAAA,GACpD,SAAS;AACZ,WAAK,OAAA;AAAA,IACP;AAEA,SAAK,mBAAmB,SAAU,QAAQ;AACxC,UAAI,eAAe,QAAQ;AACzB,YAAI,IAAI,YAAY,QAAQ,UAAU,CAAC,IAAI;AAC3C,oBAAY,CAAC,IAAI,WAAW,YAAY,CAAC,CAAC,IAAI,SAAS;AACvD,oBAAY,CAAC,IAAI,WAAW,YAAY,CAAC,CAAC,IAAI,SAAS;AAEvD,kBAAU,WAAW;AAAA,MACvB;AAAA,IACF;AAEA,SAAK,UAAU,SAAU,OAAO,gBAAgB;AAC9C,UAAI,KAAK,SAAS;AAChB,kBAAU,SAAS,KAAK,OAAO,MAAM,IAAI;AACzC,aAAK,UAAU,KAAK,WAAW;AAC/B,0BAAkB,cAAc,WAAW,MAAA;AAC3C,qBAAa;AACb,qBAAa,SAAS,UAAU;AAChC,yBAAiB,gBAAgBzG,gBAAe,eAAe,aAAa;AAE5E,YAAI,iBAAiB;AACnB,0BAAgB,MAAA;AAChB,kBAAQ,SAAS,QAAQ,MAAM,KAAA,MAAW,QAAQ,QAAQ;AAAA,QAC5D;AAEA,YAAI,CAAC,YAAY;AACf,cAAI,IAAI,UAAU;AAElB,iBAAO,KAAK;AACV,gBAAI,UAAU,CAAC,EAAE,aAAa,YAAY,UAAU,CAAC,MAAM,MAAM;AAC/D;AAAA,YACF;AAAA,UACF;AAEA,0BAAgB,UAAU,UAAU,SAAS;AAE7C,wBAAc,gBAAgB,UAAU,UAAU,SAAS;AAAA,QAC7D;AAAA,MACF;AAAA,IACF;AAEA,SAAK,OAAO,SAAU,QAAQ,gBAAgB;AAC5C,WAAK,QAAQ,QAAQ,cAAc;AACnC,oBAAc,CAAC,kBAAkB,WAAW,KAAA;AAC5C,YAAM,OAAO,KAAK,EAAE;AAEpB,UAAI,IAAI,UAAU,QAAQ,IAAI;AAE9B,WAAK,KAAK,UAAU,OAAO,GAAG,CAAC;AAC/B,YAAM,MAAM,aAAa,KAAK;AAG9B,UAAI;AAEJ,gBAAU,QAAQ,SAAU,GAAG;AAC7B,eAAO,EAAE,aAAa,KAAK,aAAa,IAAI;AAAA,MAC9C,CAAC;AAED,WAAK,mBAAmB,KAAK,OAAO,MAAM;AAE1C,UAAI,WAAW;AACb,kBAAU,gBAAgB;AAC1B,kBAAU,UAAU,OAAO;AAAA,UACzB,MAAM;AAAA,QAAA,CACP;AACD,0BAAkB,UAAU,KAAA;AAAA,MAC9B;AAEA,qBAAe,CAAC,aAAa,WAAW,oBAAoB,gBAAgB,EAAE,QAAQ,SAAU,GAAG;AACjG,eAAO,EAAE,cAAc,EAAE,WAAW,YAAY,CAAC;AAAA,MACnD,CAAC;AACD,mBAAa,SAAS,WAAW;AAEjC,UAAI,KAAK;AACP,qBAAa,SAAS,UAAU;AAChC,YAAI;AAEJ,kBAAU,QAAQ,SAAU,GAAG;AAC7B,iBAAO,EAAE,QAAQ,OAAO;AAAA,QAC1B,CAAC;AAED,cAAM,SAAS,SAAS;AAAA,MAC1B;AAEA,WAAK,UAAU,KAAK,OAAO,IAAI;AAAA,IACjC;AAEA,cAAU,KAAK,IAAI;AAEnB,SAAK,OAAO,OAAO,KAAK;AACxB,0BAAsB,mBAAmB,IAAI;AAE7C,QAAI,aAAa,UAAU,OAAO,CAAC,QAAQ;AAEzC,UAAI,aAAa,KAAK;AAEtB,WAAK,SAAS,WAAY;AACxB,aAAK,SAAS;AACd,mBAAW;AAEX,iBAAS,OAAO,KAAK,QAAA;AAAA,MACvB;AAEA,WAAK,YAAY,MAAM,KAAK,MAAM;AAClC,eAAS;AACT,cAAQ,MAAM;AAAA,IAChB,OAAO;AACL,WAAK,QAAA;AAAA,IACP;AAEA,WAAO,iBAAA;AAAA,EACT;AAEAA,iBAAc,WAAW,SAAS,SAAS,MAAM;AAC/C,QAAI,CAAC,cAAc;AACjB,aAAO,QAAQ,SAAA;AAEf,qBAAe;AAAA,IACjB;AAEA,WAAO;AAAA,EACT;AAEAA,iBAAc,WAAW,SAAS,SAAS,QAAQ;AACjD,QAAI,QAAQ;AACV,eAAS,KAAK,QAAQ;AACpB,kBAAU,CAAC,IAAI,OAAO,CAAC;AAAA,MACzB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEAA,iBAAc,UAAU,SAAS,QAAQ,OAAO,MAAM;AACpD,eAAW;AAEX,cAAU,QAAQ,SAAU,SAAS;AACnC,aAAO,QAAQ,OAAO,SAAS,SAAS,EAAE,KAAK;AAAA,IACjD,CAAC;AAED,oBAAgB,MAAM,SAAS,SAAS;AAExC,oBAAgB,MAAM,UAAU,SAAS;AAEzC,kBAAc,aAAa;AAE3B,oBAAgB,MAAM,eAAe,YAAY;AAEjD,oBAAgB,OAAO,cAAc,YAAY;AAEjD,mBAAe,iBAAiB,MAAM,oCAAoC,mBAAmB;AAE7F,mBAAe,iBAAiB,MAAM,8BAA8B,iBAAiB;AAErF,iBAAa,KAAA;AAEb,wBAAoB,eAAe;AAEnC,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK,GAAG;AAC7C,qBAAe,iBAAiB,WAAW,CAAC,GAAG,WAAW,IAAI,CAAC,CAAC;AAEhE,qBAAe,iBAAiB,WAAW,CAAC,GAAG,WAAW,IAAI,CAAC,CAAC;AAAA,IAClE;AAAA,EACF;AAEAA,iBAAc,SAAS,SAAS,SAAS;AACvC,WAAO;AACP,WAAO;AACP,aAAS,KAAK;AACd,YAAQ,KAAK;AAEb,QAAI,MAAM;AACR,iBAAW,KAAK,MAAM;AACtB,eAAS,KAAK,MAAM;AACpB,iBAAW,KAAK,KAAK,WAAW;AAChC,4BAAsB,KAAK,KAAK,sBAAsB;AACtD,2BAAqB,KAAK,QAAQ,qBAAqB;AACvD,oBAAc,KAAK,eAAe;AAClC,WAAK,KAAK,QAAQ,iBAAiBA,cAAa;AAEhD,UAAI,OAAO;AACT,mBAAW;AACX,oBAAY,SAAS,cAAc,KAAK;AAExC,kBAAU,MAAM,SAAS;AACzB,kBAAU,MAAM,WAAW;AAE3B,sBAAA;AAEA,mBAAA;AAEA,iBAAS,SAAS,IAAI;AAEtBA,uBAAc,UAAU,SAAS;AACjC,qBAAa,SAAS,WAAW,0BAA0B,cAAe,SAAS;AAEnF,8BAAsB,SAAS,YAAY;AAE3C,qBAAa,MAAM,SAAS,SAAS;AAGrC,gBAAQ,CAAC,MAAM,MAAM,QAAQ,KAAK;AAElC,YAAI,KAAK,YAAY;AACnBA,yBAAc,aAAa,SAAU,MAAM;AACzC,gBAAI,KAAK,KAAK,WAAA,GACV;AAEJ,iBAAK,KAAK,MAAM;AACd,iBAAG,IAAI,GAAG,KAAK,CAAC,CAAC;AAAA,YACnB;AAEA,mBAAO;AAAA,UACT;AAEA,eAAK,iBAAiB,kBAAkB,WAAY;AAClD,mBAAO,WAAA;AAAA,UACT,CAAC;AACD,eAAK,iBAAiB,oBAAoB,WAAY;AACpD,mBAAO,gBAAA;AAAA,UACT,CAAC;AACD,eAAK,iBAAiB,cAAc,WAAY;AAC9C,wBAAY,GAAG,CAAC;AAEhB,sBAAU,YAAY;AAAA,UACxB,CAAC;AACD,eAAK,WAAA,EAAa,IAAI,2BAA2B,WAAY;AAE3D,+BAAA;AAEA,mBAAO;AAAA,UACT,CAAC;AAAA,QACH,OAAO;AACL,kBAAQ,KAAK,+BAA+B;AAAA,QAC9C;AAEA,2BAAA;AAEA,qBAAa,MAAM,UAAU,SAAS;AAGtC,YAAI,eAAe,MAAM,aAAa,OAAO,GACzC,YAAY,MAAM,OAClB,SAAS,UAAU,gBACnB,iBAAiB,KAAK,KAAK,UAAU,WACrC,QACA;AAEJ,uBAAe,UAAU,OAAO,eAAe,gBAAgB,UAAU;AAAA,UACvE,OAAO,SAAS,QAAQ;AACtB,mBAAO,KAAK,KAAK,OAAO,IAAI;AAAA,UAC9B;AAAA,QAAA,CACD;AAED,kBAAU,iBAAiB;AAE3B,iBAAS,WAAW,KAAK;AACzB,kBAAU,IAAI,KAAK,MAAM,OAAO,MAAM,UAAU,GAAA,CAAI,KAAK;AAEzD,oBAAY,IAAI,KAAK,MAAM,OAAO,OAAO,YAAY,GAAA,CAAI,KAAK;AAC9D,iBAAS,UAAU,iBAAiB,SAAS,UAAU,eAAe,kBAAkB;AAExF,YAAI,CAAC,cAAc;AAEjB,gBAAM,aAAa,SAAS,EAAE;AAG9B,gBAAM,gBAAgB,OAAO;AAAA,QAC/B;AAGA,wBAAgB,YAAY,OAAO,GAAG;AACtC,aAAK,YAAY,KAAK,WAAY;AAChC,iBAAO,WAAW;AAAA,QACpB,CAAC;AAED,qBAAa,MAAM,eAAe,YAAY;AAG9C,qBAAa,OAAO,cAAc,YAAY;AAG9C,uBAAe,cAAc,MAAM,oCAAoC,mBAAmB;AAE1F,uBAAe,cAAc,MAAM,8BAA8B,iBAAiB;AAElF,yBAAiB,KAAK,MAAM,YAAY,WAAW;AAEnD,oBAAY,KAAK,cAAc;AAE/B,uBAAe,SAAA;AACf,uBAAe,KAAK,YAAY,KAAK,WAAW,EAAE,MAAA;AAClD,uBAAe,CAAC,MAAM,oBAAoB,WAAY;AACpD,cAAI,IAAI,KAAK,YACT0G,KAAI,KAAK;AAEb,cAAI,KAAK,QAAQ;AACf,yBAAa;AACb,0BAAcA;AAAA,UAChB,WAAW,eAAe,KAAK,gBAAgBA,IAAG;AAChD,sBAAA;AAAA,UACF;AAAA,QACF,GAAG,MAAM,oBAAoB,aAAa,MAAM,QAAQ,aAAa,MAAM,UAAU,SAAS;AAE9F,4BAAoB,YAAY;AAEhC,kBAAU,QAAQ,SAAU,SAAS;AACnC,iBAAO,QAAQ,OAAO,GAAG,CAAC;AAAA,QAC5B,CAAC;AAED,aAAK,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK,GAAG;AACzC,yBAAe,iBAAiB,WAAW,CAAC,GAAG,WAAW,IAAI,CAAC,CAAC;AAEhE,yBAAe,iBAAiB,WAAW,CAAC,GAAG,WAAW,IAAI,CAAC,CAAC;AAAA,QAClE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA1G,iBAAc,SAAS,SAAS,OAAO,MAAM;AAC3C,wBAAoB,SAAS,kBAAkB,CAAC,CAAC,KAAK;AACtD,QAAI,KAAK,KAAK;AACd,UAAM,cAAc,aAAa,MAAM,gBAAgB,OAAO,YAAY,OAAO,EAAE;AACnF,4BAAwB,SAAS,sBAAsBA,eAAc,YAAY,KAAK,KAAK;AAE3F,QAAI,uBAAuB,MAAM;AAC/B,0BAAoB,eAAe,KAAK,oBAAoB,cAAc,KAAK,qBAAqB,MAAM;AAC1G,uBAAiB,KAAK,oBAAoB,IAAI,QAAQ,QAAQ,MAAM;AAAA,IACtE;AAAA,EACF;AAEAA,iBAAc,gBAAgB,SAAS,cAAc,QAAQ,MAAM;AACjE,QAAI,IAAI,WAAW,MAAM,GACrB,IAAI,WAAW,QAAQ,CAAC,GACxB,aAAa,YAAY,CAAC;AAE9B,QAAI,CAAC,GAAG;AACN,iBAAW,OAAO,GAAG,aAAa,IAAI,CAAC;AAAA,IACzC;AAEA,QAAI,MAAM;AACR,mBAAa,SAAS,QAAQ,MAAM,MAAM,OAAO,MAAM,QAAQ,IAAI,IAAI,SAAS,QAAQ,GAAG,IAAI;AAAA,IACjG;AAAA,EACF;AAEAA,iBAAc,kBAAkB,SAAS,gBAAgB,OAAO;AAC9D,cAAU,QAAQ,SAAU,GAAG;AAC7B,aAAO,EAAE,QAAQ,EAAE,KAAK,UAAU,SAAS,EAAE,KAAK,KAAK,MAAM,IAAI;AAAA,IACnE,CAAC;AAAA,EACH;AAEAA,iBAAc,eAAe,SAAS,aAAa,SAAS,OAAO,YAAY;AAC7E,QAAI,UAAU,UAAU,OAAO,IAAI,WAAW,OAAO,IAAI,SAAS,sBAAA,GAC9D,SAAS,OAAO,aAAa,SAAS,OAAO,IAAI,SAAS;AAC9D,WAAO,aAAa,OAAO,QAAQ,SAAS,KAAK,OAAO,OAAO,SAAS,KAAK,aAAa,OAAO,SAAS,SAAS,KAAK,OAAO,MAAM,SAAS,KAAK;AAAA,EACrJ;AAEAA,iBAAc,qBAAqB,SAAS,mBAAmB,SAAS,gBAAgB,YAAY;AAClG,cAAU,OAAO,MAAM,UAAU,WAAW,OAAO;AACnD,QAAI,SAAS,QAAQ,sBAAA,GACjB,OAAO,OAAO,aAAa,SAAS,OAAO,GAC3C,SAAS,kBAAkB,OAAO,OAAO,IAAI,kBAAkB,YAAY,UAAU,cAAc,IAAI,OAAO,CAAC,eAAe,QAAQ,GAAG,IAAI,WAAW,cAAc,IAAI,OAAO,MAAM,WAAW,cAAc,KAAK;AACzN,WAAO,cAAc,OAAO,OAAO,UAAU,KAAK,cAAc,OAAO,MAAM,UAAU,KAAK;AAAA,EAC9F;AAEAA,iBAAc,UAAU,SAAS,QAAQ,gBAAgB;AACvD,cAAU,MAAM,CAAC,EAAE,QAAQ,SAAU,GAAG;AACtC,aAAO,EAAE,KAAK,OAAO,oBAAoB,EAAE,KAAA;AAAA,IAC7C,CAAC;AAED,QAAI,mBAAmB,MAAM;AAC3B,UAAI,YAAY,WAAW,WAAW,CAAA;AACtC,mBAAa,CAAA;AACb,gBAAU,QAAQ,SAAU,GAAG;AAC7B,eAAO,EAAA;AAAA,MACT,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAOA;AACT,GAAA;AACA,cAAc,UAAU;AAExB,cAAc,aAAa,SAAU,SAAS;AAC5C,SAAO,UAAU,SAAS,OAAO,EAAE,QAAQ,SAAU,QAAQ;AAE3D,QAAI,UAAU,OAAO,OAAO;AAC1B,UAAI,IAAI,aAAa,QAAQ,MAAM;AAEnC,WAAK,KAAK,aAAa,OAAO,GAAG,CAAC;AAElC,mBAAa,KAAK,QAAQ,OAAO,MAAM,SAAS,OAAO,WAAW,OAAO,aAAa,WAAW,GAAG,KAAK,KAAK,SAAS,MAAM,GAAG,UAAU;AAAA,IAC5I;AAAA,EACF,CAAC,IAAI;AACP;AAEA,cAAc,SAAS,SAAU,MAAM,OAAO;AAC5C,SAAO,WAAW,CAAC,MAAM,KAAK;AAChC;AAEA,cAAc,SAAS,SAAU,MAAM,WAAW;AAChD,SAAO,IAAI,cAAc,MAAM,SAAS;AAC1C;AAEA,cAAc,UAAU,SAAU,MAAM;AACtC,SAAO,OAAO,UAAU,IAAI,KAAK,gBAAgB,cAAc,SAAA,MAAe,YAAY,IAAI;AAChG;AAEA,cAAc,SAAS,SAAU,OAAO;AACtC,SAAO,EAAE,WAAW,SAAS,WAAW,UAAU,OAAO,IAAI,CAAC;AAChE;AAEA,cAAc,oBAAoB;AAElC,cAAc,YAAY,SAAU,SAAS,YAAY;AACvD,SAAO,WAAW,SAAS,aAAa,cAAc,SAAS;AACjE;AAEA,cAAc,gBAAgB,SAAU,SAAS,YAAY;AAC3D,SAAO,eAAe,WAAW,OAAO,GAAG,aAAa,cAAc,SAAS;AACjF;AAEA,cAAc,UAAU,SAAU,IAAI;AACpC,SAAO,KAAK,EAAE;AAChB;AAEA,cAAc,SAAS,WAAY;AACjC,SAAO,UAAU,OAAO,SAAU,GAAG;AACnC,WAAO,EAAE,KAAK,OAAO;AAAA,EACvB,CAAC;AACH;AAGA,cAAc,cAAc,WAAY;AACtC,SAAO,CAAC,CAAC;AACX;AAEA,cAAc,kBAAkB;AAEhC,cAAc,mBAAmB,SAAU,MAAM,UAAU;AACzD,MAAI,IAAI,WAAW,IAAI,MAAM,WAAW,IAAI,IAAI;AAChD,GAAC,EAAE,QAAQ,QAAQ,KAAK,EAAE,KAAK,QAAQ;AACzC;AAEA,cAAc,sBAAsB,SAAU,MAAM,UAAU;AAC5D,MAAI,IAAI,WAAW,IAAI,GACnB,IAAI,KAAK,EAAE,QAAQ,QAAQ;AAC/B,OAAK,KAAK,EAAE,OAAO,GAAG,CAAC;AACzB;AAEA,cAAc,QAAQ,SAAU,SAAS,MAAM;AAC7C,MAAI,SAAS,CAAA,GACT,WAAW,CAAA,GACX,WAAW,KAAK,YAAY,OAC5B,WAAW,KAAK,YAAY,KAC5B,gBAAgB,SAAS2G,eAAc,MAAM,UAAU;AACzD,QAAI,WAAW,CAAA,GACX,WAAW,CAAA,GACX,QAAQ,KAAK,YAAY,UAAU,WAAY;AACjD,eAAS,UAAU,QAAQ;AAC3B,iBAAW,CAAA;AACX,iBAAW,CAAA;AAAA,IACb,CAAC,EAAE,MAAA;AACH,WAAO,SAAU,MAAM;AACrB,eAAS,UAAU,MAAM,QAAQ,IAAI;AACrC,eAAS,KAAK,KAAK,OAAO;AAC1B,eAAS,KAAK,IAAI;AAClB,kBAAY,SAAS,UAAU,MAAM,SAAS,CAAC;AAAA,IACjD;AAAA,EACF,GACI;AAEJ,OAAK,KAAK,MAAM;AACd,aAAS,CAAC,IAAI,EAAE,OAAO,GAAG,CAAC,MAAM,QAAQ,YAAY,KAAK,CAAC,CAAC,KAAK,MAAM,kBAAkB,cAAc,GAAG,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC;AAAA,EAC7H;AAEA,MAAI,YAAY,QAAQ,GAAG;AACzB,eAAW,SAAA;AAEX,iBAAa,eAAe,WAAW,WAAY;AACjD,aAAO,WAAW,KAAK,SAAA;AAAA,IACzB,CAAC;AAAA,EACH;AAEA,WAAS,OAAO,EAAE,QAAQ,SAAU,QAAQ;AAC1C,QAAI,SAAS,CAAA;AAEb,SAAK,KAAK,UAAU;AAClB,aAAO,CAAC,IAAI,SAAS,CAAC;AAAA,IACxB;AAEA,WAAO,UAAU;AACjB,WAAO,KAAK,cAAc,OAAO,MAAM,CAAC;AAAA,EAC1C,CAAC;AAED,SAAO;AACT;AAGA,IAAI,uCAAuC,SAASC,sCAAqC,YAAY,SAAS,KAAK,KAAK;AACtH,YAAU,MAAM,WAAW,GAAG,IAAI,UAAU,KAAK,WAAW,CAAC;AAC7D,SAAO,MAAM,OAAO,MAAM,YAAY,MAAM,WAAW,MAAM,IAAI,WAAW,UAAU,OAAO;AAC/F,GACI,sBAAsB,SAASC,qBAAoB,QAAQ,WAAW;AACxE,MAAI,cAAc,MAAM;AACtB,WAAO,MAAM,eAAe,cAAc;AAAA,EAC5C,OAAO;AACL,WAAO,MAAM,cAAc,cAAc,OAAO,SAAS,YAAY,SAAS,aAAa,SAAS,UAAU,gBAAgB,MAAM;AAAA,EACtI;AAEA,aAAW,UAAUA,qBAAoB,OAAO,SAAS;AAC3D,GACI,YAAY;AAAA,EACd,MAAM;AAAA,EACN,QAAQ;AACV,GACI,gBAAgB,SAASC,eAAc,OAAO;AAChD,MAAI,QAAQ,MAAM,OACd,SAAS,MAAM,QACf,OAAO,MAAM;AAEjB,MAAI,QAAQ,MAAM,iBAAiB,MAAM,eAAe,CAAC,IAAI,OAAO,QAChE,QAAQ,KAAK,SAAS,KAAK,KAAK,SAAS,IAAI,GAC7C,OAAO,YACP;AAEJ,MAAI,CAAC,MAAM,cAAc,OAAO,MAAM,aAAa,KAAM;AAEvD,WAAO,QAAQ,SAAS,UAAU,KAAK,gBAAgB,KAAK,gBAAgB,KAAK,eAAe,KAAK,eAAe,EAAE,WAAW,KAAK,kBAAkB,IAAI,GAAG,SAAS,KAAK,UAAU,GAAG,SAAS,KAAK;AACtM,aAAO,KAAK;AAAA,IACd;AAEA,UAAM,YAAY,QAAQ,SAAS,UAAU,CAAC,YAAY,IAAI,MAAM,WAAW,KAAK,kBAAkB,IAAI,GAAG,SAAS,KAAK,UAAU,GAAG,SAAS;AACjJ,UAAM,aAAa;AAAA,EACrB;AAEA,MAAI,MAAM,aAAa,SAAS,KAAK;AACnC,UAAM,gBAAA;AACN,UAAM,aAAa;AAAA,EACrB;AACF,GAEA,iBAAiB,SAASC,gBAAe,QAAQ,MAAM,QAAQ,QAAQ;AACrE,SAAO,SAAS,OAAO;AAAA,IACrB;AAAA,IACA,SAAS;AAAA,IACT,UAAU;AAAA,IACV,UAAU;AAAA,IACV;AAAA,IACA,SAAS,SAAS,UAAU;AAAA,IAC5B,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,UAAU,SAAS,WAAW;AAC5B,aAAO,UAAU,aAAa,MAAM,SAAS,WAAW,CAAC,GAAG,gBAAgB,OAAO,IAAI;AAAA,IACzF;AAAA,IACA,WAAW,SAAS,YAAY;AAC9B,aAAO,gBAAgB,MAAM,SAAS,WAAW,CAAC,GAAG,gBAAgB,IAAI;AAAA,IAC3E;AAAA,EAAA,CACD;AACH,GACI,YAAY,kCACZ,iBACA,iBAAiB,SAASC,gBAAe,GAAG;AAC9C,MAAI,UAAU,UAAU,KAAK,EAAE,OAAO,OAAO;AAE7C,MAAI,WAAW,iBAAiB;AAC9B,MAAE,aAAa;AACf,sBAAkB;AAAA,EACpB;AACF,GACI,uBAAuB,SAASC,sBAAqB,MAAM;AAC7D,YAAU,IAAI,MAAM,OAAO;AAC3B,OAAK,iBAAiB,KAAK,eAAe,KAAK,cAAc;AAC7D,OAAK,SAAS,KAAK,OAAO;AAC1B,OAAK,WAAW,CAAC,CAAC,KAAK;AACvB,OAAK,KAAK,KAAK,MAAM;AAErB,MAAI,SAAS,MACT,mBAAmB,OAAO,kBAC1B,WAAW,OAAO,UAClB,oBAAoB,OAAO,mBAC3B,YAAY,OAAO,WACnB,MACA,MACA,SAAS,WAAW,KAAK,MAAM,KAAK,QACpC,WAAW,KAAK,KAAK,UAAU,gBAC/B,mBAAmB,YAAY,SAAS,OACxC,UAAU,eAAe,KAAK,WAAW,WAAW,KAAK,OAAO,KAAK,oBAAoB,KAAK,YAAY,SAAS,CAAC,iBAAiB,YAAY,iBAAiB,YAClK,cAAc,eAAe,QAAQ,SAAS,GAC9C,cAAc,eAAe,QAAQ,WAAW,GAChD,QAAQ,GACR,gBAAgB,SAAS,WAAW,KAAK,iBAAiB,KAAK,eAAe,QAAQ,KAAK,eAAe,QAAQ,KAAK,cAAc,KAAK,YAC1I,eAAe,GACf,0BAA0B,YAAY,QAAQ,IAAI,WAAY;AAChE,WAAO,SAAS,IAAI;AAAA,EACtB,IAAI,WAAY;AACd,WAAO,YAAY;AAAA,EACrB,GACI,eACA,eACA,gBAAgB,eAAe,QAAQ,KAAK,MAAM,MAAM,iBAAiB,GACzE,kBAAkB,SAASC,mBAAkB;AAC/C,WAAO,gBAAgB;AAAA,EACzB,GACI,eAAe,cACf,eAAe,cACf,eAAe,SAASC,gBAAe;AACzC,WAAO,WAAW,QAAQ,SAAS;AACnC,mBAAe,OAAO,aAAa,IAAI,GAAG,IAAI;AAC9C,yBAAqB,eAAe,OAAO,GAAG,WAAW,QAAQ,WAAW,CAAC;AAC7E,oBAAgB;AAAA,EAClB,GACI,sBAAsB,SAASC,uBAAsB;AACvD,YAAQ,MAAM,IAAI,OAAO,WAAW,QAAQ,MAAM,CAAC,IAAI,YAAY,MAAM,IAAI;AAC7E,YAAQ,MAAM,YAAY,qDAAqD,WAAW,QAAQ,MAAM,CAAC,IAAI;AAC7G,gBAAY,SAAS,YAAY,UAAU;AAAA,EAC7C,GACI,aAAa,SAASC,cAAa;AACrC,QAAI,eAAe;AACjB,4BAAsB,eAAe;AAErC,UAAI,SAAS,OAAO,KAAK,SAAS,CAAC,GAC/B,SAAS,aAAa,YAAY,IAAI,MAAM;AAEhD,UAAI,WAAW,WAAW,YAAY,IAAI,YAAY,QAAQ;AAC5D,oBAAY,SAAS,SAAS,YAAY;AAE1C,YAAI,IAAI,QAAQ,WAAW,WAAW,QAAQ,MAAM,CAAC,KAAK,KAAK,YAAY,MAAM;AAEjF,gBAAQ,MAAM,YAAY,qDAAqD,IAAI;AACnF,gBAAQ,MAAM,IAAI,IAAI;AACtB,oBAAY,UAAU,WAAW;AAEjC,mBAAA;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,gBAAY,UAAU,oBAAA;AACtB,oBAAgB;AAAA,EAClB,GACI,OACA,cACA,cACA,mBACA,WAAW,SAASC,YAAW;AAEjC,iBAAA;AAEA,QAAI,MAAM,SAAA,KAAc,MAAM,KAAK,UAAU,MAAM;AACjD,kBAAA,IAAgB,OAAO,MAAM,SAAS,CAAC,KAAK,YAAY,IAAI,IAAI,MAAM,QAAQ,WAAW,IAAI;AAAA,IAC/F;AAAA,EACF;AAEA,aAAW,KAAK,IAAI,SAAS;AAAA,IAC3B,GAAG;AAAA,EAAA,CACJ;AAED,OAAK,cAAc,SAAU,GAAG;AAC9B,WAAO,cAAc,EAAE,SAAS,eAAe,WAAY,KAAK,QAAQ,QAAQ,EAAE,SAAS,gBAAgB,KAAK,eAAe,EAAE,WAAW,EAAE,QAAQ,SAAS;AAAA,EACjK;AAEA,OAAK,UAAU,WAAY;AACzB,oBAAgB;AAChB,QAAI,YAAY;AAChB,YAAQ,QAAQ,KAAK,kBAAkB,KAAK,eAAe,SAAS,KAAK,YAAY;AACrF,UAAM,MAAA;AACN,kBAAc,SAAS,oBAAoB,QAAQ,QAAQ,OAAO,OAAO,mBAAmB,QAAQ,GAAG;AACvG,mBAAe,YAAA;AACf,mBAAe,YAAA;AACf,iBAAA;AACA,oBAAgB;AAAA,EAClB;AAEA,OAAK,YAAY,KAAK,iBAAiB,SAAUC,OAAM,aAAa;AAClE,gBAAY,UAAU,oBAAA;AAEtB,QAAI,CAAC,aAAa;AAChB,wBAAkB,QAAQ,IAAI;AAAA,IAChC,OAAO;AACL,iBAAW;AAGX,UAAI,MAAM,2BACN,eACA;AAEJ,UAAI,kBAAkB;AACpB,wBAAgB,YAAA;AAChB,oBAAY,gBAAgB,MAAM,OAAO,CAACA,MAAK,YAAY;AAE3D,eAAO,qCAAqC,aAAa,eAAe,WAAW,WAAW,QAAQ,WAAW,CAAC;AAClH,cAAM,KAAK,UAAU,aAAa,SAAS;AAAA,MAC7C;AAEA,sBAAgB,YAAA;AAChB,kBAAY,gBAAgB,MAAM,OAAO,CAACA,MAAK,YAAY;AAE3D,aAAO,qCAAqC,aAAa,eAAe,WAAW,WAAW,QAAQ,SAAS,CAAC;AAChH,YAAM,KAAK,UAAU,aAAa,SAAS;AAC3C,YAAM,aAAa,SAAS,GAAG,EAAE,KAAK,IAAI;AAE1C,UAAI,cAAc,MAAM,KAAK,WAAW,QAAQ,iBAAiB,OAAO,GAAG;AAEzE,aAAK,GAAG,IAAI;AAAA,UACV,UAAU;AAAA,UACV,UAAU;AAAA,QAAA,CACX;AAAA,MACH;AAAA,IACF;AAEA,iBAAa,UAAUA,KAAI;AAAA,EAC7B;AAEA,OAAK,UAAU,WAAY;AACzB,UAAM,OAAO,MAAM,MAAA;AAEnB,QAAI,SAAA,IAAa,eAAe,KAAM;AAEpC,sBAAgB;AAChB,qBAAe,SAAA;AAAA,IACjB;AAAA,EACF;AAEA,OAAK,WAAW,SAAUA,OAAM,IAAI,IAAI,QAAQ,QAAQ;AACtD,mBAAe,iBAAiB,aAAA;AAChC,UAAM,oBAAoB,YAAY,aAAa,OAAO,CAAC,MAAM,KAAK,gBAAgBA,MAAK,SAASA,MAAK,KAAK,YAAA,IAAgB,KAAK,OAAO,CAAC,CAAC,CAAC;AAE7I,QAAI,IAAI;AACN,kBAAY,UAAU,oBAAA;AACtB,UAAI,UAAU,OAAO,CAAC,MAAM,IACxB,IAAI,UAAU,eAAeA,MAAK,SAASA,MAAK,IAAI,YAAA,IAAgB,KAAK,OAAO,CAAC,GACjF,WAAW,aAAa,CAAC;AAC7B,iBAAW,MAAM,aAAa,gBAAgB,WAAW;AACzD,kBAAY,QAAQ;AAAA,IACtB;AAEA,KAAC,MAAM,OAAO,WAAA;AAAA,EAChB;AAEA,OAAK,WAAW,WAAY;AAC1B,wBAAoB,QAAQ,mBAAmB,QAAQ,GAAG;AAE1D,kBAAc,iBAAiB,WAAW,QAAQ;AAElD,iBAAa,MAAM,UAAU,QAAQ;AAErC,QAAI,YAAY,QAAQ;AACtB,kBAAY,OAAO,MAAM,iBAAiB;AAC1C,kBAAY,SAAS,YAAY,SAAS;AAAA,IAC5C;AAEA,kBAAc,OAAA;AAAA,EAChB;AAEA,OAAK,YAAY,WAAY;AAC3B,wBAAoB,QAAQ,IAAI;AAEhC,oBAAgB,MAAM,UAAU,QAAQ;AAExC,kBAAc,oBAAoB,WAAW,QAAQ;AACrD,kBAAc,KAAA;AAAA,EAChB;AAEA,OAAK,WAAW,KAAK,aAAa;AAClC,SAAO,IAAI,SAAS,IAAI;AACxB,OAAK,MAAM;AAEX,gBAAc,CAAC,iBAAiB,YAAY,CAAC;AAE7C,gBAAc,KAAK,OAAO,IAAI,YAAY;AAE1C,sBAAoB,KAAK;AACzB,UAAQ,KAAK,GAAG,MAAM;AAAA,IACpB,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,SAAS,mBAAmB,UAAU;AAAA,IACtC,SAAS;AAAA,IACT,WAAW;AAAA,MACT,SAAS,qBAAqB,aAAa,YAAA,GAAe,WAAY;AACpE,eAAO,MAAM,MAAA;AAAA,MACf,CAAC;AAAA,IAAA;AAAA,IAEH,UAAU;AAAA,IACV,YAAY,kBAAkB,KAAK;AAAA,EAAA,CACpC;AAED,SAAO;AACT;AAEA,cAAc,OAAO,SAAU,MAAM;AACnC,MAAI,YAAY,IAAI,GAAG;AACrB,WAAO,UAAU,KAAK,IAAI;AAAA,EAC5B;AAEA,MAAI,SAAS,KAAK,eAAe;AACjC,gBAAc,OAAA,EAAS,QAAQ,SAAU,GAAG;AAC1C,WAAO,EAAE,SAAS,EAAE,UAAU,SAAS,EAAE,QAAQ,sBAAA,EAAwB,MAAM,EAAE,QAAQ,KAAK;AAAA,EAChG,CAAC;AACD,SAAO,UAAU,KAAK,QAAQ,SAAU,GAAG,GAAG;AAC5C,YAAQ,EAAE,KAAK,mBAAmB,KAAK,QAAQ,EAAE,KAAK,qBAAqB,MAAM,EAAE,YAAY,EAAE,KAAK,qBAAqB,MAAM,EAAE,WAAW,EAAE,KAAK,mBAAmB,KAAK;AAAA,EAC/K,CAAC;AACH;AAEA,cAAc,UAAU,SAAU,MAAM;AACtC,SAAO,IAAI,SAAS,IAAI;AAC1B;AAEA,cAAc,kBAAkB,SAAU,MAAM;AAC9C,MAAI,OAAO,SAAS,aAAa;AAC/B,WAAO;AAAA,EACT;AAEA,MAAI,SAAS,QAAQ,aAAa;AAChC,WAAO,YAAY,OAAA;AAAA,EACrB;AAEA,MAAI,SAAS,OAAO;AAClB,mBAAe,YAAY,KAAA;AAC3B,kBAAc;AACd;AAAA,EACF;AAEA,MAAI,aAAa,gBAAgB,WAAW,OAAO,qBAAqB,IAAI;AAC5E,iBAAe,YAAY,WAAW,WAAW,UAAU,YAAY,KAAA;AACvE,cAAY,WAAW,MAAM,MAAM,cAAc;AACjD,SAAO;AACT;AAEA,cAAc,OAAO;AAAA;AAAA,EAEnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAQ;AAAA;AAAA,IAEN,IAAI,SAAS,KAAK;AAChB,yBAAmB,UAAU,aAAa;AAC1C,wBAAkB,SAAA;AAAA,IACpB;AAAA;AAAA,IAEA,KAAK,SAASC,OAAM;AAClB,aAAO;AAAA,IACT;AAAA,EAAA;AAEJ;AACA,cAAc,KAAK,eAAe,aAAa;AC9nFxC,MAAM,iBAAiB,MAAM;AAClC,QAAM,cAAc;AAAA,IAClB;AAAA,MACE,QAAQ;AAAA,MACR,SAAS,UAAU,KAAK;AAAA,IAAA;AAAA;AAAA,EAC1B;AAKF,QAAMC,YAAW,YAAY,eAAe,SAAS;AACrD,QAAM,YAAY,YAAY,QAAQ,SAAS;AAE/C,SAAO;AAAA,IACL;AAAA,IACA,UAAAA;AAAA,IACA;AAAA,EAAA;AAEJ;ACd0B,iBAAiB;AAClB,iBAAiB;AAGnC,MAAM,MAAM,QAAQ,IAAI,aAAa;AACxB,QAAQ,IAAI,aAAa;;;;;ACyHlC,mBAAe,IAAI;AAC9B,UAAM,eAAe,IAAa,KAAK;AACvC,UAAM,iBAAiB,gBAAA;AACvB,UAAM,aAAa,IAAa,KAAK;AACf,QAAoB,IAAI;AACzB,mBAA4B,cAAc;AACzC,mBAA4B,eAAe;AAEjE,UAAM,UAAU,WAAA;AACF,YAAQ;AAItB,UAAM,QAAoF;AAAA,MACxF,OAAO;AAAA,QACL,OAAO;AAAA,QACP,OAAO;AAAA,UACL,EAAE,OAAO,uBAAuB,IAAI,IAAA;AAAA,UACpC,EAAE,OAAO,kBAAkB,IAAI,IAAA;AAAA,UAC/B,EAAE,OAAO,oBAAoB,IAAI,IAAA;AAAA,UACjC,EAAE,OAAO,qBAAqB,IAAI,IAAA;AAAA,UAClC,EAAE,OAAO,mBAAmB,IAAI,IAAA;AAAA,QAAI;AAAA,MACtC;AAAA,MAEF,WAAW;AAAA,QACT,OAAO;AAAA,QACP,OAAO;AAAA,UACL,EAAE,OAAO,wBAAwB,IAAI,IAAA;AAAA,UACrC,EAAE,OAAO,wBAAwB,IAAI,IAAA;AAAA,UACrC,EAAE,OAAO,mBAAmB,IAAI,IAAA;AAAA,UAChC,EAAE,OAAO,qBAAqB,IAAI,IAAA;AAAA,UAClC,EAAE,OAAO,iBAAiB,IAAI,IAAA;AAAA,QAAI;AAAA,MACpC;AAAA,MAEF,YAAY;AAAA,QACV,OAAO;AAAA,QACP,OAAO;AAAA,UACL,EAAE,OAAO,qBAAqB,IAAI,IAAA;AAAA,UAClC,EAAE,OAAO,iBAAiB,IAAI,IAAA;AAAA,UAC9B,EAAE,OAAO,yBAAyB,IAAI,IAAA;AAAA,UACtC,EAAE,OAAO,sBAAsB,IAAI,IAAA;AAAA,UACnC,EAAE,OAAO,kBAAkB,IAAI,IAAA;AAAA,QAAI;AAAA,MACrC;AAAA,MAEF,WAAW;AAAA,QACT,OAAO;AAAA,QACP,OAAO;AAAA,UACL,EAAE,OAAO,QAAQ,IAAI,IAAA;AAAA,UACrB,EAAE,OAAO,gBAAgB,IAAI,IAAA;AAAA,UAC7B,EAAE,OAAO,SAAS,IAAI,IAAA;AAAA,UACtB,EAAE,OAAO,QAAQ,IAAI,IAAA;AAAA,UACrB,EAAE,OAAO,WAAW,IAAI,IAAA;AAAA,QAAI;AAAA,MAC9B;AAAA,IACF;AAGF,UAAM,cAAc,IAAoB,IAAI;AAC5C,UAAM,aAAa,IAAoB,IAAI;AAE3C,UAAM,SAAS,SAA8C;AAAA,MAC3D,OAAO;AAAA,MACP,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,WAAW;AAAA,IAAA,CACZ;AACiB,aAA8C;AAAA,MAC9D,OAAO;AAAA,MACP,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,WAAW;AAAA,IAAA,CACZ;AAEsB,aAA8C;AAAA,MACnE,OAAO;AAAA,MACP,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,WAAW;AAAA,IAAA,CACZ;AAEgB,aAAoD;AAAA,MACnE,OAAO,CAAA;AAAA,MACP,WAAW,CAAA;AAAA,MACX,YAAY,CAAA;AAAA,MACZ,WAAW,CAAA;AAAA,IAAC,CACb;AAED,UAAM,cAAc,SAA+B;AAAA,MACjD,OAAO,CAAA;AAAA,MACP,WAAW,CAAA;AAAA,MACX,YAAY,CAAA;AAAA,MACZ,WAAW,CAAA;AAAA,IAAC,CACb;AAqBD,WAAO,KAAK,KAAK,EAAE,QAAQ,CAAC,MAAM;AAChC,YAAM,MAAM;AACZ,YAAM,QAAQ,SAAS,MAAM,OAAO,GAAG,CAAC;AACxC,qBAAe,OAAO,MAAM;AAC1B,YAAI,YAAY,UAAU,IAAK,aAAY,QAAQ;AAAA,MACrD,CAAC;AAAA,IACH,CAAC;AAED,qBAAiB,WAAW,CAAC,MAAqB;AAChD,UAAI,EAAE,QAAQ,SAAU,aAAY,QAAQ;AAAA,IAC9C,CAAC;AAED,YAAQ,KAAK,0BAA0B,MAAM;AAC3C,UAAI,CAAC,eAAe,MAAO;AAC3B,qBAAe,QAAQ;AAAA,IACzB,CAAC;AAEqB,mBAAA;AAwPtB,aAAS,mBAAyB;AAChC,iBAAW,QAAQ,CAAC,WAAW;AAAA,IACjC;;;;;;;;;;;;sBA1fkCpJ,MAAA,cAAA;AAAA,gBAA8BA,MAAA,YAAA;AAAA,MAAA;;;AAWjBqJ,oBAAA,OAAK,CAAxB,MAAM,KAAK,QAAG;;;UAO1B,OAAK,CAAC,aAAW,EAAA,QACCrJ,MAAA,WAAA,MAAiB,KAAG;AAAA,UACtC,IAAG;AAAA,UACF,iBAAeA,MAAA,WAAA,MAAiB;AAAA,QAAA;2BAJnC,CAQW,GAAAO,QAAAC,UAAA,aAAA;;sEAHa8I,eAAA,KAAK,KAAK,gEACHA,eAAA,KAAK,KAAK;;gBACzB,OAAK,EAAA,MAAUtJ,MAAA,WAAA,MAAiB,IAAA;AAAA,cAAG;;;gBAFjDW,YAA0C,UAApC,OAAM,OAAA,GAAM4I,gBAAI,KAAK,KAAK,GAAA,CAAA;AAAA,gBAChC5I,YAAiD,UAA3C,OAAM,cAAA,GAAa4I,gBAAI,KAAK,KAAK,GAAA,CAAA;AAAA,gBACvC5I,YAAmE,wBAAA;AAAA,kBAArD,OAAK,EAAA,MAAUX,MAAA,WAAA,MAAiB,IAAA;AAAA,gBAAG;;;;;;+CAOhD,cAAY,KAAK,KAAK,YACFwJ,eAAA,CAAA,EAAA,WAAAxJ,MAAA,WAAA,MAAiB,KAAG,cAA4BA,MAAA,UAAA,MAAgB,IAAA,GAAG,UAAA,CAAA,aAChFyJ,eAAAzJ,MAAA,WAAA,EAAY,GAAG,CAAA;AAGN,cAAA0J,mBAAA,wBAAA,EAAA,OAAM,kBAAc,MAAA,OAAA,CAAA;;AAIXL,sBAAA,KAAK,OAAK,CAAxB,MAAMM,SAAG;;;YAIP,OAAM;AAAA,YAAkB,IAAI,KAAK;AAAA,UAAA;6BAA3C,CAEW,GAAApJ,QAAAC,UAAA,aAAA;;AADND,uBAAA,GAAA+I,eAAA,KAAK,KAAK,CAAA,EAAA;AAAA;;kBAAVM,gBAAAL,gBAAA,KAAK,KAAK,GAAA,CAAA;AAAA,gBAAA;AAAA;;;;;;;YAMb,QAAG,GAAA;;;YACD,OAAM;AAAA,YAAY,IAAG;AAAA,UAAA;6BAA/B,CAGW,GAAAhJ,QAAAC,UAAA,aAAA;;;;;kBAFTG,YAA4C,QAAA,EAAtC,OAAM,OAAA,GAAO,oBAAkB;AAAA,kBACrCA,YAAmD,QAAA,EAA7C,OAAM,cAAA,GAAc,oBAAkB;AAAA,gBAAA;AAAA;;;;;;;;;;;AAOvC,YAAA+I,mBAAA,sBAAA,EAAA,OAAM,iBAAa;AAAA,yBAA9B,CAAuD,GAAAnJ,QAAAC,UAAA,aAAA;;;;;8BAAxB,cAAY;AAAA,YAAA;AAAA;;;;;;QAIhC,gBAAcR,MAAA,UAAA;AAAA,QAAa,SAAO;AAAA,MAAA;;;;;;;;;;;;;ACpEvD,SAAS,yBAAyB,UAAU,SAAS;AACnD,QAAM,uBAAuB,UAAU,WAAW;AAClD,SAAO,IAAI,KAAK,KAAK,MAAM,KAAK,KAAK,uBAAuB,EAAE;AAChE;AACA,SAAS,uBAAuB,OAAO,IAAI;AACzC,QAAM,EAAE,WAAW,KAAK,WAAW,KAAK,YAAY,KAAK,aAAa,IAAG,IAAK;AAC1D,OAAK,qBAAqB;AAC9C,QAAM,UAAU,WAAU;AAC1B,QAAM,WAAW,WAAW,CAAC;AAC7B,QAAM,YAAY,WAAW,KAAK;AAClC,QAAM,QAAQ,WAAW,KAAK;AAM9B,QAAM,QAAQ,CAAC,QAAQ,OAAO;AAE5B,UAAM,QAAQ;AACd,QAAI,GAAG,KAAK;AAAA,EACd;AACA,WAAS,IAAI,KAAK,GAAG,QAAQ,CAAA,GAAI;AAC/B,QAAI,QAAQ,aAAa;AACvB;AAAA,IACF;AACA,QAAI,MAAM,KAAK;AACb,aAAO,OAAO,EAAE,OAAO,MAAM,MAAK,CAAE;AAAA,IACtC;AAEA,aAAS,QAAQ,KAAK,IAAI,IAAI;AACT,UAAM,QAAQ,IAAI;AAMhC;AACL,gBAAU,QAAQ;AAAA,IAEpB;AAAA,EACF;AAWA,WAAS,OAAO,QAAQ,IAAI;AAC1B,aAAS,QAAQ;AAIjB,QAAI,MAAM,OAAO;AACf,YAAM,QAAQ;AAAA,IAChB;AACA,QAAI,MAAM,OAAO;AACf,eAAS,QAAQ;AACjB,gBAAU,QAAQ;AAAA,IACpB;AAAA,EAGF;AAOA,WAAS,QAAQ;AAAA,EAKjB;AAmBA,MAAI,WAAW,MAAM;AAAA,EACrB;AAgBA,SAAO;AAAA,IACL;AAAA,IACA,UAAU,SAAS,MAAM,SAAS,KAAK;AAAA,IACvC,WAAW,SAAS,MAAM,UAAU,KAAK;AAAA,IACzC,OAAO,SAAS,MAAM,MAAM,KAAK;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA;AACO,SAAS,oBAAoB,OAAO,IAAI;AAC7C,QAAM,UAAU,WAAU;AAC1B,QAAM,YAAY,QAAQ,sBAAsB,uBAAuB,IAAI;AAY3E,SAAO;AACT;;;;;ACtIA,UAAM,KAAK,eAAe,IAAI;AAC9B,UAAM,kBAAkB,IAAI,IAAI;AAER,uBAAkB;AAE1C,UAAM,EAAE,UAAU,WAAW,OAAO,QAAQ,MAAK,IAAK,oBAAoB;AAAA,MACxE,UAAU;AAAA,MACV,UAAU;AAAA,MACV,mBAAmB,CAAC,UAAU,YAAa,IAAI,KAAK,KAAM,MAAM,KAAK,KAAO,UAAU,WAAY,MAAO,EAAE;AAAA,IAC7G,CAAC;;UAfYA,MAAA,eAAA,GAAe;;mBAAM;AAAA,UAAJ,KAAI;AAAA,UAAK,OAAM;AAAA;;;;;;;;;;;;;;;;;;ACY7C,UAAM,gBAAgB,eAAA;AACtB,UAAM,aAAa,cAAA;AACnB,UAAM,iBAAiB,kBAAA;AACvB,UAAM,kBAAkB,mBAAA;AAGxB,UAAM,eAAe,CAAC,GAAG,IAAI,IAAI,WAAW,OAAO,KAAK,CAAC;AACzD,UAAM,oBAAoB,IAAI,IAAI,eAAe,MAAM,OAAO,CAAC,SAAS,KAAK,SAAS,OAAO,EAAE,IAAI,CAAC,SAAS,KAAK,GAAG,CAAC;AACtH,UAAM,YAAY,aAAa,OAAO,CAAC,QAAQ,CAAC,kBAAkB,IAAI,GAAG,CAAC;AAC1E,mBAAe,MAAM,KAAK,GAAG,UAAU,IAAI,CAAC,SAAS,EAAE,KAAK,KAAK,MAAM,QAAA,EAAU,CAAC;AAGlF,QAAI,UAAU,UAAU,eAAe;AACrC,YAAM,gCAAgB,IAAA;AACtB,iBAAW,SAAS,OAAO,OAAO,UAAU,KAAK,MAAM,GAAG;AACxD,cAAM,WAAW,MAAM,MAAM,GAAG,EAAE,CAAC,EAAE,QAAQ,SAAS,EAAE,EAAE,KAAA;AAC1D,kBAAU,IAAI,QAAQ;AAAA,MACxB;AAEA,YAAM,kBAAkB,IAAI,IAAI,eAAe,MAAM,OAAO,CAAC,SAAS,KAAK,SAAS,MAAM,EAAE,IAAI,CAAC,SAAS,KAAK,EAAE,CAAC;AAClH,iBAAW,YAAY,WAAW;AAChC,YAAI,CAAC,gBAAgB,IAAI,QAAQ,GAAG;AAClC,gBAAM,aAAa;AAAA,YACjB,IAAI;AAAA,YACJ,MAAM;AAAA,UAAA;AAGR,yBAAe,MAAM,KAAK,UAAU;AAAA,QACtC;AAAA,MACF;AAAA,IACF;AAEA,UAAM,KAAK,eAAe,IAAI;AACf,mBAAe,QAAQ;AAElB,QAAI,CAAC;AACN,QAAI,CAAC;AAExB,UAAM,gBAAgB,SAAS,MAAM,KAAK,MAAM,gBAAgB,KAAK,CAAC;AA8GtE,UAAM,YAAY,MAAM;AACtB,oBAAc,QAAA;AAAA,IAChB;AAEA,UAAM,eAAe,CAAC,UAAU;AAC9B,UAAI,OAAO;AACT,kBAAA;AAAA,MACF;AAAA,IACF,CAAC;AAEa,iBAAa;;WA1KbA,MAAA,aAAA,GAAa;;mBAAM;AAAA,UAAJ,KAAI;AAAA,UAAK,OAAM;AAAA,QAAA,yMAGOA,MAAA,aAAA,CAAa;;;;;;;;;;;;;;ACFzD,SAAS,wBAAwB,SAAS;AAE7C,SAAO,IAAI,QAAQ,MAAM;AAAA,EACzB,CAAC;AAiDL;AClDA,SAAS,yBAAyB,QAAQ,OAAO;AAC/C,MAAI,CAAC,OAAO;AACV;AAAA,EACF;AACA,QAAM,cAAc,CAAC,KAAK,OAAO;AAC/B,QAAI,CAAC,OAAO,KAAK,GAAG,GAAG;AACrB,SAAG,OAAO,QAAQ;AAClB,aAAO,MAAM;AAAA,MACb;AAAA,IACF;AACA,QAAI,IAAI,OAAO,KAAK,GAAG,EAAE,KAAK,EAAE;AAChC,UAAM,UAAU,MAAM;AACpB,UAAI,GAAG;AACL,eAAO,KAAK,GAAG,GAAG,OAAO,IAAI,GAAG,CAAC;AACjC,YAAI;AAAA,MACN;AAAA,IACF;AACA,mBAAe,OAAO;AACtB,WAAO;AAAA,EACT;AACA,SAAO,WAAW,CAAC,OAAO,YAAY,UAAU,EAAE;AAClD,SAAO,UAAU,CAAC,OAAO,YAAY,SAAS,EAAE;AAChD,iBAAe,MAAM;AACnB,WAAO,yBAAyB,MAAK;AAAA,EACvC,CAAC;AACH;AACA,SAAS6J,YAAU,QAAQ,UAAU;AACnC,QAAM,QAAQ,OAAO,WAAW,WAAW,EAAE,KAAK,OAAM,IAAK;AAC7D,QAAM,UAAU,YAAY,CAAA;AAC5B,QAAM,OAAO,SAAS,QAAQ5K,aAAU;AACxC,UAAQ,OAAO;AACf,QAAM,QAAQ,mBAAkB;AAChC,UAAQ,eAAe;AACvB,MAAI,SAAS,OAAO,QAAQ,YAAY,aAAa;AACnD,YAAQ,UAAU;AAAA,EACpB,WAAW,MAAM,QAAQ,OAAO,GAAG;AACjC,UAAM,aAAa,QAAQ;AAC3B,QAAI;AACJ,YAAQ,UAAU,IAAI,QAAQ,CAAC,YAAY;AACzC,YAAM,MAAM,YAAY,CAAC,QAAQ;AAC/B,YAAI,KAAK;AACP,kBAAQ,IAAI;AAAA,QACd;AAAA,MACF,GAAG;AAAA,QACD,WAAW;AAAA,MACnB,CAAO;AACD,qBAAe,MAAM,QAAQ,KAAK,GAAG,IAAI;AAAA,IAC3C,CAAC,EAAE,KAAK,CAAC,QAAQ;AACf,YAAG;AACH,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AACA,OAAK,uBAAuB,KAAK,wBAAwB,KAAK,MAAM,KAAK,kBAAkB,CAAC,EAAE,QAAQ,EAAC,MAAO;AAC5G,MAAE,WAAW,QAAQ,EAAE;AAAA,EACzB,CAAC;AACD,QAAM,SAAS6K,YAAY,MAAM,OAAO,OAAO;AAC/C,SAAO,aAAa,OAAO,cAAc,IAAI,OAAO,MAAM;AAC1D,2BAAyB,QAAQ,KAAK;AACtC,SAAO,IAAI,MAAM,QAAQ;AAAA,IACvB,IAAI,GAAG,KAAK,GAAG;AACb,aAAO,QAAQ,IAAI,GAAG,QAAQ,WAAW,eAAe,KAAK,CAAC;AAAA,IAChE;AAAA,EACJ,CAAG;AACH;AC/DA,SAAS,6BAA6B;AACpC,UAAO,iCAAgB,GAAG,OAAO,cAAc;AACjD;AACO,SAAS,iBAAiB,OAAO;AACtC,SAAO,MAAM,OAAO,MAAM,QAAQ,OAAO,MAAM,cAAc,WAAW,MAAM,YAAY;AAC5F;AACO,SAAS,UAAU,OAAO,SAAS;AACxC,UAAQ,OAAO,UAAU,WAAW,EAAE,KAAK,MAAK,IAAK;AACrD,YAAU,KAAK,SAAS,2BAA0B,GAAI,oBAAoB;AAC1E,QAAM,KAAK,OAAO,iBAAiB,KAAK,CAAC;AACzC,QAAM,UAAU,WAAU;AAC1B,UAAQ,OAAO,QAAQ,QAAQ,WAAU;AACzC,MAAI,CAAC,QAAQ,MAAM;AACjB,UAAM,IAAI,MAAM,mDAAmD;AAAA,EACrE;AACA,UAAQ,WAAW,QAAQ,YAAY,SAAS,CAAA,CAAE;AACnC,GAAC,CAAC,QAAQ,WAAW,EAAE;AACtC,MAAI,QAAQ,YAAY,iBAAiB,QAAQ,YAAY,UAAU;AACrE,QAAI,CAAC,QAAQ,gBAAgB;AAC3B,cAAQ,iBAAiB;AAAA,IAC3B;AACA,QAAI,QAAQ,YAAY,eAAe;AACrC,cAAQ,UAAU;AAAA,IACpB;AAAA,EACF;AACA,QAAM,WAAWC,YAAW,OAAO,OAAO;AAC1C,QAAM,UAAU,SAAS;AACzB,WAAS,SAAS,MAAM;AACtB,YAAQ,SAAS,EAAE,IAAI;AACvB,WAAO,QAAO;AAAA,EAChB;AACA,UAAQ,SAAS,EAAE,IAAI;AAgDvB,SAAO;AACT;ACpFA,MAAM,OAAO,OAAO;AAAA,EAClB,OAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA,EAAE,UAAU,KAAI;AAAA,EACpB;AACA;AAEO,MAAM,SAAS;AAEf,MAAM,SAAS;AAGf,MAAM,WAAW;ACCjB,SAAS,oBAAoB,KAAK;AACvC,WAAQ,iCAAgB,GAAG,OAAO,WAAW,CAAA,GAAI,GAAG;AACtD;AACO,SAAS,kBAAkB,aAAa,WAAW,cAAc;AACtE,QAAM,eAAe,oBAAoB,WAAW;AACpD,QAAM,cAAc,OAAO,OAAO,gBAAgB,IAAI,OAAO,iBAAiB,WAAW,eAAe,EAAE;AAC1G,QAAM,UAAU,UAAU,WAAW;AACrC,QAAM,cAAc,KAAK,YAAY,aAAa,QAAQ,aAAa,EAAE,KAAK,aAAa;AAC3F,QAAM,gBAAgB,OAAO,OAAO,aAAa,iBAAiB,IAAI,QAAQ,iBAAiB,EAAE;AAajG,QAAM,OAAO,cAAc;AAC3B,gBAAc,aAAa,MAAM;AAM/B,WAAI;AAAA,EAIN;AACA,SAAO,UAAU,aAAa,aAAa;AAC7C;AC7CsC,OAAO;AAAA,EAC3C,IAAI,OAAA;AAAA;AAAA,EAEJ,GAAG,SAAS,OAAA,CAAQ;AAAA;AAEtB,CAAC;AACM,SAAS,yBAAyB,UAAU;AACjD,SAAO,kBAAkB,UAAU,OAAO,mBAAmB,CAAC,YAAY;AACxE,UAAM,gBAAgB,SAAS,KAAK;AACpC,UAAM,IAAkC,CAAA;AACxC,WAAO;AAAA,MACL,aAAa;AAAA,QACX,KAAK,UAAU,4CAA4C,EAAE,IAAI,SAAS,IAAI,GAAG,SAAS,EAAA,CAAG;AAAA,MAAA;AAAA,MAE/F,QAAmD;AAAA,MACnD,eAAe;AAAA,QACb,KAAK,MAAM;AACT,iBAAO;AAAA,YACL,WAAW,EAAE,aAAa;AAAA,YAC1B,MAAM,EAAE;AAAA,UAAA;AAAA,QAEZ;AAAA,QACA,wBAAwB;AAAA,QACxB,aAAa;AAAA,MAAA;AAAA,MAEf,YAAiC;AAAA,IAQjC;AAAA,EAEJ,GAAG,QAAQ;AACb;;;;;AC4EA,UAAM,gBAAgB,iCAAgB;AACtC,UAAM,OAAO,SAAS,MAAM,cAAc,OAAO,QAAQ,gBAAgB,EAAE;AAE3E,UAAM,SAAS,UAAU,gBAAgB;AACzC,UAAM,WAAW,IAAI,KAAK;AAE1B,UAAM,cAAc,IAAI,KAAK;AAE7B,UAAM,oBAAoB,KAAK,QAC3B,UAAU,sBAAsB;AAAA,MAC9B,SAAS,OAAO,EAAE,WAAW;MAC7B,MAAM;AAAA,IACZ,CAAK,IACD,IAAI,EAAE,WAAW,MAAM;AAEP,aAAS;AAAA,MAC3B,WAAW;AAAA,MACX,WAAW,KAAK,QAAS,kBAAkB,OAAO,aAAa,QAAS;AAAA,IAC1E,CAAC;AAED,QAAI,KAAK,OAAO;AACd,YAAM,iBAAiB,wBAAuB;AAE9C,YAAM,KAAK,yBAAyB;AAAA,QAClC,eAAe;AAAA,UACb,SAAS;AAAA,QACf;AAAA,MACA,CAAG;AAED,YAAM,mBAAmB,CAAC,UAAU;AAClC,YAAI,MAAM,WAAW;AACnB,yBAAe,OAAM;AACrB,cAAI,KAAI;AAAA,QACV,OAAO;AACL,cAAI,OAAM;AAAA,QACZ;AAAA,MACF,CAAC;AAAA,IACH;AAEA,UAAM,UAAU,WAAU;AAC1B,UAAM,QAAQ,QAAQ;AAEtB,UAAM,aAAa,CAAC,WAAW;AAC7B,UAAI,CAAC,MAAO;AACZ,UAAI,QAAQ;AACV,cAAM,MAAK;AAAA,MACb,OAAO;AACL,cAAM,OAAM;AAAA,MACd;AAAA,IACF,CAAC;AA8CU,mBAAe,IAAI;AAER,mBAAc;AAkBpC,gBAAY,UAAU,MAAM;AAC1B,UAAI,CAAC,YAAY,MAAO;AACxB,kBAAY,QAAQ;AAAA,IACtB,CAAC;;;;;AAvOe,UAAA,CAAA/J,MAAA,MAAA,MAAWA,MAAA,QAAA,GAAQ;;AAGnB,cAAA0J,mBAAA,iBAAA,EAAA,OAAM,QAAO,GAAA;AAAA,2BAAnB,CAAkD,GAAAnJ,QAAAC,UAAA,aAAA;;;;;gCAA9B,yBAAuB;AAAA;;;;;;2BAC3C,CAGO,GAAAD,QAAAC,UAAA,aAAA;;;;;gCAHD,gLAGN;AAAA;;;;;;;;;;;;;;;;;;;;;;ACRV,MAAA,UAAe;AAAA,EACb,SAAS,qBAAqB,MAAM,OAAO,6BAA6E,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC,CAAC;AACrJ;ACKA,MAAM,eAAe,gBAAgB;AAAA,EACnC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACE,MAAM,OAAO,SAAS;AACpB,WAAO,MAAM,EAAE,QAAQ,MAAM,IAAI,GAAG,MAAM,aAAa,QAAQ,KAAK;AAAA,EACtE;AACF,CAAC;AACD,MAAM,kBAAkB;AAAA,EACtB,MAAM;AAAA,IACJ,MAAM,CAAC,QAAQ,SAAS,MAAM;AAAA,IAC9B,SAAS;AAAA,EACb;AAAA,EACE,UAAU;AAAA,IACR,MAAM,CAAC,QAAQ,MAAM;AAAA,IACrB,SAAS;AAAA,EACb;AACA;AACA,MAAA,qBAAe,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,EACP,MAAM,OAAO,SAAS;AACpB,UAAM,UAAU,WAAU;AAC1B,UAAM,gBAAgB,OAAO,eAAe;AAC5C,UAAM,sBAAsB,CAAC,iBAAiB,kBAAkB,SAAQ;AACxE,UAAM,QAAQ,sBAAsBwJ,WAAiB,IAAK;AAC1D,UAAMC,UAAS,SAAS,MAAM;AAC5B,UAAIC,WAAU,MAAM,MAAM,IAAI,KAAK,OAAO,KAAK,UAAU;AACzD,UAAIA,YAAW,EAAEA,YAAW,UAAU;AAIpC,YAAI,MAAM,UAAU;AAClB,UAAAA,WAAU,MAAM,MAAM,QAAQ;AAAA,QAChC;AAAA,MACF;AACA,aAAOA;AAAA,IACT,CAAC;AACD,UAAM,YAAY,WAAU;AAC5B,YAAQ,OAAO,EAAE,WAAW;AAC5B,UAAM,OAAO,QAAQ,eAAc;AAQnC,QAAI;AACJ,WAAO,MAAM;AACX,YAAM,YAAYD,QAAO,SAASA,QAAO,SAAS;AAClD,YAAM,kBAAkB,OAAO,KAAK,oBAAoBE;AACxD,YAAM,2BAA2B;AACjC,mBAAaF,QAAO;AACpB,aAAO,kBAAkB,aAAa,iBAAiB;AAAA,QACrD,SAAS,MAAM,EAAE,UAAU,EAAE,aAAa,MAAM,WAAW,MAAM;AAC/D,mBAAS,IAAI;AAAA,QACf,KAAK;AAAA,UACH,SAAS,MAAM;AAAA,YACb;AAAA,YACA;AAAA,cACE,aAAa,WAAW,QAAQ,OAAO,EAAE,KAAK,WAAW;AAAA,cACzD,KAAKA,QAAO,SAAS;AAAA,cACrB,MAAMA,QAAO;AAAA,cACb,eAAe,CAAC,MAAM;AAAA,cACtB,sBAAsB,CAAC,SAAS;AAC9B,uBAAO,SAAS,4BAA4B,SAASA,QAAO;AAAA,cAC9D;AAAA,cACA,eAAe,CAAC,CAAC;AAAA,YAC/B;AAAA,YACY,QAAQ;AAAA,UACpB;AAAA,QACA,CAAS;AAAA,MACT,CAAO,EAAE,QAAO;AAAA,IACZ;AAAA,EACF;AACF,CAAC;AACD,MAAM,iBAAiB,gBAAgB;AAAA,EACrC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,MAAM;AAAA,MACJ,MAAM,CAAC,QAAQ,OAAO;AAAA,IAC5B;AAAA,IACI,aAAa;AAAA,MACX,MAAM;AAAA,IACZ;AAAA,IACI,eAAe;AAAA,MACb,MAAM;AAAA,IACZ;AAAA,IACI,eAAe;AAAA,MACb,MAAM;AAAA,IACZ;AAAA,IACI,sBAAsB;AAAA,MACpB,MAAM;AAAA,MACN,UAAU;AAAA,IAChB;AAAA,EACA;AAAA,EACE,MAAM,OAAO,SAAS;AACpB,UAAM,OAAO,MAAM;AACnB,QAAI,MAAM,eAAe;AACvB,cAAQ,kBAAkB;AAAA,QACxB,WAAW,CAAC,UAAU,UAAU,MAAM,KAAK,UAAU;AAAA,MAC7D,CAAO;AAAA,IACH;AACA,UAAM,gBAAgB,OAAO,eAAe;AAC5C,UAAM,sBAAsB,iBAAiB,kBAAkB,SAAQ;AACvE,QAAI,qBAAqB;AACvB,YAAM,iBAAiBD,WAAiB;AACxC,YAAM,qBAAqB,CAAA;AAC3B,iBAAW,QAAQ,gBAAgB;AACjC,cAAM,MAAM;AACZ,eAAO,eAAe,oBAAoB,KAAK;AAAA,UAC7C,YAAY;AAAA,UACZ,KAAK,MAAM;AACT,mBAAO,MAAM,qBAAqB,MAAM,IAAI,IAAI,eAAe,GAAG,IAAI,cAAc,GAAG;AAAA,UACzF;AAAA,QACV,CAAS;AAAA,MACH;AACA,cAAQ,iBAAiB,gBAAgB,kBAAkB,CAAC;AAAA,IAC9D;AAeA,WAAO,MAAM;AACX,UAAI,CAAC,QAAQ,OAAO,SAAS,YAAY,EAAE,QAAQ,UAAU;AAK3D,eAAO,QAAQ,MAAM,UAAO;AAAA,MAC9B;AASA,aAAO;AAAA,QACL;AAAA,QACA,EAAE,KAAK,MAAM,aAAa,MAAM,aAAa,KAAI;AAAA,QACjD,QAAQ;AAAA,MAChB;AAAA,IACI;AAAA,EACF;AACF,CAAC;ACxKM,MAAM,sBAAsB,CAAC,OAAO,oBAAoB,gBAAgB;AAAA,EAC7E;AAAA,EACA,OAAO;AAAA,IACL,OAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU;AAAA,IAChB;AAAA,IACI,OAAO;AAAA,IACP,UAAU;AAAA,IACV,WAAW;AAAA,IACX,gBAAgB;AAAA,EACpB;AAAA,EACE,MAAM,OAAO;AACX,UAAM,cAAc,MAAM;AAC1B,UAAM,gBAAgB,MAAM;AAC5B,UAAM,QAAQ,CAAA;AACd,eAAW,OAAO,MAAM,OAAO;AAC7B,aAAO,eAAe,OAAO,KAAK;AAAA,QAChC,KAAK,MAAM,gBAAgB,MAAM,YAAY,MAAM,MAAM,GAAG,IAAI,cAAc,GAAG;AAAA,QACjF,YAAY;AAAA,MACpB,CAAO;AAAA,IACH;AACA,YAAQ,iBAAiB,gBAAgB,KAAK,CAAC;AAY/C,WAAO,MAAM;AACX,UAAI,CAAC,MAAM,OAAO;AAChB,eAAO,MAAM;AAAA,MACf;AAKA,aAAO,EAAE,MAAM,OAAO,EAAE,KAAK,MAAM,UAAU;AAAA,IAC/C;AAAA,EACF;AACF,CAAC;AACM,MAAM,gBAAgB,oBAAmB;ACrChD,MAAA,qBAAe,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,MAAM;AAAA,MACJ,MAAM;AAAA,IACZ;AAAA,IACI,YAAY;AAAA,MACV,MAAM,CAAC,SAAS,MAAM;AAAA,MACtB,SAAS;AAAA,IACf;AAAA,IACI,WAAW;AAAA,MACT,MAAM,CAAC,SAAS,MAAM;AAAA,MACtB,SAAS;AAAA,IACf;AAAA,IACI,OAAO;AAAA,MACL,MAAM;AAAA,IACZ;AAAA,IACI,SAAS;AAAA,MACP,MAAM,CAAC,UAAU,MAAM;AAAA,MACvB,SAAS;AAAA,IACf;AAAA,EACA;AAAA,EACE,MAAM,OAAO,EAAE,OAAO,OAAO,OAAM,GAAI;AACrC,UAAM,UAAU,WAAU;AAC1B,UAAM,UAAU,IAAG;AACD,WAAO,iBAAiB,IAAI;AAE9C,WAAO,EAAE,SAAS;AACE,WAAO,kBAAkB,IAAI;AAEpC,YAAQ,eAAc;AAwBnC,WAAO,MAAM;AACX,aAAO,EAAE,YAAY,EAAE,MAAM,MAAM,MAAM,OAAO,MAAM,OAAO,GAAG,MAAK,GAAI;AAAA,QACvE,SAA8B,CAAC,eAAe;AAC5C,iBAAO,EAAE,UAAU,EAAE,aAAa,KAAI,GAAI;AAAA,YACxC,UAAU;AACR,qBAAO,EAAE,eAAe;AAAA,gBACtB,OAAO,MAAM,UAAU,cAAc,MAAM,SAAS,UAAU,IAAI,WAAW;AAAA,gBAC7E,OAAO,WAAW;AAAA,gBAClB,UAAU;AAAA,cAC1B,CAAe;AAAA,YACH;AAAA,UACZ,CAAW;AAAA,QACH;AAAA,MAyFR,CAAO;AAAA,IACH;AAAA,EACF;AACF,CAAC;AA2BD,SAAS,cAAc,MAAM,MAAM;AACjC,QAAM,cAAc,KAAK,IAAI;AAC7B,SAAO,YAAY,WAAW,IAAI,EAAE,YAAY,CAAC,CAAC,IAAI,EAAE,UAAU,QAAQ,WAAW;AACvF;ACtMA,MAAMpJ,eAAa;AAAA,EACjB,OAAO;AAAA,EACP,MAAM;AAAA,EACN,SAAS;AACX;AAEO,SAASC,SAAO,MAAM,QAAQ;AACnC,SAAQC,UAAU,GAAIC,mBAAoB,OAAOH,cAAY,CAAC,GAAI,OAAO,CAAC,MAAM,OAAO,CAAC,IAAI;AAAA,IAC1FI,mBAAoB,QAAQ;AAAA,MAC1B,MAAM;AAAA,MACN,GAAG;AAAA,IACT,GAAO,MAAM,EAAE;AAAA,EACf,EAAK,CAAC;AACN;AACA,MAAA,qBAAe,EAAE,QAAQH,SAAM;;;;;;ACd/B,MAAMD,eAAa;AAAA,EACjB,OAAO;AAAA,EACP,MAAM;AAAA,EACN,SAAS;AACX;AAEO,SAASC,SAAO,MAAM,QAAQ;AACnC,SAAQC,UAAU,GAAIC,mBAAoB,OAAOH,cAAY,CAAC,GAAI,OAAO,CAAC,MAAM,OAAO,CAAC,IAAI;AAAA,IAC1FI,mBAAoB,QAAQ;AAAA,MAC1B,MAAM;AAAA,MACN,GAAG;AAAA,IACT,GAAO,MAAM,EAAE;AAAA,EACf,EAAK,CAAC;AACN;AACA,MAAA,qBAAe,EAAE,QAAQH,SAAM;;;;;;ACd/B,MAAM,aAAa;AAAA,EACjB,OAAO;AAAA,EACP,MAAM;AAAA,EACN,SAAS;AACX;AAEO,SAAS,OAAO,MAAM,QAAQ;AACnC,SAAQC,UAAU,GAAIC,mBAAoB,OAAO,YAAY,CAAC,GAAI,OAAO,CAAC,MAAM,OAAO,CAAC,IAAI;AAAA,IAC1FC,mBAAoB,QAAQ;AAAA,MAC1B,MAAM;AAAA,MACN,GAAG;AAAA,IACT,GAAO,MAAM,EAAE;AAAA,EACf,EAAK,CAAC;AACN;AACA,MAAA,qBAAe,EAAE,OAAc;;;;;;;;;;ACwHjB,iBAAa;AAMX,eAAA;AAEhB,UAAM,KAAK,eAAe,IAAI;;;;;;;;;QA/IpB,IAAG;AAAA,iBAAa;AAAA,QAAJ,KAAI;AAAA,MAAA;;QAEd,OAAM;AAAA,QAAkB,SAAQ;AAAA,MAAA;yBAAtC,CAAiE,GAAAT,QAAAC,UAAA,aAAA;;;;;8BAAlB,aAAW;AAAA,YAAA;AAAA;;;;;;AAM7C,YAAAkJ,mBAAA,qBAAA,EAAA,aAAW,QAAI,MAAA,OAAA,CAAA;;;QAMpB,OAAM;AAAA,QAAW,SAAQ;AAAA,MAAA;yBAA/B,CAAsD,GAAAnJ,QAAAC,UAAA,aAAA;;;;;8BAAd,SAAO;AAAA,YAAA;AAAA;;;;;;QAG/B,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA6D,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAA/B,sBAAoB;AAAA,YAAA;AAAA;;;;;;QACxC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAwD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAA1B,iBAAe;AAAA,YAAA;AAAA;;;;;;QACnC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAgD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAlB,SAAO;AAAA,YAAA;AAAA;;;;;;QAC3B,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAmD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAArB,YAAU;AAAA,YAAA;AAAA;;;;;;QAKxC,OAAM;AAAA,QAAW,SAAQ;AAAA,MAAA;yBAA/B,CAAwD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAhB,WAAS;AAAA,YAAA;AAAA;;;;;;QAGjC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA8D,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAhC,uBAAqB;AAAA,YAAA;AAAA;;;;;;QACzC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA2D,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAA7B,oBAAkB;AAAA,YAAA;AAAA;;;;;;QACtC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA8D,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAhC,uBAAqB;AAAA,YAAA;AAAA;;;;;;QACzC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAqD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAvB,cAAY;AAAA,YAAA;AAAA;;;;;;QAK1C,OAAM;AAAA,QAAW,SAAQ;AAAA,MAAA;yBAA/B,CAAwD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAhB,WAAS;AAAA,YAAA;AAAA;;;;;;QAGjC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAuD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAzB,gBAAc;AAAA,YAAA;AAAA;;;;;;QAClC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA6C,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAf,MAAI;AAAA,YAAA;AAAA;;;;;;QACxB,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAiD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAnB,UAAQ;AAAA,YAAA;AAAA;;;;;;QAC5B,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA4D,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAA9B,qBAAmB;AAAA,YAAA;AAAA;;;;;;QAKjD,OAAM;AAAA,QAAW,SAAQ;AAAA,MAAA;yBAA/B,CAAwD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAhB,WAAS;AAAA,YAAA;AAAA;;;;;;QAGjC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA0D,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAA5B,mBAAiB;AAAA,YAAA;AAAA;;;;;;QACrC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA0D,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAA5B,mBAAiB;AAAA,YAAA;AAAA;;;;;;QACrC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAoD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAtB,aAAW;AAAA,YAAA;AAAA;;;;;;QAC/B,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAmD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAArB,YAAU;AAAA,YAAA;AAAA;;;;;;QAKxC,OAAM;AAAA,QAAW,SAAQ;AAAA,MAAA;yBAA/B,CAAiE,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAzB,oBAAkB;AAAA,YAAA;AAAA;;;;;;QAG1C,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAqD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAvB,cAAY;AAAA,YAAA;AAAA;;;;;;QAChC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAuD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAzB,gBAAc;AAAA,YAAA;AAAA;;;;;;QAClC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAAyD,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAA3B,kBAAgB;AAAA,YAAA;AAAA;;;;;;QACpC,OAAM;AAAA,QAAO,IAAG;AAAA,MAAA;yBAA1B,CAA+D,GAAAD,QAAAC,UAAA,aAAA;;;;;8BAAjC,wBAAsB;AAAA,YAAA;AAAA;;;;;AAMtD,YAAAkJ,mBAAA,iBAAA,EAAA,OAAM,eAAW;AAAA,yBAAvB,CAAkF,GAAAnJ,QAAAC,UAAA,aAAA;;AAAjDD,mBAAA,KAAA+I,gBAAA,oBAAA,QAAO,YAAA,CAAW,CAAA,qBAAA;AAAA;;cAA3BM,gBAAA,OAAEL,iBAAA,oBAAO,KAAA,GAAO,YAAA,KAAgB,uBAAmB,CAAA;AAAA,YAAA;AAAA;;;;;AAG/D,YAAAG,mBAAA,qBAAA,EAAA,OAAM,iBAAa;AAAA,yBAA7B,CAA4E,GAAAnJ,QAAAC,UAAA,aAAA;;;;;cAA7CG,YAAiC,WAA9B,4BAA0B;AAAA,YAAA;AAAA;;;;;;yBAG5D,CAKO,GAAAJ,QAAAC,UAAA,aAAA;;;;;8BALD,MACD;AAAA,cAAAG,YAAK,IAAA;AAAA,cACRA,YAA0B,WAAvB,qBAAmB;AAAA,cAAIA,YAAK,IAAA;AAAA,cAC/BA,YAA0F,KAAA;AAAA,gBAAvF,OAAM;AAAA,gBAAc,MAAK;AAAA,cAAA,GAAkC,0BAAwB;AAAA,cAAIA,YAAK,IAAA;AAAA,8BAAA,qBAEjG;AAAA,YAAA;AAAA;;;;;;QAMc,IAAG;AAAA,QAAK,UAAU;AAAA,QAAM,QAAO;AAAA,QAAS,cAAW;AAAA,MAAA;yBAA7D,CAAiG,GAAAJ,QAAAC,UAAA,aAAA;;;;;cAA1BG,YAAe,sBAAA;AAAA,YAAA;AAAA;;;;;;QAG5E,IAAG;AAAA,QAAK,UAAU;AAAA,QAAM,QAAO;AAAA,QAAS,cAAW;AAAA,MAAA;yBAA7D,CAAmG,GAAAJ,QAAAC,UAAA,aAAA;;;;;cAA3BG,YAAgB,uBAAA;AAAA,YAAA;AAAA;;;;;;QAOxF,SAAQ;AAAA,QAAS,OAAM;AAAA,MAAA;yBAA7B,CA8BO,GAAAJ,QAAAC,UAAA,aAAA;;;;;8BA9BmC,mBACxB;AAAA,cAAAG,YAAK,IAAA;AAAA,cAAAA,YAAK,IAAA;AAAA,8BAAA,i/EAmBQ;AAAA,cAAAA,YAAK,IAAA;AAAA,cAAAA,YAAK,IAAA;AAAA,8BAAA,eAEhC;AAAA,cAAAA,YAAK,IAAA;AAAA,cAAAA,YAAK,IAAA;AAAA,8BAAA,0oBAK8D;AAAA,cAAAA,YAAK,IAAA;AAAA,cAAAA,YAAK,IAAA;AAAA,8BAAA,wDAGhG;AAAA,YAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5HN,iBAAA;AAYA,UAAA,YAAA,IAAA;AACA,UAAA,kBAAA,IAAA;AACA,UAAA,YAAA,IAAA;AAEA,YAAA;AAAA,MACA,eAAA,QAAA,SAAA;AAAA,IACA,CAAA;AAEA,YAAA;AAAA,MAAA,OAAA;AAAA,MAAA,MAAA;AAAA,QAAA,EAAA,UAAA,YAAA,SAAA,UAAA;AAAA,QAAA,EAAA,MAAA,eAAA,SAAA,gBAAA;AAAA,QAAA,EAAA,UAAA,kBAAA,SAAA,gBAAA;AAAA,QAAA,EAAA,UAAA,YAAA,SAAA,UAAA;AAAA,QAAA,EAAA,MAAA,gBAAA,SAAA,sBAAA;AAAA,MAAA;AAAA,IAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA,UAAM,QAAQ;;iDANH2I,eAAA,MAAM,KAAK,YACZA,eAAA,MAAM,OAAO;;;;;;;;;;;;;;;;;AC8BvB,UAAM,QAAQ;;;AAhCP,YAAA,OAAA5I,eAAAJ,WAAA,EAAA,OAAM,QAAI,MAAA,CAAA,CAAA,0DAAA;UAEAN,MAAA,GAAA,GAAG;8GACc,OAAO,OAAO,UAAU,2DAC5B,OAAO,OAAO,OAAO;YAChC,OAAO,OAAO,OAAK;sDAAwB,OAAO,OAAO,SAAK,EAAA,QAAA;AAAA;;;;;;;;UAKjE,OAAO,OAAO,eAAU,KAAA;;UAC9B,OAAM;AAAA,UACN,SAAQ;AAAA,QAAA;;;;UAGO,OAAO,OAAO,eAAU,KAAA;;UAAU,OAAM;AAAA,UAAiB,SAAQ;AAAA,QAAA;;;;UAGjE,OAAO,OAAO,eAAU,KAAA;;UAAU,OAAM;AAAA,UAAc,SAAQ;AAAA,QAAA;;;;;;;;;;;;;;;;;;;ACSvF,UAAM,iBAAgJ,MAAM;AAC5J,UAAM,UAAU,WAAA;AACE,YAAQ,eAAA;AAKO,YAAQ,WAAW;AACpD,UAAM,iBAAiB;AACvB,YAAQ,iBAAiB,UAAU;AACnB,YAAQ,MAAM,aAAa,CAAC,UAAU,MAAM,IAAI,CAAC,SAAS,KAAA,CAAM,GAAG,WAAW;AAI9F,UAAM,QAAQ,SAAA;AACd,UAAM,cAAoC,MAAM,SAAS,CAAC,QAAQ,WAAW;AAE7E,oBAAgB,CAAC,KAAK,QAAQ,SAAS;AACrC,cAAQ,MAAM,SAAS,aAAa,KAAK,QAAQ,IAAI,EAAE,MAAM,CAAC,cAAc,QAAQ,MAAM,oCAAoC,SAAS,CAAC;AAM5D;AAC1E,cAAM,IAAI,QAAQ,eAAe,MAAM,UAAU,GAAG,CAAC;AACrD,yBAAiB,MAAM,CAAC;AACxB,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AACD,UAAM,gBAAsC,QAAQ,WAAW;;;iBAzD7D,MAeW;cAdEA,MAAA,WAAA,GAAW;;qBAETA,MAAA,KAAA,GAAK;AACf,kBAAA0J,mBAAA1J,MAAA,cAAA,GAAA,EAAA,OAAOA,MAAA,KAAA,EAAA,GAAK,MAAA,OAAA,CAAA;AAAA,qBAGFA,MAAA,aAAA,GAAa;AACvB,kBAAA0J,mBAAA1J,MAAA,cAAA,GAAA,EAAA,SAASA,MAAA,aAAA,EAAA,GAAa,MAAA,OAAA,CAAA;AAAA,qBAIZA,MAAA,cAAA,GAAc;sEADpBA,MAAA,cAAA,CAAc,GAAA,MAAA,IAAA,GAAA,OAAA;AAAA;;;;;;;;;;;;;;;ACHzB,IAAI;AACoB;AACtB,UAAQ,eAAe,oBAAoB,YAAY;AACrD,UAAM,SAAS,UAAUoK,SAAa;AACtC,UAAM,OAAO,cAAc,EAAE,QAAQ,YAAY;AACjD,QAAI;AACF,YAAM,aAAa,MAAM,OAAO;AAChC,YAAM,KAAK,MAAM,SAAS,eAAe,MAAM;AAAA,IACjD,SAAS,OAAO;AACd,YAAM,KAAK,MAAM,SAAS,aAAa,KAAK;AAC5C,WAAK,QAAQ,UAAU,YAAY,KAAK;AAAA,IAC1C;AACA,QAAI,YAAY,iBAAiB;AAC/B,YAAM,IAAI,MAAM,iBAAiB;AAAA,IACnC;AACA,WAAO;AAAA,EACT;AACF;AAmDA,MAAA,UAAe,CAAC,eAAe,MAAM,UAAU;","names":["plugin","provide","plugins","createH3Error","injectHead","toArray","createRadixRouter","__executeAsync","createRouter","component","entry","headSymbol","headCore","seoMeta","title","base","router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw","getImage","baseURL","_unref","attrs","placeholder","custom","placeholderClass","tag","_mergeProps","_push","_parent","_renderSlot","_ssrRenderAttrs","_createVNode","_hoisted_1","render","_openBlock","_createElementBlock","_createElementVNode","noop","toValue$1","window","getValue","gsap","_coreInitted","_win","_doc","_docEl","_body","ScrollTrigger","_root","_normalizer","_context","_getGSAP","_getTime","_bridge","_integrate","_getProxyProp","_isViewport","_addListener","_removeListener","_onScroll","_scrollCacheFunc","cachingFunc","_getTarget","_isWithin","_getScrollFunc","_getVelocityProp","update","value","reset","getVelocity","_getEvent","_getAbsoluteMax","_setScrollTrigger","_initCore","Observer","clickCapture","_ignoreCheck","onStopFunc","onDelta","onTouchOrPointerDelta","_onDrag","_onGestureStart","_onGestureEnd","onScroll","_onWheel","_onMove","_onHover","_onHoverEnd","_onClick","_parseClamp","_keepClamp","_rafBugFix","_pointerDownHandler","_pointerUpHandler","_passThrough","_round","_windowExists","_getViewportDimension","_getBoundsFunc","_getSizeFunc","_getOffsetsFunc","_maxScroll","_iterateAutoRefresh","_isString","_isFunction","_isNumber","_isObject","_endAnimation","_callback","_getComputedStyle","_makePositionable","_setDefaults","_getBounds","_getSize","_getLabelRatioArray","_getClosestLabel","_snapDirectional","a","_getLabelAtDirection","_multiListener","_wheelListener","_offsetToPx","_createMarker","color","_positionMarker","_sync","_setBaseDimensions","_onResize","_softRefresh","_dispatch","_revertRecorded","_revertAll","_clearScrollMemory","_queueRefreshAll","_refresh100vh","_hideAllMarkers","_refreshAll","_updateAll","_swapPinOut","_swapPinIn","_setState","_getState","_copyState","_parsePosition","_reparent","_interruptionTracker","_shiftMarker","_getTweenCreator","getTween","offset","cs","prevProgress","snap","h","proxyCallback","_clampScrollAndGetDurationMultiplier","_allowNativePanning","_nestedScroll","_inputObserver","_captureInputs","_getScrollNormalizer","resumeTouchMove","updateClamps","removeContentOffset","ignoreDrag","onResize","self","ref","isMobile","_ssrRenderList","_ssrInterpolate","_toDisplayString","_ssrRenderClass","_ssrRenderStyle","_ssrRenderComponent","idx","_createTextVNode","useScript","useScript$1","_useScript","useVueRouterRoute","layout","layout2","defaultLayoutTransition","RootComponent"],"sources":["../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Ffetch.mjs","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Fglobal-polyfills.mjs","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Fnuxt.config.mjs","../../../node_modules/nuxt/dist/app/nuxt.js","../../../node_modules/nuxt/dist/app/components/injections.js","../../../node_modules/nuxt/dist/app/utils.js","../../../node_modules/nuxt/dist/app/composables/router.js","../../../node_modules/nuxt/dist/app/composables/error.js","../../../node_modules/@unhead/vue/dist/shared/vue.BYLJNEcq.mjs","../../../node_modules/nuxt/dist/head/runtime/plugins/unhead.js","../../../node_modules/nuxt/dist/pages/runtime/utils.js","../../../node_modules/nuxt/dist/app/composables/manifest.js","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Froutes.mjs","../../../node_modules/nuxt/dist/app/components/utils.js","../../../node_modules/nuxt/dist/pages/runtime/router.options.js","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Frouter.options.mjs","../../../node_modules/nuxt/dist/pages/runtime/validate.js","../../../node_modules/nuxt/dist/app/middleware/manifest-route-rule.js","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Fmiddleware.mjs","../../../node_modules/nuxt/dist/pages/runtime/plugins/router.js","../../../node_modules/nuxt/dist/head/runtime/composables.js","../../../node_modules/nuxt/dist/app/components/server-placeholder.js","../../../node_modules/nuxt/dist/app/components/client-only.js","../../../node_modules/nuxt/dist/app/composables/ready.js","../../../node_modules/nuxt/dist/app/composables/state.js","../../../node_modules/nuxt/dist/app/composables/ssr.js","../../../node_modules/nuxt/dist/app/composables/cookie.js","../../../node_modules/nuxt/dist/app/composables/payload.js","../../../node_modules/nuxt/dist/app/components/nuxt-link.js","../../../node_modules/nuxt-site-config/dist/runtime/app/plugins/0.siteConfig.js","../../../node_modules/nuxt/dist/app/plugins/revive-payload.server.js","../../../app/assets/icon/appstore.svg?nuxt_component=async&nuxt_component_name=IconAppstore&nuxt_component_export=default","../../../app/assets/icon/arrow.svg?nuxt_component=async&nuxt_component_name=IconArrow&nuxt_component_export=default","../../../app/assets/icon/arrowslide.svg?nuxt_component=async&nuxt_component_name=IconArrowslide&nuxt_component_export=default","../../../app/assets/icon/chevron.svg?nuxt_component=async&nuxt_component_name=IconChevron&nuxt_component_export=default","../../../app/assets/icon/circlecenter.svg?nuxt_component=async&nuxt_component_name=IconCirclecenter&nuxt_component_export=default","../../../app/assets/icon/circleleft.svg?nuxt_component=async&nuxt_component_name=IconCircleleft&nuxt_component_export=default","../../../app/assets/icon/circleright.svg?nuxt_component=async&nuxt_component_name=IconCircleright&nuxt_component_export=default","../../../app/assets/icon/close.svg?nuxt_component=async&nuxt_component_name=IconClose&nuxt_component_export=default","../../../app/assets/icon/googleplay.svg?nuxt_component=async&nuxt_component_name=IconGoogleplay&nuxt_component_export=default","../../../app/assets/icon/hamburger.svg?nuxt_component=async&nuxt_component_name=IconHamburger&nuxt_component_export=default","../../../app/assets/icon/linkedin.svg?nuxt_component=async&nuxt_component_name=IconLinkedin&nuxt_component_export=default","../../../app/assets/icon/logotext.svg?nuxt_component=async&nuxt_component_name=IconLogotext&nuxt_component_export=default","../../../app/assets/icon/quote.svg?nuxt_component=async&nuxt_component_name=IconQuote&nuxt_component_export=default","../../../app/assets/icon/twitter.svg?nuxt_component=async&nuxt_component_name=IconTwitter&nuxt_component_export=default","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Fcomponents.plugin.mjs","../../../node_modules/nuxt-site-config/dist/runtime/app/composables/useSiteConfig.js","../../../node_modules/nuxt-seo-utils/dist/runtime/app/plugins/siteConfig.js","../../../node_modules/nuxt-seo-utils/dist/runtime/app/plugins/inferSeoMetaPlugin.js","../../../node_modules/nuxt-seo-utils/dist/runtime/app/plugins/titles.js","../../../node_modules/nuxt-schema-org/dist/runtime/app/utils/config.js","../../../node_modules/nuxt-schema-org/dist/runtime/app/composables/useSchemaOrg.js","../../../node_modules/site-config-stack/dist/urls.mjs","../../../node_modules/nuxt-site-config/dist/runtime/app/composables/useNitroOrigin.js","../../../node_modules/nuxt-site-config/dist/runtime/app/composables/utils.js","../../../node_modules/nuxt-schema-org/dist/runtime/app/utils/shared.js","../../../node_modules/nuxt-schema-org/dist/runtime/app/plugins/defaults.js","../../../node_modules/nuxt-schema-org/dist/runtime/app/plugins/init.js","../../../node_modules/@nuxtjs/robots/dist/runtime/app/plugins/robot-meta.server.js","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Fnuxtjs-device.mjs","../../../node_modules/@nuxtjs/device/dist/runtime/generateFlags.js","../../../node_modules/@nuxtjs/device/dist/runtime/plugin.js","../../../node_modules/nuxt-seo-utils/dist/runtime/app/plugins/1.absoluteImageUrls.server.js","../../../node_modules/nuxt-seo-utils/dist/runtime/app/plugins/0.routeRules.js","../../../node_modules/nuxt-seo-utils/dist/runtime/app/logic/applyDefaults.js","../../../node_modules/nuxt-seo-utils/dist/runtime/app/plugins/defaults.js","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Fplugins.server.mjs","../../../node_modules/nuxt/dist/head/runtime/components.js","../../../node_modules/@nuxt/image/dist/runtime/utils/prerender.js","../../../node_modules/@nuxt/image/dist/runtime/utils/index.js","../../../node_modules/@nuxt/image/dist/runtime/utils/meta.js","../../../node_modules/@nuxt/image/dist/runtime/image.js","../../../node_modules/@nuxt/image/dist/runtime/providers/ipx.js","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Fimage-options.mjs","../../../node_modules/@nuxt/image/dist/runtime/composables.js","../../../node_modules/@nuxt/image/dist/runtime/components/_base.js","../../../node_modules/@nuxt/image/dist/runtime/components/NuxtPicture.vue","../../../node_modules/@nuxt/image/dist/runtime/components/NuxtImg.vue","../../../app/stores/media.ts","../../../node_modules/@nuxtjs/device/dist/runtime/composables/useDevice.js","../../../app/components/media/MediaImg.vue","../../../app/components/text/Text.vue","../../../app/components/section/SectionContact.vue","../../../app/assets/icon/logotext.svg","../../../app/components/text/TextLogo.vue","../../../app/assets/icon/chevron.svg","../../../app/components/button/ButtonCta.vue","../../../app/components/button/ButtonMenu.vue","../../../app/composables/states.ts","../../../node_modules/@vueuse/shared/index.mjs","../../../node_modules/@vueuse/core/index.mjs","../../../node_modules/gsap/Observer.js","../../../node_modules/gsap/ScrollTrigger.js","../../../app/composables/useScreenQuery.ts","../../../app/utils/constants.ts","../../../app/components/base/BaseHeader.vue","../../../node_modules/nuxt/dist/app/composables/loading-indicator.js","../../../app/components/base/BaseIndicator.vue","../../../app/components/base/BasePreloader.vue","../../../node_modules/@nuxt/scripts/dist/runtime/composables/useScriptTriggerConsent.js","../../../node_modules/@unhead/vue/dist/shared/vue.cHBs6zvy.mjs","../../../node_modules/@nuxt/scripts/dist/runtime/composables/useScript.js","../../../node_modules/@nuxt/scripts/dist/runtime/validation/mock.js","../../../node_modules/@nuxt/scripts/dist/runtime/utils.js","../../../node_modules/@nuxt/scripts/dist/runtime/registry/google-analytics.js","../../../app/components/popup/PopupCookies.vue","../../../virtual:nuxt:%2FUsers%2Fmarina%2FTrabajos%2FPia%2Fsolstrategies%2Frepository%2F.nuxt%2Flayouts.mjs","../../../node_modules/nuxt/dist/app/components/nuxt-layout.js","../../../node_modules/nuxt/dist/app/components/route-provider.js","../../../node_modules/nuxt/dist/pages/runtime/page.js","../../../app/assets/icon/arrow.svg","../../../app/assets/icon/twitter.svg","../../../app/assets/icon/linkedin.svg","../../../app/components/base/BaseFooter.vue","../../../app/app.vue","../../../app/components/base/BaseError.vue","../../../app/error.vue","../../../node_modules/nuxt/dist/app/components/nuxt-root.vue","../../../node_modules/nuxt/dist/app/entry.js"],"sourcesContent":["import { $fetch } from 'ofetch'\nimport { baseURL } from '#internal/nuxt/paths'\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  })\n}","\nif (!(\"global\" in globalThis)) {\n  globalThis.global = globalThis;\n}","export const appPageTransition = {\"name\":\"page\",\"mode\":\"out-in\"}\n\nexport const appHead = {\"link\":[{\"rel\":\"icon\",\"type\":\"image/x-icon\",\"href\":\"/favicon.ico\"},{\"rel\":\"apple-touch-icon\",\"sizes\":\"180x180\",\"href\":\"/apple-touch-icon-180x180.png\"},{\"rel\":\"manifest\",\"href\":\"/manifest.webmanifest\"}],\"meta\":[{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},{\"charset\":\"utf-8\"},{\"name\":\"description\",\"content\":\"A publicly traded company providing infrastructure for the Solana blockchain ecosystem, the fastest growing project in crypto.\"},{\"name\":\"author\",\"content\":\"SOL STRATEGIES\"},{\"property\":\"og:type\",\"content\":\"website\"},{\"name\":\"msapplication-TileColor\",\"content\":\"#000000\"},{\"name\":\"theme-color\",\"content\":\"#000000\"}],\"style\":[],\"script\":[],\"noscript\":[],\"title\":\"SOL STRATEGIES\",\"charset\":\"utf-8\",\"viewport\":\"width=device-width, initial-scale=1\",\"htmlAttrs\":{}}\n\nexport const appBaseURL = \"/\"\n\nexport const appBuildAssetsDir = \"/_nuxt/\"\n\nexport const appCdnURL = \"\"\n\nexport const appLayoutTransition = false\n\nexport const appViewTransition = false\n\nexport const appKeepalive = false\n\nexport const appRootId = \"__nuxt\"\n\nexport const appRootTag = \"div\"\n\nexport const appRootAttrs = {\"id\":\"__nuxt\"}\n\nexport const appTeleportTag = \"div\"\n\nexport const appTeleportId = \"teleports\"\n\nexport const appTeleportAttrs = {\"id\":\"teleports\"}\n\nexport const appSpaLoaderTag = \"div\"\n\nexport const appSpaLoaderAttrs = {\"id\":\"__nuxt-loader\"}\n\nexport const renderJsonPayloads = true\n\nexport const componentIslands = false\n\nexport const payloadExtraction = true\n\nexport const cookieStore = true\n\nexport const appManifest = true\n\nexport const remoteComponentIslands = false\n\nexport const selectiveClient = false\n\nexport const devPagesDir = null\n\nexport const devRootDir = null\n\nexport const devLogs = false\n\nexport const nuxtLinkDefaults = {\"componentName\":\"NuxtLink\",\"prefetch\":true,\"prefetchOn\":{\"visibility\":true}}\n\nexport const asyncDataDefaults = {\"deep\":false}\n\nexport const fetchDefaults = {}\n\nexport const vueAppRootContainer = '#__nuxt'\n\nexport const viewTransition = false\n\nexport const appId = \"nuxt-app\"\n\nexport const outdatedBuildInterval = 3600000\n\nexport const multiApp = false\n\nexport const chunkErrorEvent = \"vite:preloadError\"\n\nexport const crawlLinks = false\n\nexport const spaLoadingTemplateOutside = true\n\nexport const purgeCachedData = true\n\nexport const granularCachedData = true\n\nexport const pendingWhenIdle = false\n\nexport const alwaysRunFetchOnKeyChange = false","import { effectScope, getCurrentInstance, getCurrentScope, hasInjectionContext, reactive, shallowReactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nimport { appId, chunkErrorEvent, multiApp } from \"#build/nuxt.config.mjs\";\nexport function getNuxtAppCtx(id = appId || \"nuxt-app\") {\n  return getContext(id, {\n    asyncContext: !!__NUXT_ASYNC_CONTEXT__ && import.meta.server\n  });\n}\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  let hydratingCount = 0;\n  const nuxtApp = {\n    _id: options.id || appId || \"nuxt-app\",\n    _scope: effectScope(),\n    provide: void 0,\n    versions: {\n      get nuxt() {\n        return __NUXT_VERSION__;\n      },\n      get vue() {\n        return nuxtApp.vueApp.version;\n      }\n    },\n    payload: shallowReactive({\n      ...options.ssrContext?.payload || {},\n      data: shallowReactive({}),\n      state: reactive({}),\n      once: /* @__PURE__ */ new Set(),\n      _errors: shallowReactive({})\n    }),\n    static: {\n      data: {}\n    },\n    runWithContext(fn) {\n      if (nuxtApp._scope.active && !getCurrentScope()) {\n        return nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn));\n      }\n      return callWithNuxt(nuxtApp, fn);\n    },\n    isHydrating: import.meta.client,\n    deferHydration() {\n      if (!nuxtApp.isHydrating) {\n        return () => {\n        };\n      }\n      hydratingCount++;\n      let called = false;\n      return () => {\n        if (called) {\n          return;\n        }\n        called = true;\n        hydratingCount--;\n        if (hydratingCount === 0) {\n          nuxtApp.isHydrating = false;\n          return nuxtApp.callHook(\"app:suspense:resolve\");\n        }\n      };\n    },\n    _asyncDataPromises: {},\n    _asyncData: shallowReactive({}),\n    _payloadRevivers: {},\n    ...options\n  };\n  if (import.meta.server) {\n    nuxtApp.payload.serverRendered = true;\n  }\n  if (import.meta.server && nuxtApp.ssrContext) {\n    nuxtApp.payload.path = nuxtApp.ssrContext.url;\n    nuxtApp.ssrContext.nuxt = nuxtApp;\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.ssrContext.config = {\n      public: nuxtApp.ssrContext.runtimeConfig.public,\n      app: nuxtApp.ssrContext.runtimeConfig.app\n    };\n  }\n  if (import.meta.client) {\n    const __NUXT__ = multiApp ? window.__NUXT__?.[nuxtApp._id] : window.__NUXT__;\n    if (__NUXT__) {\n      for (const key in __NUXT__) {\n        switch (key) {\n          case \"data\":\n          case \"state\":\n          case \"_errors\":\n            Object.assign(nuxtApp.payload[key], __NUXT__[key]);\n            break;\n          default:\n            nuxtApp.payload[key] = __NUXT__[key];\n        }\n      }\n    }\n  }\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  if (import.meta.server) {\n    const contextCaller = async function(hooks, args) {\n      for (const hook of hooks) {\n        await nuxtApp.runWithContext(() => hook(...args));\n      }\n    };\n    nuxtApp.hooks.callHook = (name, ...args) => nuxtApp.hooks.callHookWith(contextCaller, name, ...args);\n  }\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (import.meta.client) {\n    if (chunkErrorEvent) {\n      window.addEventListener(chunkErrorEvent, (event) => {\n        nuxtApp.callHook(\"app:chunkError\", { error: event.payload });\n        if (event.payload.message.includes(\"Unable to preload CSS\")) {\n          event.preventDefault();\n        }\n      });\n    }\n    window.useNuxtApp ||= useNuxtApp;\n    const unreg = nuxtApp.hook(\"app:error\", (...args) => {\n      console.error(\"[nuxt] error caught during app initialization\", ...args);\n    });\n    nuxtApp.hook(\"app:mounted\", unreg);\n  }\n  const runtimeConfig = import.meta.server ? options.ssrContext.runtimeConfig : nuxtApp.payload.config;\n  nuxtApp.provide(\"config\", import.meta.client && import.meta.dev ? wrappedConfig(runtimeConfig) : runtimeConfig);\n  return nuxtApp;\n}\nexport function registerPluginHooks(nuxtApp, plugin) {\n  if (plugin.hooks) {\n    nuxtApp.hooks.addHooks(plugin.hooks);\n  }\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (typeof plugin === \"function\") {\n    const { provide } = await nuxtApp.runWithContext(() => plugin(nuxtApp)) || {};\n    if (provide && typeof provide === \"object\") {\n      for (const key in provide) {\n        nuxtApp.provide(key, provide[key]);\n      }\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  const resolvedPlugins = /* @__PURE__ */ new Set();\n  const unresolvedPlugins = [];\n  const parallels = [];\n  let error = void 0;\n  let promiseDepth = 0;\n  async function executePlugin(plugin) {\n    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];\n    if (unresolvedPluginsForThisPlugin.length > 0) {\n      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);\n    } else {\n      const promise = applyPlugin(nuxtApp, plugin).then(async () => {\n        if (plugin._name) {\n          resolvedPlugins.add(plugin._name);\n          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {\n            if (dependsOn.has(plugin._name)) {\n              dependsOn.delete(plugin._name);\n              if (dependsOn.size === 0) {\n                promiseDepth++;\n                await executePlugin(unexecutedPlugin);\n              }\n            }\n          }));\n        }\n      }).catch((e) => {\n        if (!plugin.parallel && !nuxtApp.payload.error) {\n          throw e;\n        }\n        error ||= e;\n      });\n      if (plugin.parallel) {\n        parallels.push(promise);\n      } else {\n        await promise;\n      }\n    }\n  }\n  for (const plugin of plugins) {\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {\n      continue;\n    }\n    registerPluginHooks(nuxtApp, plugin);\n  }\n  for (const plugin of plugins) {\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {\n      continue;\n    }\n    await executePlugin(plugin);\n  }\n  await Promise.all(parallels);\n  if (promiseDepth) {\n    for (let i = 0; i < promiseDepth; i++) {\n      await Promise.all(parallels);\n    }\n  }\n  if (error) {\n    throw nuxtApp.payload.error || error;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtPlugin(plugin) {\n  if (typeof plugin === \"function\") {\n    return plugin;\n  }\n  const _name = plugin._name || plugin.name;\n  delete plugin.name;\n  return Object.assign(plugin.setup || (() => {\n  }), plugin, { [NuxtPluginIndicator]: true, _name });\n}\nexport const definePayloadPlugin = defineNuxtPlugin;\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  const nuxtAppCtx = getNuxtAppCtx(nuxt._id);\n  if (import.meta.server) {\n    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt, fn));\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return nuxt.vueApp.runWithContext(fn);\n  }\n}\nexport function tryUseNuxtApp(id) {\n  let nuxtAppInstance;\n  if (hasInjectionContext()) {\n    nuxtAppInstance = getCurrentInstance()?.appContext.app.$nuxt;\n  }\n  nuxtAppInstance ||= getNuxtAppCtx(id).tryUse();\n  return nuxtAppInstance || null;\n}\nexport function useNuxtApp(id) {\n  const nuxtAppInstance = tryUseNuxtApp(id);\n  if (!nuxtAppInstance) {\n    if (import.meta.dev) {\n      throw new Error(\"[nuxt] A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function. This is probably not a Nuxt bug. Find out more at `https://nuxt.com/docs/guide/concepts/auto-imports#vue-and-nuxt-composables`.\");\n    } else {\n      throw new Error(\"[nuxt] instance unavailable\");\n    }\n  }\n  return nuxtAppInstance;\n}\n// @__NO_SIDE_EFFECTS__\nexport function useRuntimeConfig(_event) {\n  return useNuxtApp().$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\nconst loggedKeys = /* @__PURE__ */ new Set();\nfunction wrappedConfig(runtimeConfig) {\n  if (!import.meta.dev || import.meta.server) {\n    return runtimeConfig;\n  }\n  const keys = Object.keys(runtimeConfig).map((key) => `\\`${key}\\``);\n  const lastKey = keys.pop();\n  return new Proxy(runtimeConfig, {\n    get(target, p, receiver) {\n      if (typeof p === \"string\" && p !== \"public\" && !(p in target) && !p.startsWith(\"__v\")) {\n        if (!loggedKeys.has(p)) {\n          loggedKeys.add(p);\n          console.warn(`[nuxt] Could not access \\`${p}\\`. The only available runtime config keys on the client side are ${keys.join(\", \")} and ${lastKey}. See https://nuxt.com/docs/guide/going-further/runtime-config for more information.`);\n        }\n      }\n      return Reflect.get(target, p, receiver);\n    }\n  });\n}\n","export const LayoutMetaSymbol = Symbol(\"layout-meta\");\nexport const PageRouteSymbol = Symbol(\"route\");\n","import { captureStackTrace } from \"errx\";\nexport function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nconst distURL = import.meta.url.replace(/\\/app\\/.*$/, \"/\");\nexport function getUserTrace() {\n  if (!import.meta.dev) {\n    return [];\n  }\n  const trace = captureStackTrace();\n  const start = trace.findIndex((entry) => !entry.source.startsWith(distURL));\n  const end = [...trace].reverse().findIndex((entry) => !entry.source.includes(\"node_modules\") && !entry.source.startsWith(distURL));\n  if (start === -1 || end === -1) {\n    return [];\n  }\n  return trace.slice(start, -end).map((i) => ({\n    ...i,\n    source: i.source.replace(/^file:\\/\\//, \"\")\n  }));\n}\nexport function getUserCaller() {\n  if (!import.meta.dev) {\n    return null;\n  }\n  const { source, line, column } = captureStackTrace().find((entry) => !entry.source.startsWith(distURL)) ?? {};\n  if (!source) {\n    return null;\n  }\n  return {\n    source: source.replace(/^file:\\/\\//, \"\"),\n    line,\n    column\n  };\n}\n","import { getCurrentInstance, hasInjectionContext, inject, onScopeDispose } from \"vue\";\nimport { sanitizeStatusCode } from \"h3\";\nimport { hasProtocol, isScriptProtocol, joinURL, parseQuery, parseURL, withQuery } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { PageRouteSymbol } from \"../components/injections.js\";\nimport { createError, showError } from \"./error.js\";\nimport { getUserTrace } from \"../utils.js\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (import.meta.dev && !getCurrentInstance() && isProcessingMiddleware()) {\n    const middleware = useNuxtApp()._processingMiddleware;\n    const trace = getUserTrace().map(({ source, line, column }) => `at ${source}:${line}:${column}`).join(\"\\n\");\n    console.warn(`[nuxt] \\`useRoute\\` was called within middleware${typeof middleware === \"string\" ? ` (\\`${middleware}\\`)` : \"\"}. This may lead to misleading results. Instead, use the (to, from) arguments passed to the middleware to access the new and old routes. Learn more: https://nuxt.com/docs/4.x/guide/directory-structure/app/middleware#accessing-route-in-middleware` + (\"\\n\" + trace));\n  }\n  if (hasInjectionContext()) {\n    return inject(PageRouteSymbol, useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const onBeforeRouteLeave = (guard) => {\n  const unsubscribe = useRouter().beforeEach((to, from, next) => {\n    if (to === from) {\n      return;\n    }\n    return guard(to, from, next);\n  });\n  onScopeDispose(unsubscribe);\n};\nexport const onBeforeRouteUpdate = (guard) => {\n  const unsubscribe = useRouter().beforeEach(guard);\n  onScopeDispose(unsubscribe);\n};\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtRouteMiddleware(middleware) {\n  return middleware;\n}\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const global = options.global || typeof name !== \"string\";\n  const mw = typeof name !== \"string\" ? name : middleware;\n  if (!mw) {\n    console.warn(\"[nuxt] No route middleware passed to `addRouteMiddleware`.\", name);\n    return;\n  }\n  if (global) {\n    nuxtApp._middleware.global.push(mw);\n  } else {\n    nuxtApp._middleware.named[name] = mw;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return false;\n  }\n  return false;\n};\nconst URL_QUOTE_RE = /\"/g;\nexport const navigateTo = (to, options) => {\n  to ||= \"/\";\n  const toPath = typeof to === \"string\" ? to : \"path\" in to ? resolveRouteObject(to) : useRouter().resolve(to).href;\n  if (import.meta.client && options?.open) {\n    const { target = \"_blank\", windowFeatures = {} } = options.open;\n    const features = Object.entries(windowFeatures).filter(([_, value]) => value !== void 0).map(([feature, value]) => `${feature.toLowerCase()}=${value}`).join(\", \");\n    open(toPath, target, features);\n    return Promise.resolve();\n  }\n  const isExternalHost = hasProtocol(toPath, { acceptRelative: true });\n  const isExternal = options?.external || isExternalHost;\n  if (isExternal) {\n    if (!options?.external) {\n      throw new Error(\"Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.\");\n    }\n    const { protocol } = new URL(toPath, import.meta.client ? window.location.href : \"http://localhost\");\n    if (protocol && isScriptProtocol(protocol)) {\n      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`);\n    }\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (import.meta.client && !isExternal && inMiddleware) {\n    if (options?.replace) {\n      if (typeof to === \"string\") {\n        const { pathname, search, hash } = parseURL(to);\n        return {\n          path: pathname,\n          ...search && { query: parseQuery(search) },\n          ...hash && { hash },\n          replace: true\n        };\n      }\n      return { ...to, replace: true };\n    }\n    return to;\n  }\n  const router = useRouter();\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (nuxtApp.ssrContext) {\n      const fullPath = typeof to === \"string\" || isExternal ? toPath : router.resolve(to).fullPath || \"/\";\n      const location2 = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath);\n      const redirect = async function(response) {\n        await nuxtApp.callHook(\"app:redirected\");\n        const encodedLoc = location2.replace(URL_QUOTE_RE, \"%22\");\n        const encodedHeader = encodeURL(location2, isExternalHost);\n        nuxtApp.ssrContext._renderResponse = {\n          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),\n          body: `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`,\n          headers: { location: encodedHeader }\n        };\n        return response;\n      };\n      if (!isExternal && inMiddleware) {\n        router.afterEach((final) => final.fullPath === fullPath ? redirect(false) : void 0);\n        return to;\n      }\n      return redirect(!inMiddleware ? void 0 : (\n        /* abort route navigation */\n        false\n      ));\n    }\n  }\n  if (isExternal) {\n    nuxtApp._scope.stop();\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    if (inMiddleware) {\n      if (!nuxtApp.isHydrating) {\n        return false;\n      }\n      return new Promise(() => {\n      });\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (import.meta.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (!err) {\n    return false;\n  }\n  err = createError(err);\n  if (err.fatal) {\n    useNuxtApp().runWithContext(() => showError(err));\n  }\n  throw err;\n};\nexport const setPageLayout = (layout) => {\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (import.meta.dev && getCurrentInstance() && nuxtApp.payload.state._layout !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    nuxtApp.payload.state._layout = layout;\n  }\n  if (import.meta.dev && nuxtApp.isHydrating && nuxtApp.payload.serverRendered && nuxtApp.payload.state._layout !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || import.meta.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\nexport function resolveRouteObject(to) {\n  return withQuery(to.path || \"\", to.query || {}) + (to.hash || \"\");\n}\nexport function encodeURL(location2, isExternalHost = false) {\n  const url = new URL(location2, \"http://localhost\");\n  if (!isExternalHost) {\n    return url.pathname + url.search + url.hash;\n  }\n  if (location2.startsWith(\"//\")) {\n    return url.toString().replace(url.protocol, \"\");\n  }\n  return url.toString();\n}\n","import { createError as createH3Error } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRouter } from \"./router.js\";\nexport const NUXT_ERROR_SIGNATURE = \"__nuxt_error\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (error) => {\n  const nuxtError = createError(error);\n  try {\n    const nuxtApp = useNuxtApp();\n    const error2 = useError();\n    if (import.meta.client) {\n      nuxtApp.hooks.callHook(\"app:error\", nuxtError);\n    }\n    error2.value ||= nuxtError;\n  } catch {\n    throw nuxtError;\n  }\n  return nuxtError;\n};\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await useRouter().replace(options.redirect);\n  }\n  error.value = void 0;\n};\nexport const isNuxtError = (error) => !!error && typeof error === \"object\" && NUXT_ERROR_SIGNATURE in error;\nexport const createError = (error) => {\n  const nuxtError = createH3Error(error);\n  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {\n    value: true,\n    configurable: false,\n    writable: false\n  });\n  return nuxtError;\n};\n","import { SafeInputPlugin, FlatMetaPlugin } from 'unhead/plugins';\nimport { walkResolver } from 'unhead/utils';\nimport { hasInjectionContext, inject, ref, watchEffect, getCurrentInstance, onBeforeUnmount, onDeactivated, onActivated } from 'vue';\nimport { V as VueResolver } from './vue.N9zWjxoK.mjs';\n\nconst headSymbol = \"usehead\";\nfunction vueInstall(head) {\n  const plugin = {\n    install(app) {\n      app.config.globalProperties.$unhead = head;\n      app.config.globalProperties.$head = head;\n      app.provide(headSymbol, head);\n    }\n  };\n  return plugin.install;\n}\n\nfunction injectHead() {\n  if (hasInjectionContext()) {\n    const instance = inject(headSymbol);\n    if (!instance) {\n      throw new Error(\"useHead() was called without provide context, ensure you call it through the setup() function.\");\n    }\n    return instance;\n  }\n  throw new Error(\"useHead() was called without provide context, ensure you call it through the setup() function.\");\n}\nfunction useHead(input, options = {}) {\n  const head = options.head || injectHead();\n  return head.ssr ? head.push(input || {}, options) : clientUseHead(head, input, options);\n}\nfunction clientUseHead(head, input, options = {}) {\n  const deactivated = ref(false);\n  let entry;\n  watchEffect(() => {\n    const i = deactivated.value ? {} : walkResolver(input, VueResolver);\n    if (entry) {\n      entry.patch(i);\n    } else {\n      entry = head.push(i, options);\n    }\n  });\n  const vm = getCurrentInstance();\n  if (vm) {\n    onBeforeUnmount(() => {\n      entry.dispose();\n    });\n    onDeactivated(() => {\n      deactivated.value = true;\n    });\n    onActivated(() => {\n      deactivated.value = false;\n    });\n  }\n  return entry;\n}\nfunction useHeadSafe(input = {}, options = {}) {\n  const head = options.head || injectHead();\n  head.use(SafeInputPlugin);\n  options._safe = true;\n  return useHead(input, options);\n}\nfunction useSeoMeta(input = {}, options = {}) {\n  const head = options.head || injectHead();\n  head.use(FlatMetaPlugin);\n  const { title, titleTemplate, ...meta } = input;\n  return useHead({\n    title,\n    titleTemplate,\n    _flatMeta: meta\n  }, options);\n}\nfunction useServerHead(input, options = {}) {\n  return useHead(input, { ...options, mode: \"server\" });\n}\nfunction useServerHeadSafe(input, options = {}) {\n  return useHeadSafe(input, { ...options, mode: \"server\" });\n}\nfunction useServerSeoMeta(input, options = {}) {\n  return useSeoMeta(input, { ...options, mode: \"server\" });\n}\n\nexport { useHeadSafe as a, useSeoMeta as b, useServerHead as c, useServerHeadSafe as d, useServerSeoMeta as e, headSymbol as h, injectHead as i, useHead as u, vueInstall as v };\n","import { createHead as createClientHead, renderDOMHead } from \"@unhead/vue/client\";\nimport { defineNuxtPlugin } from \"#app/nuxt\";\nimport unheadOptions from \"#build/unhead-options.mjs\";\nexport default defineNuxtPlugin({\n  name: \"nuxt:head\",\n  enforce: \"pre\",\n  setup(nuxtApp) {\n    const head = import.meta.server ? nuxtApp.ssrContext.head : createClientHead(unheadOptions);\n    nuxtApp.vueApp.use(head);\n    if (import.meta.client) {\n      let pauseDOMUpdates = true;\n      const syncHead = async () => {\n        pauseDOMUpdates = false;\n        await renderDOMHead(head);\n      };\n      head.hooks.hook(\"dom:beforeRender\", (context) => {\n        context.shouldRender = !pauseDOMUpdates;\n      });\n      nuxtApp.hooks.hook(\"page:start\", () => {\n        pauseDOMUpdates = true;\n      });\n      nuxtApp.hooks.hook(\"page:finish\", () => {\n        if (!nuxtApp.isHydrating) {\n          syncHead();\n        }\n      });\n      nuxtApp.hooks.hook(\"app:error\", syncHead);\n      nuxtApp.hooks.hook(\"app:suspense:resolve\", syncHead);\n    }\n  }\n});\n","import { KeepAlive, h } from \"vue\";\nconst ROUTE_KEY_PARENTHESES_RE = /(:\\w+)\\([^)]+\\)/g;\nconst ROUTE_KEY_SYMBOLS_RE = /(:\\w+)[?+*]/g;\nconst ROUTE_KEY_NORMAL_RE = /:\\w+/g;\nconst interpolatePath = (route, match) => {\n  return match.path.replace(ROUTE_KEY_PARENTHESES_RE, \"$1\").replace(ROUTE_KEY_SYMBOLS_RE, \"$1\").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || \"\");\n};\nexport const generateRouteKey = (routeProps, override) => {\n  const matchedRoute = routeProps.route.matched.find((m) => m.components?.default === routeProps.Component.type);\n  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute));\n  return typeof source === \"function\" ? source(routeProps.route) : source;\n};\nexport const wrapInKeepAlive = (props, children) => {\n  return { default: () => import.meta.client && props ? h(KeepAlive, props === true ? {} : props, children) : children };\n};\nexport function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n","import { createMatcherFromExport, createRouter as createRadixRouter, toRouteMatcher } from \"radix3\";\nimport { defu } from \"defu\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport { buildAssetsURL } from \"#internal/nuxt/paths\";\nlet manifest;\nlet matcher;\nfunction fetchManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  if (import.meta.server) {\n    manifest = import(\n      /* webpackIgnore: true */\n      /* @vite-ignore */\n      \"#app-manifest\"\n    );\n  } else {\n    manifest = $fetch(buildAssetsURL(`builds/meta/${useRuntimeConfig().app.buildId}.json`), {\n      responseType: \"json\"\n    });\n  }\n  manifest.then((m) => {\n    matcher = createMatcherFromExport(m.matcher);\n  }).catch((e) => {\n    console.error(\"[nuxt] Error fetching app manifest.\", e);\n  });\n  return manifest;\n}\nexport function getAppManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._preloadManifest = true;\n  }\n  return manifest || fetchManifest();\n}\nexport async function getRouteRules(arg) {\n  const path = typeof arg === \"string\" ? arg : arg.path;\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._preloadManifest = true;\n    const _routeRulesMatcher = toRouteMatcher(\n      createRadixRouter({ routes: useRuntimeConfig().nitro.routeRules })\n    );\n    return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());\n  }\n  await getAppManifest();\n  if (!matcher) {\n    console.error(\"[nuxt] Error creating app manifest matcher.\", matcher);\n    return {};\n  }\n  try {\n    return defu({}, ...matcher.matchAll(path).reverse());\n  } catch (e) {\n    console.error(\"[nuxt] Error matching route rules.\", e);\n    return {};\n  }\n}\n","\nif (import.meta.hot) {\n  import.meta.hot.accept((mod) => {\n    const router = import.meta.hot.data.router\n    const generateRoutes = import.meta.hot.data.generateRoutes\n    if (!router || !generateRoutes) {\n      import.meta.hot.invalidate('[nuxt] Cannot replace routes because there is no active router. Reloading.')\n      return\n    }\n    router.clearRoutes()\n    const routes = generateRoutes(mod.default || mod)\n    function addRoutes (routes) {\n      for (const route of routes) {\n        router.addRoute(route)\n      }\n      router.replace(router.currentRoute.value.fullPath)\n    }\n    if (routes && 'then' in routes) {\n      routes.then(addRoutes)\n    } else {\n      addRoutes(routes)\n    }\n  })\n}\n\nexport function handleHotUpdate(_router, _generateRoutes) {\n  if (import.meta.hot) {\n    import.meta.hot.data ||= {}\n    import.meta.hot.data.router = _router\n    import.meta.hot.data.generateRoutes = _generateRoutes\n  }\n}\nimport { default as blogR7K7c5kcCoxSJI4Mds58uAHv_tnQDraVSPr50yRhdVoMeta } from \"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/blog.vue?macro=true\";\nimport { default as aboutS3zeCcKz01t_cP3oJqmVjmqOJSGmQf947Yt6d5PfWM0Meta } from \"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/about.vue?macro=true\";\nimport { default as indexuympEMnbVpHoFbRDFNJAzipi_PgeuOOpcHckr5zozSQMeta } from \"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/index.vue?macro=true\";\nimport { default as singleTeameTgPk_nlb5L20VzTHu332jXybGvPKISHkuDwu5yvRQwMeta } from \"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/singleTeam.vue?macro=true\";\nimport { default as investor_45relations8PSOSX3jvA2CylD6pqoxCLKjcNz_ZfbZACwkvtu30LQMeta } from \"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/investor-relations.vue?macro=true\";\nexport default [\n  {\n    name: \"blog\",\n    path: \"/blog\",\n    component: () => import(\"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/blog.vue\")\n  },\n  {\n    name: \"about\",\n    path: \"/about\",\n    component: () => import(\"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/about.vue\")\n  },\n  {\n    name: \"index\",\n    path: \"/\",\n    component: () => import(\"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/index.vue\")\n  },\n  {\n    name: \"singleTeam\",\n    path: \"/singleTeam\",\n    component: () => import(\"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/singleTeam.vue\")\n  },\n  {\n    name: \"investor-relations\",\n    path: \"/investor-relations\",\n    component: () => import(\"/Users/marina/Trabajos/Pia/solstrategies/repository/app/pages/investor-relations.vue\")\n  }\n]","import { Transition, createStaticVNode, h } from \"vue\";\nimport { isString, isPromise, isArray, isObject } from \"@vue/shared\";\nimport { START_LOCATION } from \"#build/pages\";\nexport const _wrapInTransition = (props, children) => {\n  return { default: () => import.meta.client && props ? h(Transition, props === true ? {} : props, children) : children.default?.() };\n};\nconst ROUTE_KEY_PARENTHESES_RE = /(:\\w+)\\([^)]+\\)/g;\nconst ROUTE_KEY_SYMBOLS_RE = /(:\\w+)[?+*]/g;\nconst ROUTE_KEY_NORMAL_RE = /:\\w+/g;\nfunction generateRouteKey(route) {\n  const source = route?.meta.key ?? route.path.replace(ROUTE_KEY_PARENTHESES_RE, \"$1\").replace(ROUTE_KEY_SYMBOLS_RE, \"$1\").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || \"\");\n  return typeof source === \"function\" ? source(route) : source;\n}\nexport function isChangingPage(to, from) {\n  if (to === from || from === START_LOCATION) {\n    return false;\n  }\n  if (generateRouteKey(to) !== generateRouteKey(from)) {\n    return true;\n  }\n  const areComponentsSame = to.matched.every(\n    (comp, index) => comp.components && comp.components.default === from.matched[index]?.components?.default\n  );\n  if (areComponentsSame) {\n    return false;\n  }\n  return true;\n}\nexport function createBuffer() {\n  let appendable = false;\n  const buffer = [];\n  return {\n    getBuffer() {\n      return buffer;\n    },\n    push(item) {\n      const isStringItem = isString(item);\n      if (appendable && isStringItem) {\n        buffer[buffer.length - 1] += item;\n      } else {\n        buffer.push(item);\n      }\n      appendable = isStringItem;\n      if (isPromise(item) || isArray(item) && item.hasAsync) {\n        buffer.hasAsync = true;\n      }\n    }\n  };\n}\nexport function vforToArray(source) {\n  if (isArray(source)) {\n    return source;\n  } else if (isString(source)) {\n    return source.split(\"\");\n  } else if (typeof source === \"number\") {\n    if (import.meta.dev && !Number.isInteger(source)) {\n      console.warn(`The v-for range expect an integer value but got ${source}.`);\n    }\n    const array = [];\n    for (let i = 0; i < source; i++) {\n      array[i] = i;\n    }\n    return array;\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      return Array.from(\n        source,\n        (item) => item\n      );\n    } else {\n      const keys = Object.keys(source);\n      const array = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        array[i] = source[key];\n      }\n      return array;\n    }\n  }\n  return [];\n}\nexport function getFragmentHTML(element, withoutSlots = false) {\n  if (element) {\n    if (element.nodeName === \"#comment\" && element.nodeValue === \"[\") {\n      return getFragmentChildren(element, [], withoutSlots);\n    }\n    if (withoutSlots) {\n      const clone = element.cloneNode(true);\n      clone.querySelectorAll(\"[data-island-slot]\").forEach((n) => {\n        n.innerHTML = \"\";\n      });\n      return [clone.outerHTML];\n    }\n    return [element.outerHTML];\n  }\n}\nfunction getFragmentChildren(element, blocks = [], withoutSlots = false) {\n  if (element && element.nodeName) {\n    if (isEndFragment(element)) {\n      return blocks;\n    } else if (!isStartFragment(element)) {\n      const clone = element.cloneNode(true);\n      if (withoutSlots) {\n        clone.querySelectorAll?.(\"[data-island-slot]\").forEach((n) => {\n          n.innerHTML = \"\";\n        });\n      }\n      blocks.push(clone.outerHTML);\n    }\n    getFragmentChildren(element.nextSibling, blocks, withoutSlots);\n  }\n  return blocks;\n}\nexport function elToStaticVNode(el, staticNodeFallback) {\n  const fragment = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : void 0;\n  if (fragment) {\n    return createStaticVNode(fragment.join(\"\"), fragment.length);\n  }\n  return h(\"div\");\n}\nexport function isStartFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"[\";\n}\nexport function isEndFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"]\";\n}\n","import { START_LOCATION } from \"vue-router\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { isChangingPage } from \"#app/components/utils\";\nimport { useRouter } from \"#app/composables/router\";\nexport default {\n  scrollBehavior(to, from, savedPosition) {\n    const nuxtApp = useNuxtApp();\n    const hashScrollBehaviour = useRouter().options?.scrollBehaviorType ?? \"auto\";\n    if (to.path === from.path) {\n      if (from.hash && !to.hash) {\n        return { left: 0, top: 0 };\n      }\n      if (to.hash) {\n        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior: hashScrollBehaviour };\n      }\n      return false;\n    }\n    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === \"function\" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;\n    if (routeAllowsScrollToTop === false) {\n      return false;\n    }\n    const hookToWait = nuxtApp._runningTransition ? \"page:transition:finish\" : \"page:loading:end\";\n    return new Promise((resolve) => {\n      if (from === START_LOCATION) {\n        resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour));\n        return;\n      }\n      nuxtApp.hooks.hookOnce(hookToWait, () => {\n        requestAnimationFrame(() => resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour)));\n      });\n    });\n  }\n};\nfunction _getHashElementScrollMarginTop(selector) {\n  try {\n    const elem = document.querySelector(selector);\n    if (elem) {\n      return (Number.parseFloat(getComputedStyle(elem).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0);\n    }\n  } catch {\n  }\n  return 0;\n}\nfunction _calculatePosition(to, from, savedPosition, defaultHashScrollBehaviour) {\n  if (savedPosition) {\n    return savedPosition;\n  }\n  const isPageNavigation = isChangingPage(to, from);\n  if (to.hash) {\n    return {\n      el: to.hash,\n      top: _getHashElementScrollMarginTop(to.hash),\n      behavior: isPageNavigation ? defaultHashScrollBehaviour : \"instant\"\n    };\n  }\n  return {\n    left: 0,\n    top: 0\n  };\n}\n","import routerOptions0 from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt/dist/pages/runtime/router.options.js\";\nconst configRouterOptions = {\n  hashMode: false,\n  scrollBehaviorType: \"auto\"\n}\nexport const hashMode = false\nexport default {\n...configRouterOptions,\n...routerOptions0,\n}","import { createError } from \"#app/composables/error\";\nimport { defineNuxtRouteMiddleware } from \"#app/composables/router\";\nexport default defineNuxtRouteMiddleware(async (to, from) => {\n  if (!to.meta?.validate) {\n    return;\n  }\n  const result = await Promise.resolve(to.meta.validate(to));\n  if (result === true) {\n    return;\n  }\n  const error = createError({\n    fatal: import.meta.client,\n    statusCode: result && result.statusCode || 404,\n    statusMessage: result && result.statusMessage || `Page Not Found: ${to.fullPath}`,\n    data: {\n      path: to.fullPath\n    }\n  });\n  if (typeof window !== \"undefined\") {\n    window.history.pushState({}, \"\", from.fullPath);\n  }\n  return error;\n});\n","import { hasProtocol } from \"ufo\";\nimport { defineNuxtRouteMiddleware } from \"../composables/router.js\";\nimport { getRouteRules } from \"../composables/manifest.js\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (import.meta.server || import.meta.test) {\n    return;\n  }\n  const rules = await getRouteRules({ path: to.path });\n  if (rules.redirect) {\n    if (hasProtocol(rules.redirect, { acceptRelative: true })) {\n      window.location.href = rules.redirect;\n      return false;\n    }\n    return rules.redirect;\n  }\n});\n","import validate from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt/dist/pages/runtime/validate.js\";\nimport manifest_45route_45rule from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt/dist/app/middleware/manifest-route-rule.js\";\nexport const globalMiddleware = [\n  validate,\n  manifest_45route_45rule\n]\nexport const namedMiddleware = {}","import { isReadonly, reactive, shallowReactive, shallowRef } from \"vue\";\nimport { START_LOCATION, createMemoryHistory, createRouter, createWebHashHistory, createWebHistory } from \"vue-router\";\nimport { isSamePath, withoutBase } from \"ufo\";\nimport { toArray } from \"../utils.js\";\nimport { getRouteRules } from \"#app/composables/manifest\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app/nuxt\";\nimport { clearError, createError, isNuxtError, showError, useError } from \"#app/composables/error\";\nimport { navigateTo } from \"#app/composables/router\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport _routes, { handleHotUpdate } from \"#build/routes\";\nimport routerOptions, { hashMode } from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location, renderedPath) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const displayedPath = withoutBase(pathname, base);\n  const path = !renderedPath || isSamePath(displayedPath, renderedPath) ? displayedPath : renderedPath;\n  return path + (path.includes(\"?\") ? \"\" : search) + hash;\n}\nconst plugin = defineNuxtPlugin({\n  name: \"nuxt:router\",\n  enforce: \"pre\",\n  async setup(nuxtApp) {\n    let routerBase = useRuntimeConfig().app.baseURL;\n    if (hashMode && !routerBase.includes(\"#\")) {\n      routerBase += \"#\";\n    }\n    const history = routerOptions.history?.(routerBase) ?? (import.meta.client ? hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n    const routes = routerOptions.routes ? await routerOptions.routes(_routes) ?? _routes : _routes;\n    let startPosition;\n    const router = createRouter({\n      ...routerOptions,\n      scrollBehavior: (to, from, savedPosition) => {\n        if (from === START_LOCATION) {\n          startPosition = savedPosition;\n          return;\n        }\n        if (routerOptions.scrollBehavior) {\n          router.options.scrollBehavior = routerOptions.scrollBehavior;\n          if (\"scrollRestoration\" in window.history) {\n            const unsub = router.beforeEach(() => {\n              unsub();\n              window.history.scrollRestoration = \"manual\";\n            });\n          }\n          return routerOptions.scrollBehavior(to, START_LOCATION, startPosition || savedPosition);\n        }\n      },\n      history,\n      routes\n    });\n    if (import.meta.hot) {\n      handleHotUpdate(router, routerOptions.routes ? routerOptions.routes : (routes2) => routes2);\n    }\n    if (import.meta.client && \"scrollRestoration\" in window.history) {\n      window.history.scrollRestoration = \"auto\";\n    }\n    nuxtApp.vueApp.use(router);\n    const previousRoute = shallowRef(router.currentRoute.value);\n    router.afterEach((_to, from) => {\n      previousRoute.value = from;\n    });\n    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n      get: () => previousRoute.value\n    });\n    const initialURL = import.meta.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location, nuxtApp.payload.path);\n    const _route = shallowRef(router.currentRoute.value);\n    const syncCurrentRoute = () => {\n      _route.value = router.currentRoute.value;\n    };\n    nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n    router.afterEach((to, from) => {\n      if (to.matched[to.matched.length - 1]?.components?.default === from.matched[from.matched.length - 1]?.components?.default) {\n        syncCurrentRoute();\n      }\n    });\n    const route = {};\n    for (const key in _route.value) {\n      Object.defineProperty(route, key, {\n        get: () => _route.value[key],\n        enumerable: true\n      });\n    }\n    nuxtApp._route = shallowReactive(route);\n    nuxtApp._middleware ||= {\n      global: [],\n      named: {}\n    };\n    const error = useError();\n    if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n      router.afterEach(async (to, _from, failure) => {\n        delete nuxtApp._processingMiddleware;\n        if (import.meta.client && !nuxtApp.isHydrating && error.value) {\n          await nuxtApp.runWithContext(clearError);\n        }\n        if (failure) {\n          await nuxtApp.callHook(\"page:loading:end\");\n        }\n        if (import.meta.server && failure?.type === 4) {\n          return;\n        }\n        if (import.meta.server && to.redirectedFrom && to.fullPath !== initialURL) {\n          await nuxtApp.runWithContext(() => navigateTo(to.fullPath || \"/\"));\n        }\n      });\n    }\n    try {\n      if (import.meta.server) {\n        await router.push(initialURL);\n      }\n      await router.isReady();\n    } catch (error2) {\n      await nuxtApp.runWithContext(() => showError(error2));\n    }\n    const resolvedInitialRoute = import.meta.client && initialURL !== router.currentRoute.value.fullPath ? router.resolve(initialURL) : router.currentRoute.value;\n    syncCurrentRoute();\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext) {\n      return { provide: { router } };\n    }\n    const initialLayout = nuxtApp.payload.state._layout;\n    router.beforeEach(async (to, from) => {\n      await nuxtApp.callHook(\"page:loading:start\");\n      to.meta = reactive(to.meta);\n      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {\n        to.meta.layout = initialLayout;\n      }\n      nuxtApp._processingMiddleware = true;\n      if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n        for (const component of to.matched) {\n          const componentMiddleware = component.meta.middleware;\n          if (!componentMiddleware) {\n            continue;\n          }\n          for (const entry of toArray(componentMiddleware)) {\n            middlewareEntries.add(entry);\n          }\n        }\n        if (isAppManifestEnabled) {\n          const routeRules = await nuxtApp.runWithContext(() => getRouteRules({ path: to.path }));\n          if (routeRules.appMiddleware) {\n            for (const key in routeRules.appMiddleware) {\n              if (routeRules.appMiddleware[key]) {\n                middlewareEntries.add(key);\n              } else {\n                middlewareEntries.delete(key);\n              }\n            }\n          }\n        }\n        for (const entry of middlewareEntries) {\n          const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n          if (!middleware) {\n            if (import.meta.dev) {\n              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n            }\n            throw new Error(`Unknown route middleware: '${entry}'.`);\n          }\n          try {\n            if (import.meta.dev) {\n              nuxtApp._processingMiddleware = middleware._path || (typeof entry === \"string\" ? entry : true);\n            }\n            const result = await nuxtApp.runWithContext(() => middleware(to, from));\n            if (import.meta.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n              if (result === false || result instanceof Error) {\n                const error2 = result || createError({\n                  statusCode: 404,\n                  statusMessage: `Page Not Found: ${initialURL}`\n                });\n                await nuxtApp.runWithContext(() => showError(error2));\n                return false;\n              }\n            }\n            if (result === true) {\n              continue;\n            }\n            if (result === false) {\n              return result;\n            }\n            if (result) {\n              if (isNuxtError(result) && result.fatal) {\n                await nuxtApp.runWithContext(() => showError(result));\n              }\n              return result;\n            }\n          } catch (err) {\n            const error2 = createError(err);\n            if (error2.fatal) {\n              await nuxtApp.runWithContext(() => showError(error2));\n            }\n            return error2;\n          }\n        }\n      }\n    });\n    router.onError(async () => {\n      delete nuxtApp._processingMiddleware;\n      await nuxtApp.callHook(\"page:loading:end\");\n    });\n    router.afterEach((to) => {\n      if (to.matched.length === 0) {\n        return nuxtApp.runWithContext(() => showError(createError({\n          statusCode: 404,\n          fatal: false,\n          statusMessage: `Page not found: ${to.fullPath}`,\n          data: {\n            path: to.fullPath\n          }\n        })));\n      }\n    });\n    nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n      try {\n        if (\"name\" in resolvedInitialRoute) {\n          resolvedInitialRoute.name = void 0;\n        }\n        await router.replace({\n          ...resolvedInitialRoute,\n          force: true\n        });\n        router.options.scrollBehavior = routerOptions.scrollBehavior;\n      } catch (error2) {\n        await nuxtApp.runWithContext(() => showError(error2));\n      }\n    });\n    return { provide: { router } };\n  }\n});\nexport default plugin;\n","import { hasInjectionContext, inject } from \"vue\";\nimport {\n  useHead as headCore,\n  useHeadSafe as headSafe,\n  headSymbol,\n  useSeoMeta as seoMeta,\n  useServerHead as serverHead,\n  useServerHeadSafe as serverHeadSafe,\n  useServerSeoMeta as serverSeoMeta\n} from \"@unhead/vue\";\nimport { useNuxtApp } from \"#app/nuxt\";\nexport function injectHead(nuxtApp) {\n  const nuxt = nuxtApp || useNuxtApp();\n  return nuxt.ssrContext?.head || nuxt.runWithContext(() => {\n    if (hasInjectionContext()) {\n      const head = inject(headSymbol);\n      if (!head) {\n        throw new Error(\"[nuxt] [unhead] Missing Unhead instance.\");\n      }\n      return head;\n    }\n  });\n}\nexport function useHead(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return headCore(input, { head, ...options });\n}\nexport function useHeadSafe(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return headSafe(input, { head, ...options });\n}\nexport function useSeoMeta(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return seoMeta(input, { head, ...options });\n}\nexport function useServerHead(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return serverHead(input, { head, ...options });\n}\nexport function useServerHeadSafe(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return serverHeadSafe(input, { head, ...options });\n}\nexport function useServerSeoMeta(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return serverSeoMeta(input, { head, ...options });\n}\n","import { createElementBlock, defineComponent } from \"vue\";\nexport default defineComponent({\n  name: \"ServerPlaceholder\",\n  render() {\n    return createElementBlock(\"div\");\n  }\n});\n","import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from \"vue\";\nimport { isPromise } from \"@vue/shared\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport ServerPlaceholder from \"./server-placeholder.js\";\nimport { elToStaticVNode } from \"./utils.js\";\nexport const clientOnlySymbol = Symbol.for(\"nuxt:client-only\");\nconst STATIC_DIV = \"<div></div>\";\nexport default defineComponent({\n  name: \"ClientOnly\",\n  inheritAttrs: false,\n  props: [\"fallback\", \"placeholder\", \"placeholderTag\", \"fallbackTag\"],\n  ...import.meta.dev && {\n    slots: Object\n  },\n  setup(props, { slots, attrs }) {\n    const mounted = shallowRef(false);\n    onMounted(() => {\n      mounted.value = true;\n    });\n    if (import.meta.dev) {\n      const nuxtApp = useNuxtApp();\n      nuxtApp._isNuxtPageUsed = true;\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    const vm = getCurrentInstance();\n    if (vm) {\n      vm._nuxtClientOnly = true;\n    }\n    provide(clientOnlySymbol, true);\n    return () => {\n      if (mounted.value) {\n        const vnodes = slots.default?.();\n        if (vnodes && vnodes.length === 1) {\n          return [cloneVNode(vnodes[0], attrs)];\n        }\n        return vnodes;\n      }\n      const slot = slots.fallback || slots.placeholder;\n      if (slot) {\n        return h(slot);\n      }\n      const fallbackStr = props.fallback || props.placeholder || \"\";\n      const fallbackTag = props.fallbackTag || props.placeholderTag || \"span\";\n      return createElementBlock(fallbackTag, attrs, fallbackStr);\n    };\n  }\n});\nconst cache = /* @__PURE__ */ new WeakMap();\n// @__NO_SIDE_EFFECTS__\nexport function createClientOnly(component) {\n  if (import.meta.server) {\n    return ServerPlaceholder;\n  }\n  if (cache.has(component)) {\n    return cache.get(component);\n  }\n  const clone = { ...component };\n  if (clone.render) {\n    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {\n      if ($setup.mounted$ ?? ctx.mounted$) {\n        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);\n        return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n      }\n      return elToStaticVNode(ctx._.vnode.el, STATIC_DIV);\n    };\n  } else {\n    clone.template &&= `\n      <template v-if=\"mounted$\">${component.template}</template>\n      <template v-else>${STATIC_DIV}</template>\n    `;\n  }\n  clone.setup = (props, ctx) => {\n    const nuxtApp = useNuxtApp();\n    const mounted$ = shallowRef(nuxtApp.isHydrating === false);\n    const instance = getCurrentInstance();\n    if (nuxtApp.isHydrating) {\n      const attrs = { ...instance.attrs };\n      const directives = extractDirectives(instance);\n      for (const key in attrs) {\n        delete instance.attrs[key];\n      }\n      onMounted(() => {\n        Object.assign(instance.attrs, attrs);\n        instance.vnode.dirs = directives;\n      });\n    }\n    onMounted(() => {\n      mounted$.value = true;\n    });\n    const setupState = component.setup?.(props, ctx) || {};\n    if (isPromise(setupState)) {\n      return Promise.resolve(setupState).then((setupState2) => {\n        if (typeof setupState2 !== \"function\") {\n          setupState2 ||= {};\n          setupState2.mounted$ = mounted$;\n          return setupState2;\n        }\n        return (...args) => {\n          if (mounted$.value || !nuxtApp.isHydrating) {\n            const res = setupState2(...args);\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      });\n    } else {\n      if (typeof setupState === \"function\") {\n        return (...args) => {\n          if (mounted$.value) {\n            const res = setupState(...args);\n            const attrs = clone.inheritAttrs !== false ? ctx.attrs : void 0;\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res, attrs) : h(res, attrs);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      }\n      return Object.assign(setupState, { mounted$ });\n    }\n  };\n  cache.set(component, clone);\n  return clone;\n}\nfunction extractDirectives(instance) {\n  if (!instance || !instance.vnode.dirs) {\n    return null;\n  }\n  const directives = instance.vnode.dirs;\n  instance.vnode.dirs = null;\n  return directives;\n}\n","import { useNuxtApp } from \"../nuxt.js\";\nimport { requestIdleCallback } from \"../compat/idle-callback.js\";\nexport const onNuxtReady = (callback) => {\n  if (import.meta.server) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp.isHydrating) {\n    nuxtApp.hooks.hookOnce(\"app:suspense:resolve\", () => {\n      requestIdleCallback(() => callback());\n    });\n  } else {\n    requestIdleCallback(() => callback());\n  }\n};\n","import { isRef, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nconst useStateKeyPrefix = \"$s\";\nexport function useState(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [_key, init] = args;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useState] key must be a string: \" + _key);\n  }\n  if (init !== void 0 && typeof init !== \"function\") {\n    throw new Error(\"[nuxt] [useState] init must be a function: \" + init);\n  }\n  const key = useStateKeyPrefix + _key;\n  const nuxtApp = useNuxtApp();\n  const state = toRef(nuxtApp.payload.state, key);\n  if (state.value === void 0 && init) {\n    const initialValue = init();\n    if (isRef(initialValue)) {\n      nuxtApp.payload.state[key] = initialValue;\n      return initialValue;\n    }\n    state.value = initialValue;\n  }\n  return state;\n}\nexport function clearNuxtState(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.state).map((key) => key.substring(useStateKeyPrefix.length));\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const _key of _keys) {\n    const key = useStateKeyPrefix + _key;\n    if (key in nuxtApp.payload.state) {\n      nuxtApp.payload.state[key] = void 0;\n    }\n  }\n}\n","import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeader, getRequestHeaders, getResponseHeader, removeResponseHeader, setResponseHeader } from \"h3\";\nimport { computed, getCurrentInstance, ref } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { useHead } from \"./head.js\";\nexport function useRequestEvent(nuxtApp) {\n  if (import.meta.client) {\n    return;\n  }\n  nuxtApp ||= useNuxtApp();\n  return nuxtApp.ssrContext?.event;\n}\nexport function useRequestHeaders(include) {\n  if (import.meta.client) {\n    return {};\n  }\n  const event = useRequestEvent();\n  const _headers = event ? getRequestHeaders(event) : {};\n  if (!include || !event) {\n    return _headers;\n  }\n  const headers = /* @__PURE__ */ Object.create(null);\n  for (const _key of include) {\n    const key = _key.toLowerCase();\n    const header = _headers[key];\n    if (header) {\n      headers[key] = header;\n    }\n  }\n  return headers;\n}\nexport function useRequestHeader(header) {\n  if (import.meta.client) {\n    return void 0;\n  }\n  const event = useRequestEvent();\n  return event ? getRequestHeader(event, header) : void 0;\n}\nexport function useRequestFetch() {\n  if (import.meta.client) {\n    return globalThis.$fetch;\n  }\n  return useRequestEvent()?.$fetch || globalThis.$fetch;\n}\nexport function setResponseStatus(arg1, arg2, arg3) {\n  if (import.meta.client) {\n    return;\n  }\n  if (arg1 && typeof arg1 !== \"number\") {\n    return _setResponseStatus(arg1, arg2, arg3);\n  }\n  const event = useRequestEvent();\n  if (event) {\n    return _setResponseStatus(event, arg1, arg2);\n  }\n}\nexport function useResponseHeader(header) {\n  if (import.meta.client) {\n    if (import.meta.dev) {\n      return computed({\n        get: () => void 0,\n        set: () => console.warn(\"[nuxt] Setting response headers is not supported in the browser.\")\n      });\n    }\n    return ref();\n  }\n  const event = useRequestEvent();\n  return computed({\n    get() {\n      return getResponseHeader(event, header);\n    },\n    set(newValue) {\n      if (!newValue) {\n        return removeResponseHeader(event, header);\n      }\n      return setResponseHeader(event, header, newValue);\n    }\n  });\n}\nexport function prerenderRoutes(path) {\n  if (!import.meta.server || !import.meta.prerender) {\n    return;\n  }\n  const paths = toArray(path);\n  appendHeader(useRequestEvent(), \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\n}\nconst PREHYDRATE_ATTR_KEY = \"data-prehydrate-id\";\nexport function onPrehydrate(callback, key) {\n  if (import.meta.client) {\n    return;\n  }\n  if (typeof callback !== \"string\") {\n    throw new TypeError(\"[nuxt] To transform a callback into a string, `onPrehydrate` must be processed by the Nuxt build pipeline. If it is called in a third-party library, make sure to add the library to `build.transpile`.\");\n  }\n  const vm = getCurrentInstance();\n  if (vm && key) {\n    vm.attrs[PREHYDRATE_ATTR_KEY] ||= \"\";\n    key = \":\" + key + \":\";\n    if (!vm.attrs[PREHYDRATE_ATTR_KEY].includes(key)) {\n      vm.attrs[PREHYDRATE_ATTR_KEY] += key;\n    }\n  }\n  const code = vm && key ? `document.querySelectorAll('[${PREHYDRATE_ATTR_KEY}*=${JSON.stringify(key)}]').forEach` + callback : callback + \"()\";\n  useHead({\n    script: [{\n      key: vm && key ? key : void 0,\n      tagPosition: \"bodyClose\",\n      tagPriority: \"critical\",\n      innerHTML: code\n    }]\n  });\n  return vm && key ? vm.attrs[PREHYDRATE_ATTR_KEY] : void 0;\n}\n","import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nimport { cookieStore } from \"#build/nuxt.config.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nconst store = import.meta.client && cookieStore ? globalThis.cookieStore : void 0;\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  opts.filter ??= (key) => key === name;\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const shouldSetInitialClientCookie = import.meta.client && (hasExpired || cookies[name] === void 0 || cookies[name] === null);\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay, opts.watch && opts.watch !== \"shallow\") : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    let channel = null;\n    try {\n      if (!store && typeof BroadcastChannel !== \"undefined\") {\n        channel = new BroadcastChannel(`nuxt:cookies:${name}`);\n      }\n    } catch {\n    }\n    const callback = (force = false) => {\n      if (!force) {\n        if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n          return;\n        }\n      }\n      writeClientCookie(name, cookie.value, opts);\n      cookies[name] = klona(cookie.value);\n      channel?.postMessage({ value: opts.encode(cookie.value) });\n    };\n    const handleChange = (data) => {\n      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value);\n      watchPaused = true;\n      cookie.value = value;\n      cookies[name] = klona(value);\n      nextTick(() => {\n        watchPaused = false;\n      });\n    };\n    let watchPaused = false;\n    const hasScope = !!getCurrentScope();\n    if (hasScope) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (store) {\n      const changeHandler = (event) => {\n        const changedCookie = event.changed.find((c) => c.name === name);\n        const removedCookie = event.deleted.find((c) => c.name === name);\n        if (changedCookie) {\n          handleChange({ value: changedCookie.value });\n        }\n        if (removedCookie) {\n          handleChange({ value: null });\n        }\n      };\n      store.addEventListener(\"change\", changeHandler);\n      if (hasScope) {\n        onScopeDispose(() => store.removeEventListener(\"change\", changeHandler));\n      }\n    } else if (channel) {\n      channel.onmessage = ({ data }) => handleChange(data);\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    }\n    if (shouldSetInitialClientCookie) {\n      callback(shouldSetInitialClientCookie);\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      nuxtApp._cookies ||= {};\n      if (name in nuxtApp._cookies) {\n        if (isEqual(cookie.value, nuxtApp._cookies[name])) {\n          return;\n        }\n        if (import.meta.dev) {\n          console.warn(`[nuxt] cookie \\`${name}\\` was previously set to \\`${opts.encode(nuxtApp._cookies[name])}\\` and is being overridden to \\`${opts.encode(cookie.value)}\\`. This may cause unexpected issues.`);\n        }\n      }\n      nuxtApp._cookies[name] = cookie.value;\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nexport function refreshCookie(name) {\n  if (import.meta.server || store || typeof BroadcastChannel === \"undefined\") {\n    return;\n  }\n  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true });\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay, shouldWatch) {\n  let timeout;\n  let unsubscribe;\n  let elapsed = 0;\n  const internalRef = shouldWatch ? ref(value) : { value };\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    if (shouldWatch) {\n      unsubscribe = watch(internalRef, trigger);\n    }\n    function createExpirationTimeout() {\n      elapsed = 0;\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        internalRef.value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return internalRef.value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        internalRef.value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n","import { hasProtocol, joinURL, withoutTrailingSlash } from \"ufo\";\nimport { parse } from \"devalue\";\nimport { getCurrentInstance, onServerPrefetch, reactive } from \"vue\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { useHead } from \"./head.js\";\nimport { useRoute } from \"./router.js\";\nimport { getAppManifest, getRouteRules } from \"./manifest.js\";\nimport { appId, appManifest, multiApp, payloadExtraction, renderJsonPayloads } from \"#build/nuxt.config.mjs\";\nexport async function loadPayload(url, opts = {}) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const shouldLoadPayload = await isPrerendered(url);\n  if (!shouldLoadPayload) {\n    return null;\n  }\n  const payloadURL = await _getPayloadURL(url, opts);\n  return await _importPayload(payloadURL) || null;\n}\nlet linkRelType;\nfunction detectLinkRelType() {\n  if (import.meta.server) {\n    return \"preload\";\n  }\n  if (linkRelType) {\n    return linkRelType;\n  }\n  const relList = document.createElement(\"link\").relList;\n  linkRelType = relList && relList.supports && relList.supports(\"prefetch\") ? \"prefetch\" : \"preload\";\n  return linkRelType;\n}\nexport function preloadPayload(url, opts = {}) {\n  const nuxtApp = useNuxtApp();\n  const promise = _getPayloadURL(url, opts).then((payloadURL) => {\n    const link = renderJsonPayloads ? { rel: detectLinkRelType(), as: \"fetch\", crossorigin: \"anonymous\", href: payloadURL } : { rel: \"modulepreload\", crossorigin: \"\", href: payloadURL };\n    if (import.meta.server) {\n      nuxtApp.runWithContext(() => useHead({ link: [link] }));\n    } else {\n      const linkEl = document.createElement(\"link\");\n      for (const key of Object.keys(link)) {\n        linkEl[key === \"crossorigin\" ? \"crossOrigin\" : key] = link[key];\n      }\n      document.head.appendChild(linkEl);\n      return new Promise((resolve, reject) => {\n        linkEl.addEventListener(\"load\", () => resolve());\n        linkEl.addEventListener(\"error\", () => reject());\n      });\n    }\n  });\n  if (import.meta.server) {\n    onServerPrefetch(() => promise);\n  }\n  return promise;\n}\nconst filename = renderJsonPayloads ? \"_payload.json\" : \"_payload.js\";\nasync function _getPayloadURL(url, opts = {}) {\n  const u = new URL(url, \"http://localhost\");\n  if (u.host !== \"localhost\" || hasProtocol(u.pathname, { acceptRelative: true })) {\n    throw new Error(\"Payload URL must not include hostname: \" + url);\n  }\n  const config = useRuntimeConfig();\n  const hash = opts.hash || (opts.fresh ? Date.now() : config.app.buildId);\n  const cdnURL = config.app.cdnURL;\n  const baseOrCdnURL = cdnURL && await isPrerendered(url) ? cdnURL : config.app.baseURL;\n  return joinURL(baseOrCdnURL, u.pathname, filename + (hash ? `?${hash}` : \"\"));\n}\nasync function _importPayload(payloadURL) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const payloadPromise = renderJsonPayloads ? fetch(payloadURL, { cache: \"force-cache\" }).then((res) => res.text().then(parsePayload)) : import(\n    /* webpackIgnore: true */\n    /* @vite-ignore */\n    payloadURL\n  ).then((r) => r.default || r);\n  try {\n    return await payloadPromise;\n  } catch (err) {\n    console.warn(\"[nuxt] Cannot load payload \", payloadURL, err);\n  }\n  return null;\n}\nexport async function isPrerendered(url = useRoute().path) {\n  const nuxtApp = useNuxtApp();\n  if (!appManifest) {\n    return !!nuxtApp.payload.prerenderedAt;\n  }\n  url = withoutTrailingSlash(url);\n  const manifest = await getAppManifest();\n  if (manifest.prerendered.includes(url)) {\n    return true;\n  }\n  return nuxtApp.runWithContext(async () => {\n    const rules = await getRouteRules({ path: url });\n    return !!rules.prerender && !rules.redirect;\n  });\n}\nlet payloadCache = null;\nexport async function getNuxtClientPayload() {\n  if (import.meta.server) {\n    return null;\n  }\n  if (payloadCache) {\n    return payloadCache;\n  }\n  const el = multiApp ? document.querySelector(`[data-nuxt-data=\"${appId}\"]`) : document.getElementById(\"__NUXT_DATA__\");\n  if (!el) {\n    return {};\n  }\n  const inlineData = await parsePayload(el.textContent || \"\");\n  const externalData = el.dataset.src ? await _importPayload(el.dataset.src) : void 0;\n  payloadCache = {\n    ...inlineData,\n    ...externalData,\n    ...multiApp ? window.__NUXT__?.[appId] : window.__NUXT__\n  };\n  if (payloadCache.config?.public) {\n    payloadCache.config.public = reactive(payloadCache.config.public);\n  }\n  return payloadCache;\n}\nexport async function parsePayload(payload) {\n  return await parse(payload, useNuxtApp()._payloadRevivers);\n}\nexport function definePayloadReducer(name, reduce) {\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._payloadReducers[name] = reduce;\n  }\n}\nexport function definePayloadReviver(name, revive) {\n  if (import.meta.dev && getCurrentInstance()) {\n    console.warn(\"[nuxt] [definePayloadReviver] This function must be called in a Nuxt plugin that is `unshift`ed to the beginning of the Nuxt plugins array.\");\n  }\n  if (import.meta.client) {\n    useNuxtApp()._payloadRevivers[name] = revive;\n  }\n}\n","import { computed, defineComponent, h, inject, onBeforeUnmount, onMounted, provide, ref, resolveComponent, shallowRef } from \"vue\";\nimport { hasProtocol, joinURL, parseQuery, withTrailingSlash, withoutTrailingSlash } from \"ufo\";\nimport { preloadRouteComponents } from \"../composables/preload.js\";\nimport { onNuxtReady } from \"../composables/ready.js\";\nimport { navigateTo, resolveRouteObject, useRouter } from \"../composables/router.js\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { cancelIdleCallback, requestIdleCallback } from \"../compat/idle-callback.js\";\nimport { nuxtLinkDefaults } from \"#build/nuxt.config.mjs\";\nimport { hashMode } from \"#build/router.options\";\nconst firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);\nconst NuxtLinkDevKeySymbol = Symbol(\"nuxt-link-dev-key\");\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtLink(options) {\n  const componentName = options.componentName || \"NuxtLink\";\n  function checkPropConflicts(props, main, sub) {\n    if (import.meta.dev && props[main] !== void 0 && props[sub] !== void 0) {\n      console.warn(`[${componentName}] \\`${main}\\` and \\`${sub}\\` cannot be used together. \\`${sub}\\` will be ignored.`);\n    }\n  }\n  function isHashLinkWithoutHashMode(link) {\n    return !hashMode && typeof link === \"string\" && link.startsWith(\"#\");\n  }\n  function resolveTrailingSlashBehavior(to, resolve, trailingSlash) {\n    const effectiveTrailingSlash = trailingSlash ?? options.trailingSlash;\n    if (!to || effectiveTrailingSlash !== \"append\" && effectiveTrailingSlash !== \"remove\") {\n      return to;\n    }\n    if (typeof to === \"string\") {\n      return applyTrailingSlashBehavior(to, effectiveTrailingSlash);\n    }\n    const path = \"path\" in to && to.path !== void 0 ? to.path : resolve(to).path;\n    const resolvedPath = {\n      ...to,\n      name: void 0,\n      // named routes would otherwise always override trailing slash behavior\n      path: applyTrailingSlashBehavior(path, effectiveTrailingSlash)\n    };\n    return resolvedPath;\n  }\n  function useNuxtLink(props) {\n    const router = useRouter();\n    const config = useRuntimeConfig();\n    const hasTarget = computed(() => !!props.target && props.target !== \"_self\");\n    const isAbsoluteUrl = computed(() => {\n      const path = props.to || props.href || \"\";\n      return typeof path === \"string\" && hasProtocol(path, { acceptRelative: true });\n    });\n    const builtinRouterLink = resolveComponent(\"RouterLink\");\n    const useBuiltinLink = builtinRouterLink && typeof builtinRouterLink !== \"string\" ? builtinRouterLink.useLink : void 0;\n    const isExternal = computed(() => {\n      if (props.external) {\n        return true;\n      }\n      const path = props.to || props.href || \"\";\n      if (typeof path === \"object\") {\n        return false;\n      }\n      return path === \"\" || isAbsoluteUrl.value;\n    });\n    const to = computed(() => {\n      checkPropConflicts(props, \"to\", \"href\");\n      const path = props.to || props.href || \"\";\n      if (isExternal.value) {\n        return path;\n      }\n      return resolveTrailingSlashBehavior(path, router.resolve, props.trailingSlash);\n    });\n    const link = isExternal.value ? void 0 : useBuiltinLink?.({ ...props, to });\n    const href = computed(() => {\n      const effectiveTrailingSlash = props.trailingSlash ?? options.trailingSlash;\n      if (!to.value || isAbsoluteUrl.value || isHashLinkWithoutHashMode(to.value)) {\n        return to.value;\n      }\n      if (isExternal.value) {\n        const path = typeof to.value === \"object\" && \"path\" in to.value ? resolveRouteObject(to.value) : to.value;\n        const href2 = typeof path === \"object\" ? router.resolve(path).href : path;\n        return applyTrailingSlashBehavior(href2, effectiveTrailingSlash);\n      }\n      if (typeof to.value === \"object\") {\n        return router.resolve(to.value)?.href ?? null;\n      }\n      return applyTrailingSlashBehavior(joinURL(config.app.baseURL, to.value), effectiveTrailingSlash);\n    });\n    return {\n      to,\n      hasTarget,\n      isAbsoluteUrl,\n      isExternal,\n      //\n      href,\n      isActive: link?.isActive ?? computed(() => to.value === router.currentRoute.value.path),\n      isExactActive: link?.isExactActive ?? computed(() => to.value === router.currentRoute.value.path),\n      route: link?.route ?? computed(() => router.resolve(to.value)),\n      async navigate(_e) {\n        await navigateTo(href.value, { replace: props.replace, external: isExternal.value || hasTarget.value });\n      }\n    };\n  }\n  return defineComponent({\n    name: componentName,\n    props: {\n      // Routing\n      to: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      href: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      // Attributes\n      target: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      rel: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      noRel: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      // Prefetching\n      prefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      prefetchOn: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      noPrefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      // Styling\n      activeClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      exactActiveClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      prefetchedClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      // Vue Router's `<RouterLink>` additional props\n      replace: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      ariaCurrentValue: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      // Edge cases handling\n      external: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      // Slot API\n      custom: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      // Behavior\n      trailingSlash: {\n        type: String,\n        default: void 0,\n        required: false\n      }\n    },\n    useLink: useNuxtLink,\n    setup(props, { slots }) {\n      const router = useRouter();\n      const { to, href, navigate, isExternal, hasTarget, isAbsoluteUrl } = useNuxtLink(props);\n      const prefetched = shallowRef(false);\n      const el = import.meta.server ? void 0 : ref(null);\n      const elRef = import.meta.server ? void 0 : (ref2) => {\n        el.value = props.custom ? ref2?.$el?.nextElementSibling : ref2?.$el;\n      };\n      function shouldPrefetch(mode) {\n        if (import.meta.server) {\n          return;\n        }\n        return !prefetched.value && (typeof props.prefetchOn === \"string\" ? props.prefetchOn === mode : props.prefetchOn?.[mode] ?? options.prefetchOn?.[mode]) && (props.prefetch ?? options.prefetch) !== false && props.noPrefetch !== true && props.target !== \"_blank\" && !isSlowConnection();\n      }\n      async function prefetch(nuxtApp = useNuxtApp()) {\n        if (import.meta.server) {\n          return;\n        }\n        if (prefetched.value) {\n          return;\n        }\n        prefetched.value = true;\n        const path = typeof to.value === \"string\" ? to.value : isExternal.value ? resolveRouteObject(to.value) : router.resolve(to.value).fullPath;\n        const normalizedPath = isExternal.value ? new URL(path, window.location.href).href : path;\n        await Promise.all([\n          nuxtApp.hooks.callHook(\"link:prefetch\", normalizedPath).catch(() => {\n          }),\n          !isExternal.value && !hasTarget.value && preloadRouteComponents(to.value, router).catch(() => {\n          })\n        ]);\n      }\n      if (import.meta.client) {\n        checkPropConflicts(props, \"prefetch\", \"noPrefetch\");\n        if (shouldPrefetch(\"visibility\")) {\n          const nuxtApp = useNuxtApp();\n          let idleId;\n          let unobserve = null;\n          onMounted(() => {\n            const observer = useObserver();\n            onNuxtReady(() => {\n              idleId = requestIdleCallback(() => {\n                if (el?.value?.tagName) {\n                  unobserve = observer.observe(el.value, async () => {\n                    unobserve?.();\n                    unobserve = null;\n                    await prefetch(nuxtApp);\n                  });\n                }\n              });\n            });\n          });\n          onBeforeUnmount(() => {\n            if (idleId) {\n              cancelIdleCallback(idleId);\n            }\n            unobserve?.();\n            unobserve = null;\n          });\n        }\n      }\n      if (import.meta.dev && import.meta.server && !props.custom) {\n        const isNuxtLinkChild = inject(NuxtLinkDevKeySymbol, false);\n        if (isNuxtLinkChild) {\n          console.log(\"[nuxt] [NuxtLink] You can't nest one <a> inside another <a>. This will cause a hydration error on client-side. You can pass the `custom` prop to take full control of the markup.\");\n        } else {\n          provide(NuxtLinkDevKeySymbol, true);\n        }\n      }\n      return () => {\n        if (!isExternal.value && !hasTarget.value && !isHashLinkWithoutHashMode(to.value)) {\n          const routerLinkProps = {\n            ref: elRef,\n            to: to.value,\n            activeClass: props.activeClass || options.activeClass,\n            exactActiveClass: props.exactActiveClass || options.exactActiveClass,\n            replace: props.replace,\n            ariaCurrentValue: props.ariaCurrentValue,\n            custom: props.custom\n          };\n          if (!props.custom) {\n            if (import.meta.client) {\n              if (shouldPrefetch(\"interaction\")) {\n                routerLinkProps.onPointerenter = prefetch.bind(null, void 0);\n                routerLinkProps.onFocus = prefetch.bind(null, void 0);\n              }\n              if (prefetched.value) {\n                routerLinkProps.class = props.prefetchedClass || options.prefetchedClass;\n              }\n            }\n            routerLinkProps.rel = props.rel || void 0;\n          }\n          return h(\n            resolveComponent(\"RouterLink\"),\n            routerLinkProps,\n            slots.default\n          );\n        }\n        const target = props.target || null;\n        checkPropConflicts(props, \"noRel\", \"rel\");\n        const rel = firstNonUndefined(\n          // converts `\"\"` to `null` to prevent the attribute from being added as empty (`rel=\"\"`)\n          props.noRel ? \"\" : props.rel,\n          options.externalRelAttribute,\n          /*\n          * A fallback rel of `noopener noreferrer` is applied for external links or links that open in a new tab.\n          * This solves a reverse tabnapping security flaw in browsers pre-2021 as well as improving privacy.\n          */\n          isAbsoluteUrl.value || hasTarget.value ? \"noopener noreferrer\" : \"\"\n        ) || null;\n        if (props.custom) {\n          if (!slots.default) {\n            return null;\n          }\n          return slots.default({\n            href: href.value,\n            navigate,\n            prefetch,\n            get route() {\n              if (!href.value) {\n                return void 0;\n              }\n              const url = new URL(href.value, import.meta.client ? window.location.href : \"http://localhost\");\n              return {\n                path: url.pathname,\n                fullPath: url.pathname,\n                get query() {\n                  return parseQuery(url.search);\n                },\n                hash: url.hash,\n                params: {},\n                name: void 0,\n                matched: [],\n                redirectedFrom: void 0,\n                meta: {},\n                href: href.value\n              };\n            },\n            rel,\n            target,\n            isExternal: isExternal.value || hasTarget.value,\n            isActive: false,\n            isExactActive: false\n          });\n        }\n        return h(\"a\", {\n          ref: el,\n          href: href.value || null,\n          // converts `\"\"` to `null` to prevent the attribute from being added as empty (`href=\"\"`)\n          rel,\n          target,\n          onClick: (event) => {\n            if (isExternal.value || hasTarget.value) {\n              return;\n            }\n            event.preventDefault();\n            return props.replace ? router.replace(href.value) : router.push(href.value);\n          }\n        }, slots.default?.());\n      };\n    }\n    // }) as unknown as DefineComponent<NuxtLinkProps, object, object, ComputedOptions, MethodOptions, object, object, EmitsOptions, string, object, NuxtLinkProps, object, SlotsType<NuxtLinkSlots>>\n  });\n}\nexport default /* @__PURE__ */ defineNuxtLink(nuxtLinkDefaults);\nfunction applyTrailingSlashBehavior(to, trailingSlash) {\n  const normalizeFn = trailingSlash === \"append\" ? withTrailingSlash : withoutTrailingSlash;\n  const hasProtocolDifferentFromHttp = hasProtocol(to) && !to.startsWith(\"http\");\n  if (hasProtocolDifferentFromHttp) {\n    return to;\n  }\n  return normalizeFn(to, true);\n}\nfunction useObserver() {\n  if (import.meta.server) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp._observer) {\n    return nuxtApp._observer;\n  }\n  let observer = null;\n  const callbacks = /* @__PURE__ */ new Map();\n  const observe = (element, callback) => {\n    observer ||= new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        const callback2 = callbacks.get(entry.target);\n        const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n        if (isVisible && callback2) {\n          callback2();\n        }\n      }\n    });\n    callbacks.set(element, callback);\n    observer.observe(element);\n    return () => {\n      callbacks.delete(element);\n      observer?.unobserve(element);\n      if (callbacks.size === 0) {\n        observer?.disconnect();\n        observer = null;\n      }\n    };\n  };\n  const _observer = nuxtApp._observer = {\n    observe\n  };\n  return _observer;\n}\nconst IS_2G_RE = /2g/;\nfunction isSlowConnection() {\n  if (import.meta.server) {\n    return;\n  }\n  const cn = navigator.connection;\n  if (cn && (cn.saveData || IS_2G_RE.test(cn.effectiveType))) {\n    return true;\n  }\n  return false;\n}\n","import { defineNuxtPlugin, useRequestEvent, useRuntimeConfig, useState } from \"#app\";\nimport { createSiteConfigStack } from \"site-config-stack\";\nexport default defineNuxtPlugin({\n  name: \"nuxt-site-config:init\",\n  enforce: \"pre\",\n  async setup(nuxtApp) {\n    const stack = import.meta.server ? useRequestEvent()?.context?.siteConfig : createSiteConfigStack();\n    const state = useState(\"site-config\");\n    if (import.meta.server) {\n      nuxtApp.hooks.hook(\"app:rendered\", () => {\n        state.value = stack?.get({\n          debug: useRuntimeConfig()[\"nuxt-site-config\"].debug,\n          resolveRefs: true\n        });\n      });\n    }\n    if (import.meta.client) {\n      const store = state.value || window.__NUXT_SITE_CONFIG__ || {};\n      for (const k in store) {\n        if (k[0] !== \"_\") {\n          stack.push({ [k]: store[k], _priority: store._priority?.[k] || -1 });\n        }\n      }\n    }\n    return {\n      provide: {\n        nuxtSiteConfig: stack\n      }\n    };\n  }\n});\n","import { isReactive, isRef, isShallow, toRaw } from \"vue\";\nimport { definePayloadReducer } from \"../composables/payload.js\";\nimport { isNuxtError } from \"../composables/error.js\";\nimport { defineNuxtPlugin } from \"../nuxt.js\";\nimport { componentIslands } from \"#build/nuxt.config.mjs\";\nimport { isValidIslandKey } from \"./utils.js\";\nconst reducers = [\n  [\"NuxtError\", (data) => isNuxtError(data) && data.toJSON()],\n  [\"EmptyShallowRef\", (data) => isRef(data) && isShallow(data) && !data.value && (typeof data.value === \"bigint\" ? \"0n\" : JSON.stringify(data.value) || \"_\")],\n  [\"EmptyRef\", (data) => isRef(data) && !data.value && (typeof data.value === \"bigint\" ? \"0n\" : JSON.stringify(data.value) || \"_\")],\n  [\"ShallowRef\", (data) => isRef(data) && isShallow(data) && data.value],\n  [\"ShallowReactive\", (data) => isReactive(data) && isShallow(data) && toRaw(data)],\n  [\"Ref\", (data) => isRef(data) && data.value],\n  [\"Reactive\", (data) => isReactive(data) && toRaw(data)]\n];\nif (componentIslands) {\n  reducers.push([\"Island\", (data) => data && data?.__nuxt_island && isValidIslandKey(data.__nuxt_island.key) && data.__nuxt_island]);\n}\nexport default defineNuxtPlugin({\n  name: \"nuxt:revive-payload:server\",\n  setup() {\n    for (const [reducer, fn] of reducers) {\n      definePayloadReducer(reducer, fn);\n    }\n  }\n});\n","export default \"__VITE_ASSET__QXmx5Bsv__$_?nuxt_component=async&nuxt_component_name=IconAppstore&nuxt_component_export=default__\"","export default \"data:image/svg+xml,%3csvg%20width='8'%20height='9'%20viewBox='0%200%208%209'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M4.35356%200.146447C4.15829%20-0.0488157%203.84171%20-0.0488157%203.64645%200.146446L0.464468%203.32843C0.269206%203.52369%200.269206%203.84027%200.464468%204.03553C0.65973%204.23079%200.976313%204.2308%201.17157%204.03553L4%201.20711L6.82843%204.03554C7.02369%204.2308%207.34027%204.2308%207.53554%204.03554C7.7308%203.84027%207.7308%203.52369%207.53554%203.32843L4.35356%200.146447ZM4%209L4.5%209L4.5%200.5L4%200.5L3.5%200.5L3.5%209L4%209Z'%20fill='%23FA974C'/%3e%3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg%20width='18'%20height='15'%20viewBox='0%200%2018%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_1159_127)'%3e%3cpath%20d='M5.79545%208.40171C7.8231%2010.1013%209.14912%2012.3986%209.01395%2015L7.21802%2014.972L6.89832%2014.67C6.8361%2011.123%203.75921%208.54168%200.012874%208.39172L0%206.40025C3.75706%206.5742%207.05495%203.48302%206.86613%200.00195312H8.8895C9.29717%202.4353%207.69007%204.7027%206.01001%206.40225H18.0021V8.40171H5.79545Z'%20fill='%23767676'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_1159_127'%3e%3crect%20width='18'%20height='15'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg%20width='10'%20height='7'%20viewBox='0%200%2010%207'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M1.06348%201.30334L4.54525%204.78512L8.02702%201.30334'%20stroke='%23FA974C'%20stroke-width='1.98958'%20stroke-linecap='round'/%3e%3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg%20width='548'%20height='547'%20viewBox='0%200%20548%20547'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M273.591%201.71875C423.744%201.719%20545.463%20123.24%20545.463%20273.139C545.463%20423.037%20423.744%20544.557%20273.591%20544.558C123.438%20544.558%201.71901%20423.037%201.71875%20273.139C1.71875%20123.24%20123.437%201.71875%20273.591%201.71875Z'%20stroke='url(%23paint0_linear_1184_3)'%20stroke-opacity='0.81'%20stroke-width='3.4366'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_1184_3'%20x1='570.332'%20y1='272.829'%20x2='-29.7837'%20y2='272.829'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%237679F7'/%3e%3cstop%20offset='1'%20stop-color='%23FF9752'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg%20width='423'%20height='423'%20viewBox='0%200%20423%20423'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='211.463'%20cy='211.463'%20r='209.463'%20transform='rotate(90%20211.463%20211.463)'%20stroke='url(%23paint0_linear_1184_2)'%20stroke-width='3.4366'%20stroke-linejoin='round'%20/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_1184_2'%20x1='1.99998'%20y1='211.463'%20x2='385.931'%20y2='377.878'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23FF9751'%20/%3e%3cstop%20offset='1'%20stop-color='%23FFC89C'%20/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg%20width='423'%20height='423'%20viewBox='0%200%20423%20423'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='211.463'%20cy='211.463'%20r='209.463'%20transform='rotate(90%20211.463%20211.463)'%20stroke='url(%23paint0_linear_1184_4)'%20stroke-width='3.4366'%20stroke-linejoin='round'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_1184_4'%20x1='140.753'%20y1='371.955'%20x2='270.055'%20y2='420.926'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%237679F7'/%3e%3cstop%20offset='1'%20stop-color='%239C9EFF'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg%20width='15'%20height='15'%20viewBox='0%200%2015%2015'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cline%20x1='0.823223'%20y1='14.0835'%20x2='13.9823'%20y2='0.924392'%20stroke='black'%20stroke-width='0.5'/%3e%3cline%20y1='-0.25'%20x2='18.6098'%20y2='-0.25'%20transform='matrix(-0.707107%20-0.707107%20-0.707107%200.707107%2014%2014.2607)'%20stroke='black'%20stroke-width='0.5'/%3e%3c/svg%3e\"","export default \"__VITE_ASSET__zAfsrYYp__$_?nuxt_component=async&nuxt_component_name=IconGoogleplay&nuxt_component_export=default__\"","export default \"data:image/svg+xml,%3csvg%20width='20'%20height='10'%20viewBox='0%200%2020%2010'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cline%20x1='0.406738'%20y1='0.355115'%20x2='19.0165'%20y2='0.355115'%20stroke='black'%20stroke-width='0.443089'/%3e%3cline%20x1='0.406494'%20y1='4.78608'%20x2='19.0163'%20y2='4.78608'%20stroke='black'%20stroke-width='0.443089'/%3e%3cline%20x1='0.406494'%20y1='9.21699'%20x2='19.0163'%20y2='9.21699'%20stroke='black'%20stroke-width='0.443089'/%3e%3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg%20width='23'%20height='23'%20viewBox='0%200%2023%2023'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.4344%200H1.62924C0.728415%200%200%200.711175%200%201.59045V20.4732C0%2021.3525%200.728415%2022.068%201.62924%2022.068H20.4344C21.3352%2022.068%2022.068%2021.3525%2022.068%2020.4775V1.59045C22.068%200.711175%2021.3352%200%2020.4344%200ZM6.54712%2018.8052H3.2714V8.27118H6.54712V18.8052ZM4.90926%206.8359C3.85758%206.8359%203.00848%205.9868%203.00848%204.93943C3.00848%203.89206%203.85758%203.04297%204.90926%203.04297C5.95663%203.04297%206.80573%203.89206%206.80573%204.93943C6.80573%205.98249%205.95663%206.8359%204.90926%206.8359ZM18.8052%2018.8052H15.5338V13.6847C15.5338%2012.465%2015.5122%2010.8917%2013.8313%2010.8917C12.1288%2010.8917%2011.8702%2012.2236%2011.8702%2013.5985V18.8052H8.60306V8.27118H11.7408V9.71077H11.7839C12.2193%208.88322%2013.2882%208.00826%2014.8786%208.00826C18.1931%208.00826%2018.8052%2010.1892%2018.8052%2013.0253V18.8052Z'%20fill='black'/%3e%3c/svg%3e\"","export default \"__VITE_ASSET__CQj1s7yu__$_?nuxt_component=async&nuxt_component_name=IconLogotext&nuxt_component_export=default__\"","export default \"data:image/svg+xml,%3csvg%20width='65'%20height='55'%20viewBox='0%200%2065%2055'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M61.0455%2054.1211L63.9545%2048.8126C55.5909%2045.1516%2046.5%2036.9143%2046.5%2027.2126C46.5%2025.016%2046.8636%2022.8194%2047.9545%2020.4397C49.7727%2021.9041%2051.7727%2022.4533%2053.9545%2022.4533C59.2273%2022.4533%2064.5%2018.4262%2064.5%2012.2024C64.5%205.42956%2059.4091%200.121094%2051.9545%200.121094C41.5909%200.121094%2035.9545%209.45669%2035.9545%2019.7075C35.9545%2034.1685%2044.1364%2046.9821%2061.0455%2054.1211ZM25.5909%2054.1211L28.5%2048.8126C20.1364%2045.1516%2011.0455%2036.9143%2011.0455%2027.2126C11.0455%2025.016%2011.4091%2022.8194%2012.5%2020.4397C14.3182%2021.9041%2016.3182%2022.4533%2018.5%2022.4533C23.7727%2022.4533%2029.0455%2018.4262%2029.0455%2012.2024C29.0455%205.42956%2023.9545%200.121094%2016.5%200.121094C6.13637%200.121094%200.5%209.45669%200.5%2019.7075C0.5%2034.1685%208.68182%2046.9821%2025.5909%2054.1211Z'%20fill='black'/%3e%3c/svg%3e\"","export default \"data:image/svg+xml,%3csvg%20width='21'%20height='20'%20viewBox='0%200%2021%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.9994%200.891602H19.1013L12.3245%208.63699L20.2968%2019.1767H14.0546L9.16542%2012.7844L3.57111%2019.1767H0.467331L7.71574%2010.8922L0.0678711%200.891602H6.4686L10.888%206.7344L15.9994%200.891602ZM14.9107%2017.3201H16.6295L5.53465%202.65072H3.6902L14.9107%2017.3201Z'%20fill='black'/%3e%3c/svg%3e\"","import { defineNuxtPlugin } from '#app/nuxt'\nimport { LazyIconAppstore, LazyIconArrow, LazyIconArrowslide, LazyIconChevron, LazyIconCirclecenter, LazyIconCircleleft, LazyIconCircleright, LazyIconClose, LazyIconGoogleplay, LazyIconHamburger, LazyIconLinkedin, LazyIconLogotext, LazyIconQuote, LazyIconTwitter, LazySymbolInfo, LazyTickerTape } from '#components'\nconst lazyGlobalComponents = [\n  [\"IconAppstore\", LazyIconAppstore],\n[\"IconArrow\", LazyIconArrow],\n[\"IconArrowslide\", LazyIconArrowslide],\n[\"IconChevron\", LazyIconChevron],\n[\"IconCirclecenter\", LazyIconCirclecenter],\n[\"IconCircleleft\", LazyIconCircleleft],\n[\"IconCircleright\", LazyIconCircleright],\n[\"IconClose\", LazyIconClose],\n[\"IconGoogleplay\", LazyIconGoogleplay],\n[\"IconHamburger\", LazyIconHamburger],\n[\"IconLinkedin\", LazyIconLinkedin],\n[\"IconLogotext\", LazyIconLogotext],\n[\"IconQuote\", LazyIconQuote],\n[\"IconTwitter\", LazyIconTwitter],\n[\"SymbolInfo\", LazySymbolInfo],\n[\"TickerTape\", LazyTickerTape],\n  \n]\n\nexport default defineNuxtPlugin({\n  name: 'nuxt:global-components',\n  setup (nuxtApp) {\n    for (const [name, component] of lazyGlobalComponents) {\n      nuxtApp.vueApp.component(name, component)\n      nuxtApp.vueApp.component('Lazy' + name, component)\n    }\n  }\n})\n","import {\n  useNuxtApp,\n  useRequestEvent\n} from \"#app\";\nimport { defu } from \"defu\";\nimport { reactive, watchEffect } from \"vue\";\nexport function useSiteConfig(options) {\n  const stack = import.meta.server ? useRequestEvent()?.context.siteConfig.get(defu({ resolveRefs: true }, options)) : reactive({});\n  if (import.meta.client) {\n    watchEffect(() => {\n      const data = useNuxtApp().$nuxtSiteConfig.get(defu({ resolveRefs: true }, options));\n      if (stack && data) {\n        Object.assign(stack, data);\n      }\n    });\n  }\n  delete stack._priority;\n  return stack;\n}\n","import { injectHead } from \"#imports\";\nimport { useSiteConfig } from \"#site-config/app/composables/useSiteConfig\";\nimport { defineNuxtPlugin } from \"nuxt/app\";\nexport default defineNuxtPlugin(() => {\n  const head = injectHead();\n  if (!head)\n    return;\n  const siteConfig = useSiteConfig();\n  const input = {\n    meta: [],\n    templateParams: {\n      site: siteConfig,\n      // support legacy\n      siteUrl: siteConfig.url,\n      siteName: siteConfig.name\n    }\n  };\n  if (siteConfig.separator)\n    input.templateParams.separator = siteConfig.separator;\n  if (siteConfig.titleSeparator)\n    input.templateParams.titleSeparator = siteConfig.titleSeparator;\n  if (siteConfig.description) {\n    input.templateParams.siteDescription = siteConfig.description;\n    input.meta.push(\n      {\n        name: \"description\",\n        content: \"%site.description\",\n        tagPriority: \"low\"\n      }\n    );\n  }\n  head.push(input);\n});\n","import { injectHead } from \"#imports\";\nimport { InferSeoMetaPlugin } from \"@unhead/addons\";\nimport { defineNuxtPlugin } from \"nuxt/app\";\nimport { TemplateParamsPlugin } from \"unhead/plugins\";\nexport default defineNuxtPlugin(() => {\n  const head = injectHead();\n  if (!head)\n    return;\n  head.use(TemplateParamsPlugin);\n  head.use(InferSeoMetaPlugin());\n});\n","import { useHead } from \"#imports\";\nimport { defineNuxtPlugin, useError, useRoute } from \"nuxt/app\";\nimport { titleCase } from \"scule\";\nimport { withoutTrailingSlash } from \"ufo\";\nimport { computed } from \"vue\";\nexport default defineNuxtPlugin({\n  name: \"nuxt-seo:fallback-titles\",\n  env: {\n    islands: false\n  },\n  setup() {\n    const route = useRoute();\n    const err = useError();\n    const title = computed(() => {\n      if (err.value && [404, 500].includes(err.value?.statusCode)) {\n        return `${err.value.statusCode} - ${err.value.message}`;\n      }\n      if (typeof route.meta?.title === \"string\")\n        return route.meta?.title;\n      const path = withoutTrailingSlash(route.path || \"/\");\n      const lastSegment = path.split(\"/\").pop();\n      return lastSegment ? titleCase(lastSegment) : null;\n    });\n    const minimalPriority = {\n      // give nuxt.config values higher priority\n      tagPriority: 101\n    };\n    useHead({ title: () => title.value }, minimalPriority);\n  }\n});\n","import { defu } from \"defu\";\nimport { useRuntimeConfig } from \"nuxt/app\";\nexport function useSchemaOrgConfig() {\n  const runtimeConfig = useRuntimeConfig();\n  return defu(import.meta.client ? runtimeConfig.public[\"nuxt-schema-org\"] : runtimeConfig[\"nuxt-schema-org\"], {\n    scriptAttributes: {}\n  });\n}\n","import { useHead } from \"#imports\";\nimport { useSchemaOrgConfig } from \"../utils/config.js\";\nexport function useSchemaOrg(input) {\n  const config = useSchemaOrgConfig();\n  const script = {\n    type: \"application/ld+json\",\n    key: \"schema-org-graph\",\n    // @ts-expect-error untyped\n    nodes: input,\n    tagPriority: \"high\",\n    ...config.scriptAttributes\n  };\n  if (import.meta.dev) {\n    return useHead({\n      script: [script]\n    });\n  }\n  if (import.meta.server) {\n    return useHead({\n      script: [script]\n    });\n  } else if (config?.reactive) {\n    return useHead({\n      script: [script]\n    });\n  }\n}\n","import { hasProtocol, parseURL, withLeadingSlash, withoutTrailingSlash, withBase, withTrailingSlash } from 'ufo';\n\nfunction resolveSitePath(pathOrUrl, options) {\n  let path = pathOrUrl;\n  if (hasProtocol(pathOrUrl, { strict: false, acceptRelative: true })) {\n    const parsed = parseURL(pathOrUrl);\n    path = parsed.pathname;\n  }\n  const base = withLeadingSlash(options.base || \"/\");\n  if (base !== \"/\" && path.startsWith(base)) {\n    path = path.slice(base.length);\n  }\n  let origin = withoutTrailingSlash(options.absolute ? options.siteUrl : \"\");\n  if (base !== \"/\" && origin.endsWith(base)) {\n    origin = origin.slice(0, origin.indexOf(base));\n  }\n  const baseWithOrigin = options.withBase ? withBase(base, origin || \"/\") : origin;\n  const resolvedUrl = withBase(path, baseWithOrigin);\n  return path === \"/\" && !options.withBase ? withTrailingSlash(resolvedUrl) : fixSlashes(options.trailingSlash, resolvedUrl);\n}\nconst fileExtensions = [\n  // Images\n  \"jpg\",\n  \"jpeg\",\n  \"png\",\n  \"gif\",\n  \"bmp\",\n  \"webp\",\n  \"svg\",\n  \"ico\",\n  // Documents\n  \"pdf\",\n  \"doc\",\n  \"docx\",\n  \"xls\",\n  \"xlsx\",\n  \"ppt\",\n  \"pptx\",\n  \"txt\",\n  \"md\",\n  \"markdown\",\n  // Archives\n  \"zip\",\n  \"rar\",\n  \"7z\",\n  \"tar\",\n  \"gz\",\n  // Audio\n  \"mp3\",\n  \"wav\",\n  \"flac\",\n  \"ogg\",\n  \"opus\",\n  \"m4a\",\n  \"aac\",\n  \"midi\",\n  \"mid\",\n  // Video\n  \"mp4\",\n  \"avi\",\n  \"mkv\",\n  \"mov\",\n  \"wmv\",\n  \"flv\",\n  \"webm\",\n  // Web\n  \"html\",\n  \"css\",\n  \"js\",\n  \"json\",\n  \"xml\",\n  \"tsx\",\n  \"jsx\",\n  \"ts\",\n  \"vue\",\n  \"svelte\",\n  \"xsl\",\n  \"rss\",\n  \"atom\",\n  // Programming\n  \"php\",\n  \"py\",\n  \"rb\",\n  \"java\",\n  \"c\",\n  \"cpp\",\n  \"h\",\n  \"go\",\n  // Data formats\n  \"csv\",\n  \"tsv\",\n  \"sql\",\n  \"yaml\",\n  \"yml\",\n  // Fonts\n  \"woff\",\n  \"woff2\",\n  \"ttf\",\n  \"otf\",\n  \"eot\",\n  // Executables/Binaries\n  \"exe\",\n  \"msi\",\n  \"apk\",\n  \"ipa\",\n  \"dmg\",\n  \"iso\",\n  \"bin\",\n  // Scripts/Config\n  \"bat\",\n  \"cmd\",\n  \"sh\",\n  \"env\",\n  \"htaccess\",\n  \"conf\",\n  \"toml\",\n  \"ini\",\n  // Package formats\n  \"deb\",\n  \"rpm\",\n  \"jar\",\n  \"war\",\n  // E-books\n  \"epub\",\n  \"mobi\",\n  // Common temporary/backup files\n  \"log\",\n  \"tmp\",\n  \"bak\",\n  \"old\",\n  \"sav\"\n];\nfunction isPathFile(path) {\n  const lastSegment = path.split(\"/\").pop();\n  const ext = (lastSegment || path).match(/\\.[0-9a-z]+$/i)?.[0];\n  return ext && fileExtensions.includes(ext.replace(\".\", \"\"));\n}\nfunction fixSlashes(trailingSlash, pathOrUrl) {\n  const $url = parseURL(pathOrUrl);\n  if (isPathFile($url.pathname))\n    return pathOrUrl;\n  const fixedPath = trailingSlash ? withTrailingSlash($url.pathname) : withoutTrailingSlash($url.pathname);\n  return `${$url.protocol ? `${$url.protocol}//` : \"\"}${$url.host || \"\"}${fixedPath}${$url.search || \"\"}${$url.hash || \"\"}`;\n}\n\nexport { fixSlashes, isPathFile, resolveSitePath };\n","import { useRequestEvent } from \"#app\";\nexport function useNitroOrigin(e) {\n  if (import.meta.server) {\n    e = e || useRequestEvent();\n    return e?.context?.siteConfigNitroOrigin || \"\";\n  }\n  return window.location.origin;\n}\n","import { useRuntimeConfig } from \"#app\";\nimport { fixSlashes, resolveSitePath } from \"site-config-stack/urls\";\nimport { computed, unref } from \"vue\";\nimport { useNitroOrigin } from \"./useNitroOrigin.js\";\nimport { useSiteConfig } from \"./useSiteConfig.js\";\nexport function createSitePathResolver(options = {}) {\n  const siteConfig = useSiteConfig();\n  const nitroOrigin = useNitroOrigin();\n  const nuxtBase = useRuntimeConfig().app.baseURL || \"/\";\n  return (path) => {\n    return computed(() => resolveSitePath(unref(path), {\n      absolute: unref(options.absolute),\n      withBase: unref(options.withBase),\n      siteUrl: unref(options.canonical) !== false || import.meta.prerender ? siteConfig.url : nitroOrigin,\n      trailingSlash: siteConfig.trailingSlash,\n      base: nuxtBase\n    }));\n  };\n}\nexport function withSiteTrailingSlash(path) {\n  const siteConfig = useSiteConfig();\n  return computed(() => fixSlashes(siteConfig.trailingSlash, unref(path)));\n}\nexport function withSiteUrl(path, options = {}) {\n  const siteConfig = useSiteConfig();\n  const nitroOrigin = useNitroOrigin();\n  const base = useRuntimeConfig().app.baseURL || \"/\";\n  return computed(() => {\n    return resolveSitePath(unref(path), {\n      absolute: true,\n      siteUrl: unref(options.canonical) !== false || import.meta.prerender ? siteConfig.url : nitroOrigin,\n      trailingSlash: siteConfig.trailingSlash,\n      base,\n      withBase: unref(options.withBase)\n    });\n  });\n}\n","import { injectHead, useHead } from \"#imports\";\nimport {\n  useSiteConfig\n} from \"#site-config/app/composables/useSiteConfig\";\nimport { createSitePathResolver } from \"#site-config/app/composables/utils\";\nimport { SchemaOrgUnheadPlugin } from \"@unhead/schema-org/vue\";\nimport { useRoute } from \"nuxt/app\";\nimport { camelCase } from \"scule\";\nimport { withTrailingSlash } from \"ufo\";\nimport { computed, toValue, watch } from \"vue\";\nimport { useSchemaOrg } from \"../composables/useSchemaOrg.js\";\nimport { useSchemaOrgConfig } from \"./config.js\";\nexport function initPlugin(nuxtApp) {\n  const head = injectHead();\n  const config = useSchemaOrgConfig();\n  const route = useRoute();\n  const siteConfig = useSiteConfig();\n  const resolvePath = createSitePathResolver({\n    absolute: false,\n    withBase: true\n  });\n  const resolveUrl = createSitePathResolver({\n    canonical: true,\n    absolute: true,\n    withBase: true\n  });\n  const schemaOrg = computed(() => {\n    const siteConfigResolved = {};\n    for (const key in siteConfig) {\n      if (key.startsWith(\"_\")) {\n        continue;\n      }\n      siteConfigResolved[key] = toValue(siteConfig[key]);\n      if (typeof siteConfigResolved[key] === \"object\") {\n        for (const k in siteConfigResolved[key]) {\n          siteConfigResolved[key][k] = toValue(siteConfigResolved[key][k]);\n        }\n      }\n    }\n    return {\n      ...route.meta?.schemaOrg || {},\n      ...siteConfigResolved,\n      url: toValue(resolveUrl(route.path)),\n      host: withTrailingSlash(siteConfigResolved.url),\n      inLanguage: toValue(siteConfigResolved.currentLocale) || toValue(siteConfigResolved.defaultLocale),\n      path: toValue(resolvePath(route.path))\n    };\n  });\n  const templateParamEntry = useHead({\n    templateParams: { schemaOrg: schemaOrg.value }\n  });\n  watch(() => siteConfig, () => {\n    templateParamEntry.patch({\n      templateParams: { schemaOrg: schemaOrg.value }\n    });\n  }, { deep: true });\n  head.use(\n    SchemaOrgUnheadPlugin({}, async () => {\n      const meta = {};\n      await nuxtApp.hooks.callHook(\"schema-org:meta\", meta);\n      return meta;\n    }, {\n      minify: config.minify,\n      trailingSlash: siteConfig.trailingSlash\n    })\n  );\n}\nexport function maybeAddIdentitySchemaOrg() {\n  const config = useSchemaOrgConfig();\n  const siteConfig = useSiteConfig({\n    resolveRefs: true\n  });\n  if (config.identity || siteConfig.identity) {\n    const identity = config.identity || siteConfig.identity;\n    let identityPayload = {\n      name: () => toValue(siteConfig.name),\n      url: () => toValue(siteConfig.url)\n    };\n    let identityType;\n    if (typeof identity !== \"string\") {\n      identityPayload = {\n        ...identityPayload,\n        ...identity\n      };\n      identityType = identity.type;\n      delete identityPayload.type;\n    } else {\n      identityType = identity;\n    }\n    if (siteConfig.twitter) {\n      const id = siteConfig.twitter.startsWith(\"@\") ? siteConfig.twitter.slice(1) : siteConfig.twitter;\n      identityPayload.sameAs = [\n        `https://twitter.com/${id}`\n      ];\n    }\n    identityPayload._resolver = identityPayload._resolver || camelCase(identityType);\n    useSchemaOrg([identityPayload]);\n  }\n}\n","import { useSiteConfig } from \"#site-config/app/composables/useSiteConfig\";\nimport { defineWebPage, defineWebSite } from \"@unhead/schema-org/vue\";\nimport { defineNuxtPlugin, useError } from \"nuxt/app\";\nimport { toValue } from \"vue\";\nimport { useSchemaOrg } from \"../composables/useSchemaOrg.js\";\nimport { maybeAddIdentitySchemaOrg } from \"../utils/shared.js\";\nexport default defineNuxtPlugin({\n  name: \"nuxt-schema-org:defaults\",\n  dependsOn: [\n    \"nuxt-schema-org:init\"\n  ],\n  setup() {\n    const error = useError();\n    if (error.value?.error) {\n      return;\n    }\n    const siteConfig = useSiteConfig();\n    useSchemaOrg([\n      defineWebSite({\n        name: () => toValue(siteConfig.name) || \"\",\n        inLanguage: () => toValue(siteConfig.currentLocale) || \"\",\n        description: () => toValue(siteConfig.description) || \"\"\n      }),\n      defineWebPage()\n    ]);\n    maybeAddIdentitySchemaOrg();\n  }\n});\n","import { defineNuxtPlugin } from \"nuxt/app\";\nimport { initPlugin } from \"../utils/shared.js\";\nexport default defineNuxtPlugin({\n  name: \"nuxt-schema-org:init\",\n  setup(nuxtApp) {\n    initPlugin(nuxtApp);\n  }\n});\n","import { useHead } from \"#imports\";\nimport { defineNuxtPlugin, useRequestEvent } from \"nuxt/app\";\nexport default defineNuxtPlugin({\n  setup() {\n    const event = useRequestEvent();\n    const ctx = event?.context?.robots;\n    if (!ctx)\n      return;\n    useHead({\n      meta: [\n        {\n          \"name\": \"robots\",\n          \"content\": () => ctx.rule || \"\",\n          \"data-hint\": () => import.meta.dev && ctx.debug?.source ? [ctx.debug?.source, ctx.debug?.line].filter(Boolean).join(\",\") : void 0\n        }\n      ]\n    });\n  }\n});\n","export const REGEX_CRAWLER = new RegExp(/Googlebot\\/|Googlebot-Mobile|Googlebot-Image|Googlebot-News|Googlebot-Video|AdsBot-Google([^-]|$)|AdsBot-Google-Mobile|Feedfetcher-Google|Mediapartners-Google|Mediapartners \\(Googlebot\\)|APIs-Google|Google-InspectionTool|Storebot-Google|GoogleOther|bingbot|Slurp|[wW]get|LinkedInBot|Python-urllib|python-requests|aiohttp|httpx|libwww-perl|httpunit|Nutch|Go-http-client|phpcrawl|msnbot|jyxobot|FAST-WebCrawler|FAST Enterprise Crawler|BIGLOTRON|Teoma|convera|seekbot|Gigabot|Gigablast|exabot|ia_archiver|GingerCrawler|webmon |HTTrack|grub\\.org|UsineNouvelleCrawler|antibot|netresearchserver|speedy|fluffy|findlink|msrbot|panscient|yacybot|AISearchBot|ips-agent|tagoobot|MJ12bot|woriobot|yanga|buzzbot|mlbot|yandex\\.com\\/bots|purebot|Linguee Bot|CyberPatrol|voilabot|Baiduspider|citeseerxbot|spbot|twengabot|postrank|Turnitin|scribdbot|page2rss|sitebot|linkdex|Adidxbot|ezooms|dotbot|Mail\\.RU_Bot|discobot|heritrix|findthatfile|europarchive\\.org|NerdByNature\\.Bot|(sistrix|SISTRIX) [cC]rawler|Ahrefs(Bot|SiteAudit)|fuelbot|CrunchBot|IndeedBot|mappydata|woobot|ZoominfoBot|PrivacyAwareBot|Multiviewbot|SWIMGBot|Grobbot|eright|Apercite|semanticbot|Aboundex|domaincrawler|wbsearchbot|summify|CCBot|edisterbot|SeznamBot|ec2linkfinder|gslfbot|aiHitBot|intelium_bot|facebookexternalhit|Yeti|RetrevoPageAnalyzer|lb-spider|Sogou|lssbot|careerbot|wotbox|wocbot|ichiro|DuckDuckBot|lssrocketcrawler|drupact|webcompanycrawler|acoonbot|openindexspider|gnam gnam spider|web-archive-net\\.com\\.bot|backlinkcrawler|coccoc|integromedb|content crawler spider|toplistbot|it2media-domain-crawler|ip-web-crawler\\.com|siteexplorer\\.info|elisabot|proximic|changedetection|arabot|WeSEE:Search|niki-bot|CrystalSemanticsBot|rogerbot|360Spider|psbot|InterfaxScanBot|CC Metadata Scaper|g00g1e\\.net|GrapeshotCrawler|urlappendbot|brainobot|fr-crawler|binlar|SimpleCrawler|Twitterbot|cXensebot|smtbot|bnf\\.fr_bot|A6-Indexer|ADmantX|Facebot|OrangeBot\\/|memorybot|AdvBot|MegaIndex|SemanticScholarBot|ltx71|nerdybot|xovibot|BUbiNG|Qwantify|archive\\.org_bot|Applebot|TweetmemeBot|crawler4j|findxbot|S[eE][mM]rushBot|yoozBot|lipperhey|Y!J|Domain Re-Animator Bot|AddThis|Screaming Frog SEO Spider|MetaURI|Scrapy|Livelap[bB]ot|OpenHoseBot|CapsuleChecker|collection@infegy\\.com|IstellaBot|DeuSu\\/|betaBot|Cliqzbot\\/|MojeekBot\\/|netEstate NE Crawler|SafeSearch microdata crawler|Gluten Free Crawler\\/|Sonic|Sysomos|Trove|deadlinkchecker|Slack-ImgProxy|Embedly|RankActiveLinkBot|iskanie|SafeDNSBot|SkypeUriPreview|Veoozbot|Slackbot|redditbot|datagnionbot|Google-Adwords-Instant|adbeat_bot|WhatsApp|contxbot|pinterest\\.com\\/bot|electricmonk|GarlikCrawler|BingPreview\\/|vebidoobot|FemtosearchBot|Yahoo Link Preview|MetaJobBot|DomainStatsBot|mindUpBot|Daum\\/|Jugendschutzprogramm-Crawler|Xenu Link Sleuth|Pcore-HTTP|moatbot|KosmioBot|[pP]ingdom|AppInsights|PhantomJS|Gowikibot|PiplBot|Discordbot|TelegramBot|Jetslide|newsharecounts|James BOT|Bark[rR]owler|TinEye|SocialRankIOBot|trendictionbot|Ocarinabot|epicbot|Primalbot|DuckDuckGo-Favicons-Bot|GnowitNewsbot|Leikibot|LinkArchiver|YaK\\/|PaperLiBot|Digg Deeper|dcrawl|Snacktory|AndersPinkBot|Fyrebot|EveryoneSocialBot|Mediatoolkitbot|Luminator-robots|ExtLinksBot|SurveyBot|NING\\/|okhttp|Nuzzel|omgili|PocketParser|YisouSpider|um-LN|ToutiaoSpider|MuckRack|Jamie's Spider|AHC\\/|NetcraftSurveyAgent|Laserlikebot|^Apache-HttpClient|AppEngine-Google|Jetty|Upflow|Thinklab|Traackr\\.com|Twurly|Mastodon|http_get|DnyzBot|botify|007ac9 Crawler|BehloolBot|BrandVerity|check_http|BDCbot|ZumBot|EZID|ICC-Crawler|ArchiveBot|^LCC |filterdb\\.iss\\.net\\/crawler|BLP_bbot|BomboraBot|Buck\\/|Companybook-Crawler|Genieo|magpie-crawler|MeltwaterNews|Moreover|newspaper\\/|ScoutJet|(^| )sentry\\/|StorygizeBot|UptimeRobot|OutclicksBot|seoscanners|Hatena|Google Web Preview|MauiBot|AlphaBot|SBL-BOT|IAS crawler|adscanner|Netvibes|acapbot|Baidu-YunGuanCe|bitlybot|blogmuraBot|Bot\\.AraTurka\\.com|bot-pge\\.chlooe\\.com|BoxcarBot|BTWebClient|ContextAd Bot|Digincore bot|Disqus|Feedly|Fetch\\/|Fever|Flamingo_SearchEngine|FlipboardProxy|g2reader-bot|G2 Web Services|imrbot|K7MLWCBot|Kemvibot|Landau-Media-Spider|linkapediabot|vkShare|Siteimprove\\.com|BLEXBot\\/|DareBoost|ZuperlistBot\\/|Miniflux\\/|Feedspot|Diffbot\\/|SEOkicks|tracemyfile|Nimbostratus-Bot|zgrab|PR-CY\\.RU|AdsTxtCrawler|Datafeedwatch|Zabbix|TangibleeBot|google-xrawler|axios|Amazon CloudFront|Pulsepoint|CloudFlare-AlwaysOnline|Google-Structured-Data-Testing-Tool|WordupInfoSearch|WebDataStats|HttpUrlConnection|ZoomBot|VelenPublicWebCrawler|MoodleBot|jpg-newsbot|outbrain|W3C_Validator|Validator\\.nu|W3C-checklink|W3C-mobileOK|W3C_I18n-Checker|FeedValidator|W3C_CSS_Validator|W3C_Unicorn|Google-PhysicalWeb|Blackboard|ICBot\\/|BazQux|Twingly|Rivva|Experibot|awesomecrawler|Dataprovider\\.com|GroupHigh\\/|theoldreader\\.com|AnyEvent|Uptimebot\\.org|Nmap Scripting Engine|2ip\\.ru|Clickagy|Caliperbot|MBCrawler|online-webceo-bot|B2B Bot|AddSearchBot|Google Favicon|HubSpot|Chrome-Lighthouse|HeadlessChrome|CheckMarkNetwork\\/|www\\.uptime\\.com|Streamline3Bot\\/|serpstatbot\\/|MixnodeCache\\/|^curl|SimpleScraper|RSSingBot|Jooblebot|fedoraplanet|Friendica|NextCloud|Tiny Tiny RSS|RegionStuttgartBot|Bytespider|Datanyze|Google-Site-Verification|TrendsmapResolver|tweetedtimes|NTENTbot|Gwene|SimplePie|SearchAtlas|Superfeedr|feedbot|UT-Dorkbot|Amazonbot|SerendeputyBot|Eyeotabot|officestorebot|Neticle Crawler|SurdotlyBot|LinkisBot|AwarioSmartBot|AwarioRssBot|RyteBot|FreeWebMonitoring SiteChecker|AspiegelBot|NAVER Blog Rssbot|zenback bot|SentiBot|Domains Project\\/|Pandalytics|VKRobot|bidswitchbot|tigerbot|NIXStatsbot|Atom Feed Robot|[Cc]urebot|PagePeeker\\/|Vigil\\/|rssbot\\/|startmebot\\/|JobboerseBot|seewithkids|NINJA bot|Cutbot|BublupBot|BrandONbot|RidderBot|Taboolabot|Dubbotbot|FindITAnswersbot|infoobot|Refindbot|BlogTraffic\\/\\d\\.\\d+ Feed-Fetcher|SeobilityBot|Cincraw|Dragonbot|VoluumDSP-content-bot|FreshRSS|BitBot|^PHP-Curl-Class|Google-Certificates-Bridge|centurybot|Viber|e\\.ventures Investment Crawler|evc-batch|PetalBot|virustotal|(^| )PTST\\/|minicrawler|Cookiebot|trovitBot|seostar\\.co|IonCrawl|Uptime-Kuma|Seekport|FreshpingBot|Feedbin|CriteoBot|Snap URL Preview Service|Better Uptime Bot|RuxitSynthetic|Google-Read-Aloud|Valve\\/Steam|OdklBot\\/|GPTBot|ChatGPT-User|YandexRenderResourcesBot\\/|LightspeedSystemsCrawler|ev-crawler\\/|BitSightBot\\/|woorankreview\\/|Google-Safety|AwarioBot|DataForSeoBot|Linespider|WellKnownBot|A Patent Crawler|StractBot|search\\.marginalia\\.nu|YouBot|Nicecrawler|Neevabot|BrightEdge Crawler|SiteCheckerBotCrawler|TombaPublicWebCrawler|CrawlyProjectCrawler|KomodiaBot|KStandBot|CISPA Webcrawler|MTRobot|hyscore\\.io|AlexandriaOrgBot|2ip bot|Yellowbrandprotectionbot|SEOlizer|vuhuvBot|INETDEX-BOT|Synapse|t3versionsBot|deepnoc|Cocolyzebot|hypestat|ReverseEngineeringBot|sempi\\.tech|Iframely|MetaInspector|node-fetch|lkxscan|python-opengraph|OpenGraphCheck|developers\\.google\\.com\\/\\+\\/web\\/snippet|SenutoBot|MaCoCu|NewsBlur|inoreader|NetSystemsResearch|PageThing|WordPress\\/|PhxBot|ImagesiftBot|Expanse|InternetMeasurement|^BW\\/|GeedoBot|Audisto Crawler|PerplexityBot\\/|[cC]laude[bB]ot|Monsidobot|GroupMeBot|Vercelbot|vercel-screenshot/)","import { REGEX_CRAWLER } from \"#build/nuxtjs-device.mjs\";\nconst REGEX_MOBILE1 = /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|FBAN|FBAV|fennec|hiptop|iemobile|ip(hone|od)|Instagram|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i;\nconst REGEX_MOBILE2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i;\nconst REGEX_MOBILE_OR_TABLET1 = /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|FBAN|FBAV|fennec|hiptop|iemobile|ip(hone|od)|Instagram|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;\nconst REGEX_MOBILE_OR_TABLET2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i;\nfunction isMobile(userAgent) {\n  return REGEX_MOBILE1.test(userAgent) || REGEX_MOBILE2.test(userAgent.slice(0, 4));\n}\nfunction isMobileOrTablet(userAgent) {\n  return REGEX_MOBILE_OR_TABLET1.test(userAgent) || REGEX_MOBILE_OR_TABLET2.test(userAgent.slice(0, 4));\n}\nfunction isIos(userAgent) {\n  return /iPad|iPhone|iPod/.test(userAgent);\n}\nfunction isAndroid(userAgent) {\n  return /android/i.test(userAgent);\n}\nfunction isWindows(userAgent) {\n  return /Windows/.test(userAgent);\n}\nfunction isMacOS(userAgent) {\n  return /Mac OS X/.test(userAgent);\n}\nconst browsers = [\n  { name: \"Samsung\", regex: /SamsungBrowser/i },\n  { name: \"Edge\", regex: /edg(?:[ea]|ios)?\\//i },\n  { name: \"Firefox\", regex: /firefox|iceweasel|fxios/i },\n  { name: \"Chrome\", regex: /chrome|crios|crmo/i },\n  { name: \"Safari\", regex: /safari|applewebkit/i }\n];\nfunction getBrowserName(userAgent) {\n  for (const browser of browsers) {\n    if (browser.regex.test(userAgent)) {\n      return browser.name;\n    }\n  }\n  return \"\";\n}\nexport default function generateFlags(userAgent, headers = {}) {\n  let mobile = false;\n  let mobileOrTablet = false;\n  let ios = false;\n  let android = false;\n  if (userAgent === \"Amazon CloudFront\") {\n    if (headers[\"cloudfront-is-mobile-viewer\"] === \"true\") {\n      mobile = true;\n      mobileOrTablet = true;\n    }\n    if (headers[\"cloudfront-is-tablet-viewer\"] === \"true\") {\n      mobile = false;\n      mobileOrTablet = true;\n    }\n    if (headers[\"cloudfront-is-desktop-viewer\"] === \"true\") {\n      mobile = false;\n      mobileOrTablet = false;\n    }\n    if (headers[\"cloudfront-is-ios-viewer\"] === \"true\") {\n      ios = true;\n    }\n    if (headers[\"cloudfront-is-android-viewer\"] === \"true\") {\n      android = true;\n    }\n  } else if (headers && headers[\"cf-device-type\"]) {\n    switch (headers[\"cf-device-type\"]) {\n      case \"mobile\":\n        mobile = true;\n        mobileOrTablet = true;\n        break;\n      case \"tablet\":\n        mobile = false;\n        mobileOrTablet = true;\n        break;\n      case \"desktop\":\n        mobile = false;\n        mobileOrTablet = false;\n        break;\n    }\n  } else {\n    mobile = isMobile(userAgent);\n    mobileOrTablet = isMobileOrTablet(userAgent);\n    ios = isIos(userAgent);\n    android = isAndroid(userAgent);\n  }\n  const windows = isWindows(userAgent);\n  const macOS = isMacOS(userAgent);\n  const browserName = getBrowserName(userAgent);\n  const isSafari = browserName === \"Safari\";\n  const isFirefox = browserName === \"Firefox\";\n  const isEdge = browserName === \"Edge\";\n  const isChrome = browserName === \"Chrome\";\n  const isSamsung = browserName === \"Samsung\";\n  const isCrawler = REGEX_CRAWLER.test(userAgent);\n  return {\n    userAgent,\n    isMobile: mobile,\n    isMobileOrTablet: mobileOrTablet,\n    isTablet: !mobile && mobileOrTablet,\n    isDesktop: !mobileOrTablet,\n    isIos: ios,\n    isAndroid: android,\n    isWindows: windows,\n    isMacOS: macOS,\n    isApple: macOS || ios,\n    isDesktopOrTablet: !mobile,\n    isSafari,\n    isFirefox,\n    isEdge,\n    isChrome,\n    isSamsung,\n    isCrawler\n  };\n}\n","import generateFlags from \"./generateFlags.js\";\nimport { defineNuxtPlugin, reactive, useRequestHeaders, useRuntimeConfig } from \"#imports\";\nexport default defineNuxtPlugin(() => {\n  const runtimeConfig = useRuntimeConfig();\n  const defaultUserAgent = runtimeConfig.public.device.defaultUserAgent;\n  let flags;\n  if (import.meta.server) {\n    const headers = useRequestHeaders();\n    const userAgent = headers[\"user-agent\"] || defaultUserAgent;\n    flags = reactive(generateFlags(userAgent, headers));\n  } else {\n    const userAgent = navigator.userAgent || defaultUserAgent;\n    flags = reactive(generateFlags(userAgent));\n    if (runtimeConfig.public.device.refreshOnResize) {\n      window.addEventListener(\"resize\", () => {\n        setTimeout(() => {\n          const newFlags = generateFlags(navigator.userAgent || userAgent);\n          Object.entries(newFlags).forEach(([key, value]) => {\n            flags[key] = value;\n          });\n        }, 50);\n      });\n    }\n  }\n  return {\n    provide: {\n      device: flags\n    }\n  };\n});\n","import { injectHead } from \"#imports\";\nimport { createSitePathResolver } from \"#site-config/app/composables/utils\";\nimport { defineNuxtPlugin } from \"nuxt/app\";\nimport { unref } from \"vue\";\nexport default defineNuxtPlugin({\n  enforce: \"post\",\n  setup() {\n    const head = injectHead();\n    if (!head)\n      return;\n    const resolver = createSitePathResolver({\n      withBase: true,\n      absolute: true,\n      canonical: true\n    });\n    head.use({\n      key: \"absoluteImageUrls\",\n      hooks: {\n        \"tags:resolve\": async ({ tags }) => {\n          for (const tag of tags) {\n            if (tag.tag !== \"meta\")\n              continue;\n            if (tag.props.property !== \"og:image:url\" && tag.props.property !== \"og:image\" && tag.props.name !== \"twitter:image\")\n              continue;\n            if (typeof tag.props.content !== \"string\" || !tag.props.content.trim() || tag.props.content.startsWith(\"http\") || tag.props.content.startsWith(\"//\"))\n              continue;\n            tag.props.content = unref(resolver(tag.props.content));\n          }\n        }\n      }\n    });\n  }\n});\n","import { injectHead, useSeoMeta } from \"#imports\";\nimport { defineNuxtPlugin, getRouteRules, useRequestEvent, useState } from \"nuxt/app\";\nexport default defineNuxtPlugin({\n  enforce: \"post\",\n  async setup() {\n    const head = injectHead();\n    const routeRuleState = useState(\"nuxt-seo-utils:routeRules\", () => null);\n    if (import.meta.server) {\n      const event = useRequestEvent();\n      const routeRules = await getRouteRules(event);\n      routeRuleState.value = {\n        head: routeRules.head,\n        seoMeta: routeRules.seoMeta\n      };\n    }\n    if (routeRuleState.value) {\n      const { head: headInput, seoMeta } = routeRuleState.value;\n      if (headInput)\n        head.push(headInput);\n      if (seoMeta)\n        useSeoMeta(seoMeta);\n    }\n  }\n});\n","import { injectHead, useHead, useSeoMeta } from \"#imports\";\nimport { useSiteConfig } from \"#site-config/app/composables/useSiteConfig\";\nimport { createSitePathResolver } from \"#site-config/app/composables/utils\";\nimport { TemplateParamsPlugin } from \"@unhead/vue/plugins\";\nimport { useError, useRoute, useRuntimeConfig } from \"nuxt/app\";\nimport { stringifyQuery } from \"ufo\";\nimport { computed, toValue } from \"vue\";\nexport function applyDefaults() {\n  const siteConfig = useSiteConfig({\n    resolveRefs: false\n  });\n  const resolveCurrentLocale = () => toValue(siteConfig.currentLocale) || toValue(siteConfig.defaultLocale) || \"en\";\n  const head = injectHead();\n  head.use(TemplateParamsPlugin);\n  const { canonicalQueryWhitelist, canonicalLowercase } = useRuntimeConfig().public[\"seo-utils\"];\n  const route = useRoute();\n  const resolveUrl = createSitePathResolver({ withBase: true, absolute: true });\n  const err = useError();\n  const canonicalUrl = computed(() => {\n    if (err.value) {\n      return false;\n    }\n    const { query } = route;\n    let url = resolveUrl(route.path || \"/\").value || route.path;\n    if (canonicalLowercase) {\n      try {\n        url = url.toLocaleLowerCase(resolveCurrentLocale());\n      } catch {\n        url = url.toLowerCase();\n      }\n    }\n    const filteredQuery = Object.fromEntries(\n      Object.entries(query).filter(([key]) => canonicalQueryWhitelist.includes(key)).sort(([a], [b]) => a.localeCompare(b))\n      // Sort params\n    );\n    const href = Object.keys(filteredQuery).length ? `${url}?${stringifyQuery(filteredQuery)}` : url;\n    return { rel: \"canonical\", href };\n  });\n  const minimalPriority = {\n    // give nuxt.config values higher priority\n    tagPriority: \"low\"\n  };\n  useHead({\n    htmlAttrs: { lang: resolveCurrentLocale },\n    templateParams: {\n      site: () => siteConfig,\n      siteName: () => siteConfig.name\n    },\n    titleTemplate: \"%s %separator %siteName\",\n    link: [() => canonicalUrl.value]\n  }, minimalPriority);\n  const seoMeta = {\n    ogType: \"website\",\n    ogUrl: () => {\n      const url = canonicalUrl.value;\n      return url ? url.href : false;\n    },\n    ogLocale: () => {\n      const locale = resolveCurrentLocale();\n      if (locale) {\n        const l = locale.replace(\"-\", \"_\");\n        if (l.includes(\"_\")) {\n          return l;\n        }\n      }\n      return false;\n    },\n    ogSiteName: siteConfig.name\n  };\n  if (siteConfig.description)\n    seoMeta.description = siteConfig.description;\n  if (siteConfig.twitter) {\n    const id = siteConfig.twitter.startsWith(\"@\") ? siteConfig.twitter : `@${siteConfig.twitter}`;\n    seoMeta.twitterCreator = id;\n    seoMeta.twitterSite = id;\n  }\n  useSeoMeta(seoMeta, minimalPriority);\n}\n","import { defineNuxtPlugin } from \"nuxt/app\";\nimport { applyDefaults } from \"../logic/applyDefaults.js\";\nexport default defineNuxtPlugin({\n  name: \"nuxt-seo:defaults\",\n  order: 999,\n  env: {\n    islands: false\n  },\n  setup() {\n    applyDefaults();\n  }\n});\n","import unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt/dist/head/runtime/plugins/unhead.js\";\nimport router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt/dist/pages/runtime/plugins/router.js\";\nimport _0_siteConfig_tU0SxKrPeVRXWcGu2sOnIfhNDbYiKNfDCvYZhRueG0Q from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-site-config/dist/runtime/app/plugins/0.siteConfig.js\";\nimport revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt/dist/app/plugins/revive-payload.server.js\";\nimport components_plugin_z4hgvsiddfKkfXTP6M8M4zG5Cb7sGnDhcryKVM45Di4 from \"/Users/marina/Trabajos/Pia/solstrategies/repository/.nuxt/components.plugin.mjs\";\nimport siteConfig_vuqmRkLAUZxQvb5pvUwT3uUdVggfjhj1m5v7Pb6IE0w from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-seo-utils/dist/runtime/app/plugins/siteConfig.js\";\nimport inferSeoMetaPlugin_KsEotgC9NJyW_guR_3z04hFN8TI2h5dgP8bzHmpMm5o from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-seo-utils/dist/runtime/app/plugins/inferSeoMetaPlugin.js\";\nimport titles_Fth_MAhm7dgpxeTaMXibYXbcCjegjWK3QH9gKvbTRVg from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-seo-utils/dist/runtime/app/plugins/titles.js\";\nimport defaults_ZjgoYqsIrjWNaJMfDhci2B0eoNnvY4CDsoscm0L1fE0 from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-schema-org/dist/runtime/app/plugins/defaults.js\";\nimport init_Ks1wcI1vuv3K3FXG7iAYRqIWlPli19G_eByed0tsXe0 from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-schema-org/dist/runtime/app/plugins/init.js\";\nimport robot_meta_server_bRHpso_4KN_Ec3RJzqCvbuvfZsNOeE_4TgpL8dCNuwk from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/@nuxtjs/robots/dist/runtime/app/plugins/robot-meta.server.js\";\nimport plugin_vz9iHc7_bD8KQzUq6ZprTRfi1svzocRN0YrDyAJWMCk from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/@nuxtjs/device/dist/runtime/plugin.js\";\nimport _1_absoluteImageUrls_server_2YTf8dZl0nl5nVc1xW7fV_4mFLM_syJu2DEHHvxD9lg from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-seo-utils/dist/runtime/app/plugins/1.absoluteImageUrls.server.js\";\nimport _0_routeRules_3p7F2AZYQSP_eJRsw5nLkf3zyZXPOFcTrXNpZlBwROM from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-seo-utils/dist/runtime/app/plugins/0.routeRules.js\";\nimport defaults_0Sn7xIMAzGkdbab2otVWD8mX4GpY74A3Jy_gY_4_qYk from \"/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/nuxt-seo-utils/dist/runtime/app/plugins/defaults.js\";\nexport default [\n  unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU,\n  router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw,\n  _0_siteConfig_tU0SxKrPeVRXWcGu2sOnIfhNDbYiKNfDCvYZhRueG0Q,\n  revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms,\n  components_plugin_z4hgvsiddfKkfXTP6M8M4zG5Cb7sGnDhcryKVM45Di4,\n  siteConfig_vuqmRkLAUZxQvb5pvUwT3uUdVggfjhj1m5v7Pb6IE0w,\n  inferSeoMetaPlugin_KsEotgC9NJyW_guR_3z04hFN8TI2h5dgP8bzHmpMm5o,\n  titles_Fth_MAhm7dgpxeTaMXibYXbcCjegjWK3QH9gKvbTRVg,\n  defaults_ZjgoYqsIrjWNaJMfDhci2B0eoNnvY4CDsoscm0L1fE0,\n  init_Ks1wcI1vuv3K3FXG7iAYRqIWlPli19G_eByed0tsXe0,\n  robot_meta_server_bRHpso_4KN_Ec3RJzqCvbuvfZsNOeE_4TgpL8dCNuwk,\n  plugin_vz9iHc7_bD8KQzUq6ZprTRfi1svzocRN0YrDyAJWMCk,\n  _1_absoluteImageUrls_server_2YTf8dZl0nl5nVc1xW7fV_4mFLM_syJu2DEHHvxD9lg,\n  _0_routeRules_3p7F2AZYQSP_eJRsw5nLkf3zyZXPOFcTrXNpZlBwROM,\n  defaults_0Sn7xIMAzGkdbab2otVWD8mX4GpY74A3Jy_gY_4_qYk\n]","import { defineComponent, inject, onUnmounted, provide, reactive } from \"vue\";\nimport { useHead } from \"#app/composables/head\";\nconst HeadComponentCtxSymbol = Symbol(\"head-component\");\nconst TagPositionProps = {\n  /**\n   * @deprecated Use tagPosition\n   */\n  body: { type: Boolean, default: void 0 },\n  tagPosition: { type: String }\n};\nconst normalizeProps = (_props) => {\n  const props = Object.fromEntries(\n    Object.entries(_props).filter(([_, value]) => value !== void 0)\n  );\n  if (typeof props.body !== \"undefined\") {\n    props.tagPosition = props.body ? \"bodyClose\" : \"head\";\n  }\n  if (typeof props.renderPriority !== \"undefined\") {\n    props.tagPriority = props.renderPriority;\n  }\n  return props;\n};\nfunction useHeadComponentCtx() {\n  return inject(HeadComponentCtxSymbol, createHeadComponentCtx, true);\n}\nfunction createHeadComponentCtx() {\n  const prev = inject(HeadComponentCtxSymbol, null);\n  if (prev) {\n    return prev;\n  }\n  const input = reactive({});\n  const entry = useHead(input);\n  const ctx = { input, entry };\n  provide(HeadComponentCtxSymbol, ctx);\n  return ctx;\n}\nconst globalProps = {\n  accesskey: String,\n  autocapitalize: String,\n  autofocus: {\n    type: Boolean,\n    default: void 0\n  },\n  class: { type: [String, Object, Array], default: void 0 },\n  contenteditable: {\n    type: Boolean,\n    default: void 0\n  },\n  contextmenu: String,\n  dir: String,\n  draggable: {\n    type: Boolean,\n    default: void 0\n  },\n  enterkeyhint: String,\n  exportparts: String,\n  hidden: {\n    type: Boolean,\n    default: void 0\n  },\n  id: String,\n  inputmode: String,\n  is: String,\n  itemid: String,\n  itemprop: String,\n  itemref: String,\n  itemscope: String,\n  itemtype: String,\n  lang: String,\n  nonce: String,\n  part: String,\n  slot: String,\n  spellcheck: {\n    type: Boolean,\n    default: void 0\n  },\n  style: { type: [String, Object, Array], default: void 0 },\n  tabindex: String,\n  title: String,\n  translate: String,\n  /**\n   * @deprecated Use tagPriority\n   */\n  renderPriority: [String, Number],\n  /**\n   * Unhead prop to modify the priority of the tag.\n   */\n  tagPriority: { type: [String, Number] }\n};\nexport const NoScript = defineComponent({\n  name: \"NoScript\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    ...TagPositionProps,\n    title: String\n  },\n  setup(props, { slots }) {\n    const { input } = useHeadComponentCtx();\n    input.noscript ||= [];\n    const idx = input.noscript.push({}) - 1;\n    onUnmounted(() => input.noscript[idx] = null);\n    return () => {\n      const noscript = normalizeProps(props);\n      const slotVnodes = slots.default?.();\n      const textContent = slotVnodes ? slotVnodes.filter(({ children }) => children).map(({ children }) => children).join(\"\") : \"\";\n      if (textContent) {\n        noscript.innerHTML = textContent;\n      }\n      input.noscript[idx] = noscript;\n      return null;\n    };\n  }\n});\nexport const Link = defineComponent({\n  name: \"Link\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    ...TagPositionProps,\n    as: String,\n    crossorigin: String,\n    disabled: Boolean,\n    fetchpriority: String,\n    href: String,\n    hreflang: String,\n    imagesizes: String,\n    imagesrcset: String,\n    integrity: String,\n    media: String,\n    prefetch: {\n      type: Boolean,\n      default: void 0\n    },\n    referrerpolicy: String,\n    rel: String,\n    sizes: String,\n    title: String,\n    type: String,\n    /** @deprecated **/\n    methods: String,\n    /** @deprecated **/\n    target: String\n  },\n  setup(props) {\n    const { input } = useHeadComponentCtx();\n    input.link ||= [];\n    const idx = input.link.push({}) - 1;\n    onUnmounted(() => input.link[idx] = null);\n    return () => {\n      input.link[idx] = normalizeProps(props);\n      return null;\n    };\n  }\n});\nexport const Base = defineComponent({\n  name: \"Base\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    href: String,\n    target: String\n  },\n  setup(props) {\n    const { input } = useHeadComponentCtx();\n    onUnmounted(() => input.base = null);\n    return () => {\n      input.base = normalizeProps(props);\n      return null;\n    };\n  }\n});\nexport const Title = defineComponent({\n  name: \"Title\",\n  inheritAttrs: false,\n  setup(_, { slots }) {\n    const { input } = useHeadComponentCtx();\n    onUnmounted(() => input.title = null);\n    return () => {\n      const defaultSlot = slots.default?.();\n      input.title = defaultSlot?.[0]?.children ? String(defaultSlot?.[0]?.children) : void 0;\n      if (import.meta.dev) {\n        if (defaultSlot && (defaultSlot.length > 1 || defaultSlot[0] && typeof defaultSlot[0].children !== \"string\")) {\n          console.error(\"<Title> can take only one string in its default slot.\");\n        }\n      }\n      return null;\n    };\n  }\n});\nexport const Meta = defineComponent({\n  name: \"Meta\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    charset: String,\n    content: String,\n    httpEquiv: String,\n    name: String,\n    property: String\n  },\n  setup(props) {\n    const { input } = useHeadComponentCtx();\n    input.meta ||= [];\n    const idx = input.meta.push({}) - 1;\n    onUnmounted(() => input.meta[idx] = null);\n    return () => {\n      const meta = { \"http-equiv\": props.httpEquiv, ...normalizeProps(props) };\n      if (\"httpEquiv\" in meta) {\n        delete meta.httpEquiv;\n      }\n      input.meta[idx] = meta;\n      return null;\n    };\n  }\n});\nexport const Style = defineComponent({\n  name: \"Style\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    ...TagPositionProps,\n    type: String,\n    media: String,\n    nonce: String,\n    title: String,\n    /** @deprecated **/\n    scoped: {\n      type: Boolean,\n      default: void 0\n    }\n  },\n  setup(props, { slots }) {\n    const { input } = useHeadComponentCtx();\n    input.style ||= [];\n    const idx = input.style.push({}) - 1;\n    onUnmounted(() => input.style[idx] = null);\n    return () => {\n      const style = normalizeProps(props);\n      const textContent = slots.default?.()?.[0]?.children;\n      if (textContent) {\n        if (import.meta.dev && typeof textContent !== \"string\") {\n          console.error(\"<Style> can only take a string in its default slot.\");\n        }\n        input.style[idx] = style;\n        style.textContent = textContent;\n      }\n      return null;\n    };\n  }\n});\nexport const Head = defineComponent({\n  name: \"Head\",\n  inheritAttrs: false,\n  setup: (_props, ctx) => {\n    createHeadComponentCtx();\n    return () => ctx.slots.default?.();\n  }\n});\nexport const Html = defineComponent({\n  name: \"Html\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    manifest: String,\n    version: String,\n    xmlns: String\n  },\n  setup(_props, ctx) {\n    const { input } = useHeadComponentCtx();\n    onUnmounted(() => input.htmlAttrs = null);\n    return () => {\n      input.htmlAttrs = { ..._props, ...ctx.attrs };\n      return ctx.slots.default?.();\n    };\n  }\n});\nexport const Body = defineComponent({\n  name: \"Body\",\n  inheritAttrs: false,\n  props: globalProps,\n  setup(_props, ctx) {\n    const { input } = useHeadComponentCtx();\n    onUnmounted(() => input.bodyAttrs = null);\n    return () => {\n      input.bodyAttrs = { ..._props, ...ctx.attrs };\n      return ctx.slots.default?.();\n    };\n  }\n});\n","import { appendHeader } from \"h3\";\nexport function prerenderStaticImages(src = \"\", srcset = \"\", event) {\n  if (!import.meta.server || !import.meta.prerender || !event) {\n    return;\n  }\n  const paths = [\n    src,\n    ...srcset.split(\", \").map((s) => s.trim().split(\" \")[0].trim())\n  ].filter((s) => s && s.includes(\"/_ipx/\"));\n  if (!paths.length) {\n    return;\n  }\n  appendHeader(event, \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\n}\n","export default function imageFetch(url) {\n  return fetch(cleanDoubleSlashes(url));\n}\nexport function getInt(x) {\n  if (typeof x === \"number\") {\n    return x;\n  }\n  if (typeof x === \"string\") {\n    return Number.parseInt(x, 10);\n  }\n  return void 0;\n}\nexport function getFileExtension(url = \"\") {\n  const extension = url.split(/[?#]/).shift().split(\"/\").pop().split(\".\").pop();\n  return extension;\n}\nexport function cleanDoubleSlashes(path = \"\") {\n  return path.replace(/(https?:\\/\\/)|(\\/)+/g, \"$1$2\");\n}\nexport function createMapper(map) {\n  return (key) => {\n    return key ? map[key] || key : map.missingValue;\n  };\n}\nexport function createOperationsGenerator({ formatter, keyMap, joinWith = \"/\", valueMap } = {}) {\n  if (!formatter) {\n    formatter = (key, value) => `${key}=${value}`;\n  }\n  if (keyMap && typeof keyMap !== \"function\") {\n    keyMap = createMapper(keyMap);\n  }\n  const map = valueMap || {};\n  Object.keys(map).forEach((valueKey) => {\n    if (typeof map[valueKey] !== \"function\") {\n      map[valueKey] = createMapper(map[valueKey]);\n    }\n  });\n  return (modifiers = {}) => {\n    const operations = Object.entries(modifiers).filter(([_, value]) => typeof value !== \"undefined\").map(([key, value]) => {\n      const mapper = map[key];\n      if (typeof mapper === \"function\") {\n        value = mapper(modifiers[key]);\n      }\n      key = typeof keyMap === \"function\" ? keyMap(key) : key;\n      return formatter(key, value);\n    });\n    return operations.join(joinWith);\n  };\n}\nexport function renderAttributesToString(attributes = {}) {\n  return Object.entries(attributes).map(([key, value]) => value ? `${key}=\"${value}\"` : \"\").filter(Boolean).join(\" \");\n}\nexport function renderTag(tag, attrs, contents) {\n  const html = `<${tag} ${renderAttributesToString(attrs)}>`;\n  if (!contents) {\n    return html;\n  }\n  return html + contents + `</${tag}>`;\n}\nexport function generateAlt(src = \"\") {\n  return src.split(/[?#]/).shift().split(\"/\").pop().split(\".\").shift();\n}\nexport function parseSize(input = \"\") {\n  if (typeof input === \"number\") {\n    return input;\n  }\n  if (typeof input === \"string\") {\n    if (input.replace(\"px\", \"\").match(/^\\d+$/g)) {\n      return Number.parseInt(input, 10);\n    }\n  }\n}\nexport function parseDensities(input = \"\") {\n  if (input === void 0 || !input.length) {\n    return [];\n  }\n  const densities = /* @__PURE__ */ new Set();\n  for (const density of input.split(\" \")) {\n    const d = Number.parseInt(density.replace(\"x\", \"\"));\n    if (d) {\n      densities.add(d);\n    }\n  }\n  return Array.from(densities);\n}\nexport function checkDensities(densities) {\n  if (densities.length === 0) {\n    throw new Error(\"`densities` must not be empty, configure to `1` to render regular size only (DPR 1.0)\");\n  }\n  if (import.meta.dev && Array.from(densities).some((d) => d > 2)) {\n    const _densities = densities;\n    if (!_densities._warned) {\n      console.warn(\"[nuxt] [image] Density values above `2` are not recommended. See https://observablehq.com/@eeeps/visual-acuity-and-device-pixel-ratio.\");\n    }\n    _densities._warned = true;\n  }\n}\nexport function parseSizes(input) {\n  const sizes = {};\n  if (typeof input === \"string\") {\n    for (const entry of input.split(/[\\s,]+/).filter((e) => e)) {\n      const s = entry.split(\":\");\n      if (s.length !== 2) {\n        sizes[\"1px\"] = s[0].trim();\n      } else {\n        sizes[s[0].trim()] = s[1].trim();\n      }\n    }\n  } else {\n    Object.assign(sizes, input);\n  }\n  return sizes;\n}\n","export async function imageMeta(_ctx, url) {\n  const meta = await _imageMeta(url).catch((err) => {\n    console.error(\"Failed to get image meta for \" + url, err + \"\");\n    return {\n      width: 0,\n      height: 0,\n      ratio: 0\n    };\n  });\n  return meta;\n}\nasync function _imageMeta(url) {\n  if (import.meta.server) {\n    const imageMeta2 = await import(\"image-meta\").then((r) => r.imageMeta);\n    const data = await fetch(url).then((res) => res.buffer());\n    const metadata = imageMeta2(data);\n    if (!metadata) {\n      throw new Error(`No metadata could be extracted from the image \\`${url}\\`.`);\n    }\n    const { width, height } = metadata;\n    const meta = {\n      width,\n      height,\n      ratio: width && height ? width / height : void 0\n    };\n    return meta;\n  }\n  if (typeof Image === \"undefined\") {\n    throw new TypeError(\"Image not supported\");\n  }\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      const meta = {\n        width: img.width,\n        height: img.height,\n        ratio: img.width / img.height\n      };\n      resolve(meta);\n    };\n    img.onerror = (err) => reject(err);\n    img.src = url;\n  });\n}\n","import { defu } from \"defu\";\nimport { hasProtocol, parseURL, joinURL, withLeadingSlash } from \"ufo\";\nimport { imageMeta } from \"./utils/meta.js\";\nimport { checkDensities, parseDensities, parseSize, parseSizes } from \"./utils/index.js\";\nimport { prerenderStaticImages } from \"./utils/prerender.js\";\nexport function createImage(globalOptions) {\n  const ctx = {\n    options: globalOptions\n  };\n  const getImage = (input, options = {}) => {\n    const image = resolveImage(ctx, input, options);\n    if (import.meta.server && import.meta.prerender && globalOptions.event) {\n      prerenderStaticImages(image.url, void 0, globalOptions.event);\n    }\n    return image;\n  };\n  const $img = (input, modifiers = {}, options = {}) => {\n    return getImage(input, {\n      ...options,\n      modifiers: defu(modifiers, options.modifiers || {})\n    }).url;\n  };\n  for (const presetName in globalOptions.presets) {\n    $img[presetName] = (source, modifiers, options) => $img(source, modifiers, { ...globalOptions.presets[presetName], ...options });\n  }\n  $img.options = globalOptions;\n  $img.getImage = getImage;\n  $img.getMeta = (input, options) => getMeta(ctx, input, options);\n  $img.getSizes = (input, options) => getSizes(ctx, input, options);\n  ctx.$img = $img;\n  return $img;\n}\nasync function getMeta(ctx, input, options) {\n  const image = resolveImage(ctx, input, { ...options });\n  if (typeof image.getMeta === \"function\") {\n    return await image.getMeta();\n  } else {\n    return await imageMeta(ctx, image.url);\n  }\n}\nfunction resolveImage(ctx, input, options) {\n  if (input && typeof input !== \"string\") {\n    throw new TypeError(`input must be a string (received ${typeof input}: ${JSON.stringify(input)})`);\n  }\n  if (!input || input.startsWith(\"data:\")) {\n    return {\n      url: input\n    };\n  }\n  const { provider, defaults } = getProvider(ctx, options.provider || ctx.options.provider);\n  const preset = getPreset(ctx, options.preset);\n  input = hasProtocol(input) ? input : withLeadingSlash(input);\n  if (!provider.supportsAlias) {\n    for (const base in ctx.options.alias) {\n      if (input.startsWith(base)) {\n        const alias = ctx.options.alias[base];\n        if (alias) {\n          input = joinURL(alias, input.slice(base.length));\n        }\n      }\n    }\n  }\n  if (provider.validateDomains && hasProtocol(input)) {\n    const inputHost = parseURL(input).host;\n    if (!ctx.options.domains.find((d) => d === inputHost)) {\n      return {\n        url: input\n      };\n    }\n  }\n  const _options = defu(options, preset, defaults);\n  _options.modifiers = { ..._options.modifiers };\n  const expectedFormat = _options.modifiers.format;\n  if (_options.modifiers?.width) {\n    _options.modifiers.width = parseSize(_options.modifiers.width);\n  }\n  if (_options.modifiers?.height) {\n    _options.modifiers.height = parseSize(_options.modifiers.height);\n  }\n  const image = provider.getImage(input, _options, ctx);\n  image.format = image.format || expectedFormat || \"\";\n  return image;\n}\nfunction getProvider(ctx, name) {\n  const provider = ctx.options.providers[name];\n  if (!provider) {\n    throw new Error(\"Unknown provider: \" + name);\n  }\n  return provider;\n}\nfunction getPreset(ctx, name) {\n  if (!name) {\n    return {};\n  }\n  if (!ctx.options.presets[name]) {\n    throw new Error(\"Unknown preset: \" + name);\n  }\n  return ctx.options.presets[name];\n}\nfunction getSizes(ctx, input, opts) {\n  const width = parseSize(opts.modifiers?.width);\n  const height = parseSize(opts.modifiers?.height);\n  const sizes = parseSizes(opts.sizes);\n  const densities = opts.densities?.trim() ? parseDensities(opts.densities.trim()) : ctx.options.densities;\n  checkDensities(densities);\n  const hwRatio = width && height ? height / width : 0;\n  const sizeVariants = [];\n  const srcsetVariants = [];\n  if (Object.keys(sizes).length >= 1) {\n    for (const key in sizes) {\n      const variant = getSizesVariant(key, String(sizes[key]), height, hwRatio, ctx);\n      if (variant === void 0) {\n        continue;\n      }\n      sizeVariants.push({\n        size: variant.size,\n        screenMaxWidth: variant.screenMaxWidth,\n        media: `(max-width: ${variant.screenMaxWidth}px)`\n      });\n      for (const density of densities) {\n        srcsetVariants.push({\n          width: variant._cWidth * density,\n          src: getVariantSrc(ctx, input, opts, variant, density)\n        });\n      }\n    }\n    finaliseSizeVariants(sizeVariants);\n  } else {\n    for (const density of densities) {\n      const key = Object.keys(sizes)[0];\n      let variant = key ? getSizesVariant(key, String(sizes[key]), height, hwRatio, ctx) : void 0;\n      if (variant === void 0) {\n        variant = {\n          size: \"\",\n          screenMaxWidth: 0,\n          _cWidth: opts.modifiers?.width,\n          _cHeight: opts.modifiers?.height\n        };\n      }\n      srcsetVariants.push({\n        width: density,\n        src: getVariantSrc(ctx, input, opts, variant, density)\n      });\n    }\n  }\n  finaliseSrcsetVariants(srcsetVariants);\n  const defaultVariant = srcsetVariants[srcsetVariants.length - 1];\n  const sizesVal = sizeVariants.length ? sizeVariants.map((v) => `${v.media ? v.media + \" \" : \"\"}${v.size}`).join(\", \") : void 0;\n  const suffix = sizesVal ? \"w\" : \"x\";\n  const srcsetVal = srcsetVariants.map((v) => `${v.src} ${v.width}${suffix}`).join(\", \");\n  return {\n    sizes: sizesVal,\n    srcset: srcsetVal,\n    src: defaultVariant?.src\n  };\n}\nfunction getSizesVariant(key, size, height, hwRatio, ctx) {\n  const screenMaxWidth = ctx.options.screens && ctx.options.screens[key] || Number.parseInt(key);\n  const isFluid = size.endsWith(\"vw\");\n  if (!isFluid && /^\\d+$/.test(size)) {\n    size = size + \"px\";\n  }\n  if (!isFluid && !size.endsWith(\"px\")) {\n    return void 0;\n  }\n  let _cWidth = Number.parseInt(size);\n  if (!screenMaxWidth || !_cWidth) {\n    return void 0;\n  }\n  if (isFluid) {\n    _cWidth = Math.round(_cWidth / 100 * screenMaxWidth);\n  }\n  const _cHeight = hwRatio ? Math.round(_cWidth * hwRatio) : height;\n  return {\n    size,\n    screenMaxWidth,\n    _cWidth,\n    _cHeight\n  };\n}\nfunction getVariantSrc(ctx, input, opts, variant, density) {\n  return ctx.$img(\n    input,\n    {\n      ...opts.modifiers,\n      width: variant._cWidth ? variant._cWidth * density : void 0,\n      height: variant._cHeight ? variant._cHeight * density : void 0\n    },\n    opts\n  );\n}\nfunction finaliseSizeVariants(sizeVariants) {\n  sizeVariants.sort((v1, v2) => v1.screenMaxWidth - v2.screenMaxWidth);\n  let previousMedia = null;\n  for (let i = sizeVariants.length - 1; i >= 0; i--) {\n    const sizeVariant = sizeVariants[i];\n    if (sizeVariant.media === previousMedia) {\n      sizeVariants.splice(i, 1);\n    }\n    previousMedia = sizeVariant.media;\n  }\n  for (let i = 0; i < sizeVariants.length; i++) {\n    sizeVariants[i].media = sizeVariants[i + 1]?.media || \"\";\n  }\n}\nfunction finaliseSrcsetVariants(srcsetVariants) {\n  srcsetVariants.sort((v1, v2) => v1.width - v2.width);\n  let previousWidth = null;\n  for (let i = srcsetVariants.length - 1; i >= 0; i--) {\n    const sizeVariant = srcsetVariants[i];\n    if (sizeVariant.width === previousWidth) {\n      srcsetVariants.splice(i, 1);\n    }\n    previousWidth = sizeVariant.width;\n  }\n}\n","import { joinURL, encodePath, encodeParam } from \"ufo\";\nimport { createOperationsGenerator } from \"#image\";\nexport const operationsGenerator = createOperationsGenerator({\n  keyMap: {\n    format: \"f\",\n    fit: \"fit\",\n    width: \"w\",\n    height: \"h\",\n    resize: \"s\",\n    quality: \"q\",\n    background: \"b\"\n  },\n  joinWith: \"&\",\n  formatter: (key, val) => encodeParam(key) + \"_\" + encodeParam(val)\n});\nexport const getImage = (src, { modifiers = {}, baseURL } = {}, ctx) => {\n  if (modifiers.width && modifiers.height) {\n    modifiers.resize = `${modifiers.width}x${modifiers.height}`;\n    delete modifiers.width;\n    delete modifiers.height;\n  }\n  const params = operationsGenerator(modifiers) || \"_\";\n  if (!baseURL) {\n    baseURL = joinURL(ctx.options.nuxt.baseURL, \"/_ipx\");\n  }\n  return {\n    url: joinURL(baseURL, params, encodePath(src))\n  };\n};\nexport const validateDomains = true;\nexport const supportsAlias = true;\n","\n  import * as ipxRuntime$_kjwQM_45Wi_Q8DVmrBlt0vBdeI7zNjosrsbyz9zik9Hk from '/Users/marina/Trabajos/Pia/solstrategies/repository/node_modules/@nuxt/image/dist/runtime/providers/ipx'\n  \n  export const imageOptions = {\n    ...{\n  \"screens\": {\n    \"xs\": 320,\n    \"sm\": 640,\n    \"md\": 768,\n    \"lg\": 1200,\n    \"xl\": 1400,\n    \"xxl\": 1800,\n    \"2xl\": 2000\n  },\n  \"presets\": {},\n  \"provider\": \"ipx\",\n  \"domains\": [],\n  \"alias\": {},\n  \"densities\": [\n    1,\n    2\n  ],\n  \"format\": [\n    \"webp\",\n    \"webp\"\n  ],\n  \"quality\": 95\n},\n    providers: {\n        ['ipx']: { provider: ipxRuntime$_kjwQM_45Wi_Q8DVmrBlt0vBdeI7zNjosrsbyz9zik9Hk, defaults: {} }\n    }\n  }\n","import { createImage } from \"./image.js\";\nimport { imageOptions } from \"#build/image-options.mjs\";\nimport { useNuxtApp, useRuntimeConfig } from \"#imports\";\nexport const useImage = (event) => {\n  const config = useRuntimeConfig();\n  const nuxtApp = useNuxtApp();\n  return nuxtApp.$img || nuxtApp._img || (nuxtApp._img = createImage({\n    ...imageOptions,\n    event: event || nuxtApp.ssrContext?.event,\n    nuxt: {\n      baseURL: config.app.baseURL\n    },\n    runtimeConfig: config\n  }));\n};\n","import { computed } from \"vue\";\nimport { parseSize } from \"../utils/index.js\";\nimport { useImage } from \"#imports\";\nexport const baseImageProps = {\n  // input source\n  src: { type: String, required: false },\n  // modifiers\n  format: { type: String, required: false },\n  quality: { type: [Number, String], required: false },\n  background: { type: String, required: false },\n  fit: { type: String, required: false },\n  modifiers: { type: Object, required: false },\n  // options\n  preset: { type: String, required: false },\n  provider: { type: String, required: false },\n  sizes: { type: [Object, String], required: false },\n  densities: { type: String, required: false },\n  preload: {\n    type: [Boolean, Object],\n    required: false\n  },\n  // <img> attributes\n  width: { type: [String, Number], required: false },\n  height: { type: [String, Number], required: false },\n  alt: { type: String, required: false },\n  referrerpolicy: { type: String, required: false },\n  usemap: { type: String, required: false },\n  longdesc: { type: String, required: false },\n  ismap: { type: Boolean, required: false },\n  loading: {\n    type: String,\n    required: false,\n    validator: (val) => [\"lazy\", \"eager\"].includes(val)\n  },\n  crossorigin: {\n    type: [Boolean, String],\n    required: false,\n    validator: (val) => [\"anonymous\", \"use-credentials\", \"\", true, false].includes(val)\n  },\n  decoding: {\n    type: String,\n    required: false,\n    validator: (val) => [\"async\", \"auto\", \"sync\"].includes(val)\n  },\n  // csp\n  nonce: { type: [String], required: false }\n};\nexport const useBaseImage = (props) => {\n  const options = computed(() => {\n    return {\n      provider: props.provider,\n      preset: props.preset\n    };\n  });\n  const attrs = computed(() => {\n    return {\n      width: parseSize(props.width),\n      height: parseSize(props.height),\n      alt: props.alt,\n      referrerpolicy: props.referrerpolicy,\n      usemap: props.usemap,\n      longdesc: props.longdesc,\n      ismap: props.ismap,\n      crossorigin: props.crossorigin === true ? \"anonymous\" : props.crossorigin || void 0,\n      loading: props.loading,\n      decoding: props.decoding,\n      nonce: props.nonce\n    };\n  });\n  const $img = useImage();\n  const modifiers = computed(() => {\n    return {\n      ...props.modifiers,\n      width: parseSize(props.width),\n      height: parseSize(props.height),\n      format: props.format,\n      quality: props.quality || $img.options.quality,\n      background: props.background,\n      fit: props.fit\n    };\n  });\n  return {\n    options,\n    attrs,\n    modifiers\n  };\n};\nexport const pictureProps = {\n  ...baseImageProps,\n  legacyFormat: { type: String, default: null },\n  imgAttrs: { type: Object, default: null }\n};\nexport const imgProps = {\n  ...baseImageProps,\n  placeholder: { type: [Boolean, String, Number, Array], required: false },\n  placeholderClass: { type: String, required: false },\n  custom: { type: Boolean, required: false }\n};\n","<template>\n  <picture>\n    <source\n      v-for=\"source in sources.slice(0, -1)\"\n      :key=\"source.src\"\n      :type=\"source.type\"\n      :sizes=\"source.sizes\"\n      :srcset=\"source.srcset\"\n    >\n\n    <img\n      v-if=\"lastSource\"\n      ref=\"imgEl\"\n      v-bind=\"{\n        ...baseAttrs,\n        ...(isServer ? { onerror: 'this.setAttribute(\\'data-error\\', 1)' } : {}),\n        ...imgAttrs,\n      }\"\n      :src=\"lastSource.src\"\n      :sizes=\"lastSource.sizes\"\n      :srcset=\"lastSource.srcset\"\n    >\n  </picture>\n</template>\n\n<script setup lang=\"ts\">\nimport type { Head } from '@unhead/vue'\n\nimport { computed, onMounted, ref, useAttrs } from 'vue'\n\nimport { prerenderStaticImages } from '../utils/prerender'\nimport { markFeatureUsage } from '../utils/performance'\nimport { getFileExtension } from '../utils'\nimport { useImage } from '../composables'\nimport { useBaseImage, pictureProps, baseImageProps } from './_base'\n\nimport { useHead, useRequestEvent } from '#imports'\nimport { useNuxtApp } from '#app/nuxt'\n\nconst props = defineProps(pictureProps)\n\nconst attrs = useAttrs()\n\nconst emit = defineEmits<{\n  (event: 'load', payload: Event): unknown\n  (event: 'error', payload: string | Event): unknown\n}>()\n\nconst isServer = import.meta.server\n\nconst $img = useImage()\n\nconst { attrs: baseAttrs, options: baseOptions, modifiers: baseModifiers } = useBaseImage(props)\n\nconst originalFormat = computed(() => getFileExtension(props.src))\n\nconst isTransparent = computed(() => ['png', 'webp', 'gif', 'svg'].includes(originalFormat.value))\n\nconst legacyFormat = computed(() => {\n  if (props.legacyFormat) {\n    return props.legacyFormat\n  }\n\n  return isTransparent.value ? 'png' : 'jpeg'\n})\n\ntype Source = { src?: string, srcset?: string, type?: string, sizes?: string }\n\nconst sources = computed<Source[]>(() => {\n  const formats = props.format?.split(',') || (originalFormat.value === 'svg' ? ['svg'] : ($img.options.format?.length ? [...$img.options.format] : ['webp']))\n\n  if (formats[0] === 'svg') {\n    return [{ src: props.src! }]\n  }\n\n  if (!formats.includes(legacyFormat.value)) {\n    formats.push(legacyFormat.value)\n  }\n  else {\n    formats.splice(formats.indexOf(legacyFormat.value), 1)\n    formats.push(legacyFormat.value)\n  }\n\n  return formats.map((format) => {\n    const { srcset, sizes, src } = $img.getSizes(props.src!, {\n      ...baseOptions.value,\n      sizes: props.sizes || $img.options.screens,\n      densities: props.densities,\n      modifiers: { ...baseModifiers.value, format },\n    })\n\n    return { src, type: `image/${format}`, sizes, srcset }\n  })\n})\n\nconst lastSource = computed(() => sources.value[sources.value.length - 1])\n\nif (import.meta.server && props.preload) {\n  useHead({ link: () => {\n    const firstSource = sources.value[0]\n    if (!firstSource) {\n      return []\n    }\n\n    const link: NonNullable<Head['link']>[number] = {\n      rel: 'preload',\n      as: 'image',\n      imagesrcset: firstSource.srcset,\n      nonce: props.nonce,\n      ...(typeof props.preload !== 'boolean' && props.preload?.fetchPriority\n        ? { fetchpriority: props.preload.fetchPriority }\n        : {}),\n    }\n\n    if (sources.value?.[0]?.sizes) {\n      link.imagesizes = sources.value[0].sizes\n    }\n    return [link]\n  } })\n}\n\n// Only passdown supported <image> attributes\nconst imgAttrs = computed(() => {\n  const result: Record<string, string | unknown> = { ...props.imgAttrs, 'data-nuxt-pic': '' }\n  for (const key in attrs) {\n    if (key in baseImageProps && !(key in result)) {\n      result[key] = attrs[key]\n    }\n  }\n  return result\n})\n\nconst imgEl = ref<HTMLImageElement>()\n\n// Prerender static images\nif (import.meta.server && import.meta.prerender) {\n  for (const src of sources.value) {\n    prerenderStaticImages(src.src, src.srcset, useRequestEvent())\n  }\n}\n\nconst nuxtApp = useNuxtApp()\nconst initialLoad = nuxtApp.isHydrating\n\nonMounted(() => {\n  if (!imgEl.value) {\n    return\n  }\n\n  if (imgEl.value.complete && initialLoad) {\n    if (imgEl.value.getAttribute('data-error')) {\n      emit('error', new Event('error'))\n    }\n    else {\n      emit('load', new Event('load'))\n    }\n  }\n\n  imgEl.value.onload = (event) => {\n    emit('load', event)\n  }\n\n  imgEl.value.onerror = (event) => {\n    emit('error', event)\n  }\n\n  markFeatureUsage('nuxt-picture')\n})\n</script>\n\n<script lang=\"ts\">\nexport { pictureProps } from './_base'\n</script>\n","<template>\n  <img\n    v-if=\"!custom\"\n    ref=\"imgEl\"\n    :class=\"placeholder && !placeholderLoaded ? placeholderClass : undefined\"\n    v-bind=\"{\n      ...isServer ? { onerror: 'this.setAttribute(\\'data-error\\', 1)' } : {},\n      ...imgAttrs,\n      ...attrs,\n    }\"\n    :src=\"src\"\n  >\n  <slot\n    v-else\n    v-bind=\"{\n      ...isServer ? { onerror: 'this.setAttribute(\\'data-error\\', 1)' } : {},\n      imgAttrs: {\n        ...imgAttrs,\n        ...attrs,\n      },\n      isLoaded: placeholderLoaded,\n      src,\n    }\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted, ref, useAttrs } from 'vue'\n\nimport { useImage } from '../composables'\nimport { parseSize } from '../utils'\nimport { prerenderStaticImages } from '../utils/prerender'\nimport { markFeatureUsage } from '../utils/performance'\nimport { imgProps, useBaseImage } from './_base'\n\nimport { useHead, useRequestEvent } from '#imports'\nimport { useNuxtApp } from '#app/nuxt'\n\nconst props = defineProps(imgProps)\n\nconst attrs = useAttrs()\n\nconst emit = defineEmits<{\n  (event: 'load', payload: Event): unknown\n  (event: 'error', payload: string | Event): unknown\n}>()\n\nconst isServer = import.meta.server\n\nconst $img = useImage()\n\nconst _base = useBaseImage(props)\n\nconst placeholderLoaded = ref(false)\nconst imgEl = ref<HTMLImageElement>()\n\ntype AttrsT = typeof _base.attrs.value & {\n  'sizes'?: string\n  'srcset'?: string\n  'data-nuxt-img'?: string\n}\n\nconst sizes = computed(() => $img.getSizes(props.src!, {\n  ..._base.options.value,\n  sizes: props.sizes,\n  densities: props.densities,\n  modifiers: {\n    ..._base.modifiers.value,\n    width: parseSize(props.width),\n    height: parseSize(props.height),\n  },\n}))\n\nconst imgAttrs = computed(() => {\n  const attrs: AttrsT = { ..._base.attrs.value, 'data-nuxt-img': '' }\n\n  if (!props.placeholder || placeholderLoaded.value) {\n    attrs.sizes = sizes.value.sizes\n    attrs.srcset = sizes.value.srcset\n  }\n\n  return attrs\n})\n\nconst placeholder = computed(() => {\n  let placeholder = props.placeholder\n\n  if (placeholder === '') {\n    placeholder = true\n  }\n\n  if (!placeholder || placeholderLoaded.value) {\n    return false\n  }\n\n  if (typeof placeholder === 'string') {\n    return placeholder\n  }\n\n  const size = (Array.isArray(placeholder)\n    ? placeholder\n    : (typeof placeholder === 'number' ? [placeholder, placeholder] : [10, 10])) as [w: number, h: number, q: number, b: number]\n\n  return $img(props.src!, {\n    ..._base.modifiers.value,\n    width: size[0],\n    height: size[1],\n    quality: size[2] || 50,\n    blur: size[3] || 3,\n  }, _base.options.value)\n})\n\nconst mainSrc = computed(() =>\n  props.sizes\n    ? sizes.value.src\n    : $img(props.src!, _base.modifiers.value, _base.options.value),\n)\n\nconst src = computed(() => placeholder.value ? placeholder.value : mainSrc.value)\n\nif (import.meta.server && props.preload) {\n  const isResponsive = Object.values(sizes.value).every(v => v)\n\n  useHead({\n    link: [{\n      rel: 'preload',\n      as: 'image',\n      nonce: props.nonce,\n      ...(!isResponsive\n        ? { href: src.value }\n        : {\n            href: sizes.value.src,\n            imagesizes: sizes.value.sizes,\n            imagesrcset: sizes.value.srcset,\n          }),\n      ...(typeof props.preload !== 'boolean' && props.preload.fetchPriority\n        ? { fetchpriority: props.preload.fetchPriority }\n        : {}),\n    }],\n  })\n}\n\n// Prerender static images\nif (import.meta.server && import.meta.prerender) {\n  prerenderStaticImages(src.value, sizes.value.srcset, useRequestEvent())\n}\n\nconst nuxtApp = useNuxtApp()\n\nconst initialLoad = nuxtApp.isHydrating\n\nonMounted(() => {\n  if (placeholder.value || props.custom) {\n    const img = new Image()\n\n    if (mainSrc.value) {\n      img.src = mainSrc.value\n    }\n\n    if (props.sizes) {\n      img.sizes = sizes.value.sizes || ''\n      img.srcset = sizes.value.srcset\n    }\n\n    img.onload = (event) => {\n      placeholderLoaded.value = true\n      emit('load', event)\n    }\n\n    img.onerror = (event) => {\n      emit('error', event)\n    }\n\n    markFeatureUsage('nuxt-image')\n\n    return\n  }\n\n  if (!imgEl.value) {\n    return\n  }\n\n  if (imgEl.value.complete && initialLoad) {\n    if (imgEl.value.getAttribute('data-error')) {\n      emit('error', new Event('error'))\n    }\n    else {\n      emit('load', new Event('load'))\n    }\n  }\n\n  imgEl.value.onload = (event) => {\n    emit('load', event)\n  }\n\n  imgEl.value.onerror = (event) => {\n    emit('error', event)\n  }\n})\n</script>\n\n<script lang=\"ts\">\nexport { imgProps } from './_base'\n</script>\n","export const useMediaStore = () => {\n  const images = useState<string[]>('images', () => []);\n\n  const addImage = (image: string) => {\n    images.value.push(image);\n  };\n\n  const clearImages = () => {\n    images.value = [];\n  };\n\n  return {\n    images,\n    addImage,\n    clearImages,\n  };\n};\n","import { useNuxtApp } from \"#imports\";\nexport const useDevice = () => useNuxtApp().$device;\n","<template>\n  <div v-if=\"props.src\" class=\"media-img\" :class=\"{ 'pointer-events': props.pointerEvents, 'n-a': !props.aspect }\">\n    <div v-if=\"props.aspect\" class=\"ar\" />\n    <NuxtPicture\n      v-if=\"props.type === 'picture'\"\n      :provider=\"props.provider ? variables.system.cms : null\"\n      :src=\"props.src\"\n      :alt=\"props.alt\"\n      :loading=\"props.lazy ? 'lazy' : null\"\n      :decoding=\"props.lazy ? null : 'async'\"\n      :img-attrs=\"{ draggable: false }\"\n      :sizes=\"props.sizes\" />\n    <NuxtImg\n      v-if=\"props.type === 'img'\"\n      :provider=\"props.provider ? variables.system.cms : null\"\n      :src=\"props.src\"\n      :alt=\"props.alt\"\n      :loading=\"props.lazy ? 'lazy' : null\"\n      :decoding=\"props.lazy ? null : 'async'\"\n      draggable=\"false\"\n      :sizes=\"props.sizes\" />\n  </div>\n</template>\n\n<script setup>\nimport variables from '~~/config/variables.json';\n\nconst props = defineProps({\n  type: {\n    type: String,\n    default: 'picture',\n    validator: (value) => ['picture', 'img'].includes(value),\n  },\n  provider: {\n    type: Boolean,\n    default: false,\n  },\n  src: {\n    type: String,\n    required: true,\n  },\n  alt: {\n    type: String,\n    required: true,\n  },\n  pointerEvents: {\n    type: Boolean,\n    default: false,\n  },\n  og: {\n    type: Boolean,\n    default: false,\n  },\n  sizes: {\n    type: String,\n  },\n  aspect: {\n    type: String,\n  },\n  aspectM: {\n    type: String,\n  },\n  lazy: {\n    type: Boolean,\n    default: false,\n  },\n});\n\n// Media store\nconst mediaStore = useMediaStore();\nmediaStore.addImage(props.src);\n\n// Aspect calc\nconst aspectCalc = ref();\nlet aspectW;\nlet aspectH;\n\nif (props.aspect) {\n  aspectW = Number(props.aspect.split('/')[0]);\n  aspectH = Number(props.aspect.split('/')[1]);\n}\n\nif (useDevice().isMobile && props.aspectM) {\n  aspectW = Number(props.aspectM.split('/')[0]);\n  aspectH = Number(props.aspectM.split('/')[1]);\n}\n\naspectCalc.value = ((aspectH / aspectW) * 100).toFixed(2);\n\nconst aspectPercent = computed(() => (props.aspect ? `${aspectCalc.value}%` : null));\n\nif (props.og) {\n  useSeoMeta({\n    ogImage: props.src,\n  });\n}\n</script>\n\n<style scoped lang=\"scss\">\n.media-img {\n  position: relative;\n  width: 100%;\n  height: 100%;\n\n  &:not(.pointer-events) {\n    pointer-events: none;\n    user-select: none;\n  }\n\n  &:not(.n-a) {\n    &:deep(img) {\n      position: absolute;\n      inset: 0;\n    }\n  }\n\n  &:deep(img) {\n    width: 100%;\n    height: 100%;\n  }\n\n  .ar {\n    padding-top: v-bind('aspectPercent');\n  }\n}\n</style>\n","<template>\n  <component :is=\"tag\" :class=\"variantClass\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type variables from '~~/config/variables.json';\n\ntype Variant = keyof typeof variables.font;\n\nconst { tag = 'p', variant = 'body1' } = defineProps<{\n  tag?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p' | 'span';\n  variant?: Variant;\n}>();\n\nconst variantClass = computed(() => {\n  return tag === 'p' && variant === 'body1' ? '' : `font-${variant}`;\n});\n</script>\n","<template>\n  \n  <section class=\"contactform\">\n    \n    <div id=\"request\">\n      <div class=\"bgForm\">\n        <MediaImg class=\"bgTop\" src=\"/ctc-bgTop.webp\" alt=\"Contact Background\" />\n        <MediaImg class=\"bgBottom\" src=\"/ctc-bgBot.webp\" alt=\"Contact Background\" />\n      </div>\n      <div class=\"cerrar cerrarmenu\">\n         <MediaImg src=\"/closeContact.svg\" alt=\"Close Form\" />\n      </div>\n      <div class=\"request-in\">\n        <div class=\"request-content\">\n          <Text tag=\"h2\" variant=\"heading2\" data-split data-linereveal><strong>Let's talk!</strong> <br>We're here to help</Text>\n          <Text tag=\"p\" variant=\"text1\" data-split data-linereveal>Drop us a message</Text>\n          <Text tag=\"p\" variant=\"text2\" data-split data-linereveal>Please provide your info and we'll connect with you soon.</Text>\n          <div class=\"form mt-5\">\n            \n            <div class=\"form-group floating-label col-sm-6\">\n              <input type=\"text\" id=\"full_name\" name=\"full_name\" class=\"form-control\" placeholder=\" \" required />\n              <label for=\"full_name\">\n                  <span class=\"label-text\">Full Name</span><span class=\"required\">*</span>\n              </label>\n            </div>\n\n            <div class=\"form-group floating-label col-sm-6\">\n              <input type=\"text\" id=\"company_name\" name=\"company_name\" class=\"form-control\" placeholder=\" \" required />\n              <label for=\"company_name\">\n                  <span class=\"label-text\">Company Name</span><span class=\"required\">*</span>\n              </label>\n            </div>\n\n             <div class=\"form-group floating-label col-sm-6\">\n              <input type=\"text\" id=\"phone\" name=\"phone\" class=\"form-control\" placeholder=\" \" required />\n              <label for=\"phone\">\n                  <span class=\"label-text\">Phone Number</span><span class=\"required\">*</span>\n              </label>\n            </div>\n\n             <div class=\"form-group floating-label col-sm-6\">\n              <input type=\"email\" id=\"your_email\" name=\"your_email\" class=\"form-control\" placeholder=\" \" required />\n              <label for=\"your_email\">\n                  <span class=\"label-text\">E-mail</span><span class=\"required\">*</span>\n              </label>\n            </div>\n\n            <div class=\"form-group floating-label col-sm-12\">\n              <input type=\"text\" id=\"inquiry\" name=\"inquiry\" class=\"form-control\" placeholder=\" \" />\n              <label for=\"inquiry\">\n                  <span class=\"label-text\">Type of Inquiry</span>\n              </label>\n            </div>\n\n             <div class=\"form-group floating-label col-sm-12\">\n              <textarea name=\"your_message\" cols=\"40\" rows=\"7\" class=\"form-control\" placeholder=\"\"></textarea>\n              <label for=\"your_message\">\n                  <span class=\"label-text\">Type your message</span>\n              </label>\n            </div>\n            <div class=\"col-sm-12\">\n              <div class=\"form-group buttons\">\n                <input id=\"enviar\" type=\"submit\" value=\"Submit\" class=\"cta\" />\n                \n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"bodycerrar\"></div>\n  </section>\n\n\n\n\n</template>\n\n\n\n<script setup>\n\nlet ctx;\n\nimport { onMounted } from 'vue';\nimport gsap from 'gsap';\n\nlet active = false;\n\nonMounted(() => {\n  gsap.set(\"#request\", { right: \"-100%\" });\n\n  const tlOpen = gsap.timeline({ paused: true })\n    .to(\"#request\", { right: 0, duration: 0.5, ease: \"power2.out\" }, 0)\n    .call(() => document.body.classList.add(\"formopen\"), null, 0);\n\n  const tlClose = gsap.timeline({ paused: true })\n    .to(\"#request\", { right: \"-100%\", duration: 0.5, ease: \"power2.in\" }, 0)\n    .call(() => document.body.classList.remove(\"formopen\"), null, 0);\n\n  let active = false;\n\n  document.addEventListener(\"click\", (e) => {\n    const target = e.target.closest(\".btn-request, .cerrarmenu, .bodycerrar\");\n    if (!target) return;\n\n    if (active) {\n      active = false;\n      tlClose.restart();\n    } else {\n      active = true;\n      tlOpen.restart();\n    }\n  });\n});\n</script>\n\n\n\n\n\n\n\n<style scoped lang=\"scss\">\n.bgForm {\n    position: absolute;\n    z-index: -1;\n    width: 100%;\n\n    @include mx.mobile {\n      height: 100%;\n      display: flex;\n      flex-direction: column;\n    }\n}\n\n\n\n  #request{\n    padding: 0;\n    position: fixed;\n    width: 740px;\n    height: 100vh;\n    overflow: auto;\n    top: 0;\n    right: 0;\n    background: #fff;\n    border-radius: 30px 0px 0px 30px;\n    right: -100%;\n    transition: all 0.5s;\n    z-index: 99999;\n    box-shadow: 0px 25px 55px 0px rgba(0, 0, 0, 0.05);\n    overflow: auto;\n    -webkit-transition: 0.4s;\n    -moz-transition: 0.4s;\n    -o-transition: 0.4s;\n    transition: 0.4s;\n\n    @include mx.mobile {\n     width: 93%;\n    }\n  }\n\n\n\n\n  #request.show {\n      right: 0;\n      transition: all 0.3s;\n  }\n\n\n  #request .cerrar{\n    position: absolute;\n    top: 66px;\n    right: 40px;\n    z-index: 3;\n    width: 24px;\n    @include mx.mobile {\n      right: 30px;\n      top: 26px;\n    }\n  }\n\n  #request .cerrar:hover{\n    cursor: pointer;\n  }\n\n\n\n  #request .request-in{\n    padding-left: 76px;\n    padding-right: 90px;\n    padding-top: 60px;\n    padding-bottom: 60px;\n    margin-top: 0;\n    display: flex;\n    align-items: center;\n    min-height: 100%;\n    overflow: auto;\n    @include mx.mobile {\n      padding: 60px 30px;\n    }\n  }\n\n  #request .request-content {\n    height: auto;\n  }\n\n\n  #request h2 {\n    margin-bottom: 7px;\n    color: #000;\n    font-size: 60px;\n    font-style: normal;\n    font-weight: 300;\n    line-height: 99%;\n    @include mx.mobile {\n      font-size: 38px;\n    }\n  }\n\n\n  #request h2 strong{\n    font-weight: 500;\n  }\n\n\n\n\n  p.font-text1 {\n    font-size: 22px;\n    font-weight: 500;\n    margin-bottom: 6px;\n    @include mx.mobile {\n      font-size: 18px;\n    }\n  }\n\n  p.font-text2 {\n    font-size: 18px;\n    color: #686868;\n    @include mx.mobile {\n      font-size: 16px;\n    }\n  }\n\n\n\n\n  body.formopen {\n    overflow: hidden;\n    position: relative;\n  }\n  header.menuopen {\n  /*    transform: translateX(-20%);*/\n  }\n\n  #smooth-wrapper.menuopen {\n  /*    transform: translateX(-20%);*/\n  }\n\n\n  body .bodycerrar{\n    background-color: #696969;\n    mix-blend-mode: multiply;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    opacity: 0;\n    z-index: -1;\n    transition: all 0.3s ease-out;\n  }\n\n\n  body.formopen .bodycerrar{\n    opacity: 0.9;\n    z-index: 9;\n    transition: all 0.3s ease-out;\n  }\n\n\n\n.form {\n    display: flex;\n    justify-content: space-between;\n    flex-wrap: wrap;\n    margin: 30px -10px 0;\n}\n\n  .form-group {\n    margin-bottom: 22px;\n    @include mx.mobile {\n     margin-bottom: 10px;\n    }\n  }\n\n\n  .col-sm-6.floating-label {\n    flex-basis: 1;\n    -ms-flex-preferred-size: 0;\n    flex-basis: 50%;\n    -ms-flex-positive: 1;\n    flex-grow: 0;\n    padding: 0 5px;\n    @include mx.mobile {\n     flex-basis: 100%;\n    }\n  }\n\n  .col-sm-12.floating-label {\n    flex-basis: 1;\n    -ms-flex-preferred-size: 0;\n    flex-basis: 100%;\n    -ms-flex-positive: 1;\n    flex-grow: 0;\n    padding: 0 5px;\n  }\n\n  .form-group.boton {\n    margin-bottom: 0px;\n  }\n\n  .form-control {\n    height: 41px;\n    line-height: 160.5%;\n    padding: 0 21px;\n    border-radius: 10px;\n    border: 1px solid #DFDFDF;\n    background: #FFF;\n    width: 100%;\n  }\n\n  input#enviar {\n    background: #000;\n    background-position: 49px 18px;\n    background-repeat: no-repeat;\n    background-size: auto;\n    border: none;\n    border-radius: 10px;\n    color: #fff;\n    font-size: 16px;\n    height: 41px;\n    padding: 0 50px;\n    transition: .4s;\n  }\n\n\n  input#enviar:hover {\n    background-color: #111;\n\n  }\n\n  .form-control::-webkit-input-placeholder{\n    color:#7E7E7E;\n    }\n\n  .form-control:-moz-placeholder{ /* Firefox 18- */\n    color:#7E7E7E; \n    }\n\n  .form-control::-moz-placeholder{  /* Firefox 19+ */\n    color:#7E7E7E; \n    }\n\n  .form-control:-ms-input-placeholder{  \n    color:#7E7E7E;\n    }\n\n\n\n\n\n\n\n  .form-control:focus::-webkit-input-placeholder{\n      color:transparent;\n    }\n\n  .form-control:focus:-moz-placeholder{ /* Firefox 18- */\n      color:transparent; \n    }\n\n  .form-control:focus::-moz-placeholder{  /* Firefox 19+ */\n      color:transparent; \n    }\n\n  .form-control:focus:-ms-input-placeholder{  \n      color:transparent;\n    }\n\n\n\n\n  .floating-label {\n    position: relative;\n    flex-basis: 1;\n    -ms-flex-preferred-size: 0;\n    flex-basis: 0;\n    -ms-flex-positive: 1;\n    flex-grow: 1;\n  }\n\n  .floating-label label {\n    color: #9F9F9F;\n    font-size: 16px;\n    padding: 0 17px;\n    position: absolute;\n    top: 10px;\n    left: 0;\n  }\n\n  .floating-label label span.required {\n    color: #F00;\n  }\n\n\n  .floating-label input:focus + label,\n  .floating-label input:not(:placeholder-shown) + label {\n    display: none;\n  }\n\n\n  textarea.form-control {\n    resize: none;\n    height: 140px;\n    @include mx.mobile {\n      height: 120px;\n    }\n  }\n\n\n\n</style>","import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  fill: \"none\",\n  viewBox: \"0 0 224 32\"\n}\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(\"svg\", _hoisted_1, [...(_cache[0] || (_cache[0] = [\n    _createElementVNode(\"path\", {\n      fill: \"#000\",\n      d: \"M145.706 6.516s-3.766-.028-5.884-.028c2.12 0 .25-.021-1.734-.021l.028-.054c.244-.12 2.331-1.264 2.169-5.401-.008-.198-.049-.229-.216-.229h-.021c-.976.008-1.791.013-2.826 0h-.013c-.108 0-.164.013-.198.046-.033.034-.049.1-.049.209.008 1.264.008 5.383.008 5.426l-.008.05h-3.456v2.25h3.456s0 7.31.006 9.48v.048h-.008v1.955c0 1.398.162 2.372.501 2.976.318.67.856 1.14 1.593 1.387.671.27 1.683.394 3.199.394.612 0 2.621-.08 2.621-.08l-.049-2.449c-.691.046-1.783.067-2.279.067-1.059 0-1.768-.157-2.161-.48-.432-.29-.632-.925-.632-1.995V18.29h-.021v-.048c0-3.192.008-8.169.013-9.202 0-.154.129-.277.283-.277h1.267c1.377 0 4.424.005 4.424.005V6.51l-.005.005h-.008ZM4.923 24.562c-1.583-.689-2.788-1.652-3.649-2.893C.414 20.43 0 19.017 0 17.365l2.996.033c0 1.688.655 3.03 2.033 3.993 1.343 1 3.132 1.48 5.406 1.48 2.066 0 3.754-.377 4.992-1.171 1.239-.792 1.86-1.86 1.86-3.202 0-.827-.31-1.55-.86-2.135-.586-.586-1.41-1-2.48-1.275l-6.68-1.55c-2.17-.482-3.788-1.307-4.854-2.443C1.31 9.993.794 8.582.794 6.861c0-1.308.378-2.444 1.172-3.41.758-.964 1.86-1.722 3.304-2.272C6.717.663 8.402.388 10.332.388c1.93 0 3.685.344 5.131 1.033 1.447.688 2.583 1.619 3.374 2.857.792 1.239 1.205 2.721 1.205 4.374h-2.996c0-1.722-.619-3.066-1.824-4.063-1.239-1-2.893-1.516-4.993-1.516-2.099 0-3.546.378-4.717 1.066C4.34 4.828 3.79 5.792 3.79 6.963c0 .895.344 1.653 1.066 2.272.689.62 1.755 1.102 3.202 1.446l6.3 1.517c1.791.447 3.238 1.135 4.305 2.065 1.066.93 1.618 2.341 1.618 4.235 0 1.41-.413 2.652-1.205 3.718-.827 1.066-1.963 1.894-3.443 2.48-1.516.585-3.238.86-5.198.86-2.1 0-3.926-.31-5.51-1l-.002.006Zm22.571-.552c-1.791-1.033-3.168-2.513-4.165-4.443-1.033-1.927-1.516-4.165-1.516-6.714 0-2.55.483-4.682 1.516-6.576 1-1.893 2.377-3.34 4.165-4.373C29.282.87 31.314.354 33.589.354c2.274 0 4.27.517 6.059 1.55 1.79 1.033 3.168 2.48 4.201 4.373 1 1.894 1.516 4.099 1.516 6.576 0 2.477-.516 4.787-1.516 6.714-1.033 1.927-2.41 3.41-4.201 4.443-1.791 1.033-3.788 1.549-6.06 1.549-2.27 0-4.303-.516-6.094-1.55Zm10.605-2.375c1.343-.827 2.41-1.996 3.168-3.512s1.135-3.271 1.135-5.268c0-1.996-.377-3.684-1.135-5.164a8.522 8.522 0 0 0-3.169-3.444c-1.343-.791-2.857-1.205-4.51-1.205-1.651 0-3.2.414-4.545 1.205-1.343.828-2.376 1.963-3.132 3.444-.758 1.48-1.136 3.201-1.136 5.164 0 1.963.378 3.754 1.136 5.268.758 1.516 1.791 2.685 3.132 3.512 1.344.828 2.858 1.239 4.546 1.239 1.688 0 3.168-.414 4.51-1.239ZM51.175.907V22.39h12.637v2.616H48.284V.907h2.893-.002ZM69.665 17.338l3.045.034c0 3.402 2.976 5.578 7.565 5.578 4.59 0 6.969-1.58 6.969-4.455 0-2.596-2.521-3.544-5.674-4.173l-2.731-.56c-4.168-.843-8.372-2.105-8.372-7.12 0-4.035 3.713-6.558 9.597-6.594 5.777-.033 9.631 3.487 9.631 8.675H86.65c0-3.508-2.662-5.94-6.583-5.94-3.921 0-6.55 1.54-6.55 3.961 0 2.631 2.662 3.544 5.849 4.212l2.662.56c4.134.879 8.263 2.104 8.263 6.84 0 4.489-3.923 7.333-10.016 7.333-6.444 0-10.61-3.294-10.61-8.348h.006l-.006-.003ZM105.752 6.51h2.698l.103 5.836h.141c.807-3.86 3.045-5.856 7.529-5.856v2.524c-2.521.102-4.309.737-5.532 1.965-1.54 1.542-2.136 4.034-2.136 7.436v6.455h-2.8V6.51h-.003ZM116.301 20.413c0-3.366 2.346-5.227 6.549-5.227h2.136c3.258 0 5.116-.352 5.116-2.806 0-1.58-1.226-3.718-5.253-3.718-3.011 0-5.18 1.58-5.604 4.348h-2.873c.386-4.173 3.68-6.807 8.508-6.807 4.828 0 8.02 2.313 8.02 6.241v12.42h-2.662l-.142-4.983h-.141c-.699 3.402-3.572 5.542-7.423 5.542-3.852 0-6.231-1.927-6.231-5.015l-.006.005h.006Zm6.865 2.633c4.271 0 6.936-3.299 6.936-6.208v-2.035h-.142c-.244 1.58-1.75 2.28-4.974 2.28h-2.205c-2.243 0-3.5 1.053-3.5 2.947 0 1.893 1.154 3.016 3.885 3.016Z\"\n    }, null, -1),\n    _createElementVNode(\"path\", {\n      fill: \"#000\",\n      d: \"M145.426 15.75c0-6.069 3.641-9.54 8.899-9.54 4.905 0 8.546 3.649 8.546 8.77 0 .424-.034.84-.07 1.297h-14.566c.069 4.387 2.659 6.7 6.162 6.7 3.011 0 4.936-1.966 5.462-4.456h2.873c-.527 4.14-3.852 6.91-8.335 6.91-5.219 0-8.963-3.159-8.963-9.683l-.005.005-.003-.002Zm14.567-1.438c-.211-3.402-2.31-5.646-5.776-5.646-3.256 0-5.743 1.928-5.987 5.646h11.766-.003ZM168.54 17.503c-1.015.494-1.506 1.367-1.506 2.177 0 1.053.876 2.068 2.556 2.068h6.304c3.255 0 5.18 1.65 5.18 4.348 0 3.543-3.117 5.47-9.104 5.47-5.987 0-8.336-1.613-8.336-4.21 0-1.753 1.47-2.84 3.153-3.403v-.141c-1.539-.56-2.346-1.65-2.346-3.089 0-1.58 1.154-2.84 3.186-3.543v-.175c-1.647-1.087-2.556-2.806-2.556-4.874 0-3.158 2.032-5.299 5.884-5.928l8.844-2.205v2.387l-4.607.028-.033.175c2.59.81 4.203 2.84 4.203 5.543 0 3.543-2.659 6.069-7.143 6.069-1.403 0-2.629-.244-3.679-.702l-.006.005h.006Zm3.71 11.61c3.852 0 5.987-1.087 5.987-2.84 0-1.297-1.084-2.068-2.906-2.068h-5.918c-.455 0-.876-.034-1.261-.07-1.193.494-1.858 1.406-1.858 2.28 0 1.824 1.611 2.703 5.953 2.703v-.005h.003Zm-.033-13.362c2.698 0 4.339-1.405 4.339-3.649 0-2.243-1.647-3.615-4.339-3.615-2.693 0-4.34 1.406-4.34 3.615 0 2.21 1.647 3.65 4.34 3.65ZM183.913 0c1.051 0 1.891.84 1.891 1.894 0 1.053-.84 1.893-1.891 1.893a1.884 1.884 0 0 1-1.892-1.893c0-1.054.841-1.894 1.892-1.894Zm1.397 6.768v18.1h-2.8v-18.1h2.8ZM188.697 15.75c0-6.069 3.641-9.54 8.899-9.54 4.902 0 8.546 3.649 8.546 8.77 0 .424-.034.84-.07 1.297h-14.566c.069 4.387 2.662 6.7 6.162 6.7 3.011 0 4.936-1.966 5.462-4.456h2.873c-.524 4.14-3.852 6.91-8.335 6.91-5.219 0-8.963-3.159-8.963-9.683l-.005.005-.003-.002Zm10.736-1.438h3.831c-.211-3.402-2.31-5.646-5.776-5.646-3.256 0-5.743 1.928-5.987 5.646h7.934M207.714 19.117h2.873c.244 2.49 2.174 3.86 5.463 3.86 2.839 0 4.622-1.124 4.622-2.948 0-1.825-1.75-2.49-3.957-2.875l-2.205-.386c-3.152-.56-6.339-1.472-6.339-5.157 0-3.333 2.66-5.401 7.213-5.401s7.634 2.42 7.634 6.313h-2.873c0-2.384-1.891-3.86-4.764-3.86-2.872 0-4.411 1.088-4.411 2.84 0 1.753 1.857 2.351 4.167 2.773l2.033.385c3.186.596 6.372 1.542 6.372 5.26 0 3.366-2.906 5.51-7.495 5.51-5.077 0-8.091-2.319-8.336-6.314h.003ZM103.489 6.516s-3.767-.028-5.884-.028c2.12 0 .25-.021-1.734-.021l.028-.054c.244-.12 2.33-1.264 2.168-5.401-.007-.198-.048-.229-.215-.229h-.02c-.977.008-1.792.013-2.827 0h-.013c-.108 0-.165.013-.198.046-.034.034-.049.1-.049.209.008 1.264.008 5.383.008 5.426l-.008.05H91.29v2.25h3.456s0 7.31.005 9.48v.048h-.007v1.955c0 1.398.161 2.372.5 2.976.32.67.856 1.14 1.594 1.387.67.27 1.683.394 3.199.394.611 0 2.621-.08 2.621-.08l-.049-2.449c-.691.046-1.783.067-2.279.067-1.059 0-1.768-.157-2.161-.48-.432-.29-.632-.925-.632-1.995V18.29h-.021v-.048c0-3.192.008-8.169.013-9.202a.28.28 0 0 1 .282-.277h1.267c1.378 0 4.425.005 4.425.005V6.51l-.005.005h-.008Z\"\n    }, null, -1)\n  ]))]))\n}\nexport default { render: render }","<template>\n  <div class=\"text-logo\" :class=\"{ 'is--footer': props.isFooter }\">\n    <MediaImg class=\"image\" src=\"/logoonly.png\" alt=\"Logo\" />\n    <IconLogotext />\n  </div>\n</template>\n\n<script setup>\nconst props = defineProps({\n  isFooter: {\n    type: Boolean,\n  },\n});\n</script>\n\n<style scoped lang=\"scss\">\n.text-logo {\n  display: flex;\n  gap: fn.toVw(8.9);\n  align-items: center;\n  width: fn.toVw(270);\n\n  @include mx.mobile {\n    width: fn.toVw(208);\n  }\n\n  &.is--footer {\n    width: fn.toVw(376);\n\n    @include mx.mobile {\n      width: fn.toVw(267);\n    }\n\n    .image {\n      position: relative;\n      top: fn.toVw(-3);\n      width: fn.toVw(53);\n    }\n  }\n\n  .image {\n    position: relative;\n    top: fn.toVw(-3);\n    width: fn.toVw(40);\n  }\n}\n</style>\n","import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  fill: \"none\",\n  viewBox: \"0 0 10 7\"\n}\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(\"svg\", _hoisted_1, [...(_cache[0] || (_cache[0] = [\n    _createElementVNode(\"path\", {\n      stroke: \"#FA974C\",\n      \"stroke-linecap\": \"round\",\n      \"stroke-width\": \"1.99\",\n      d: \"m1.063 1.303 3.482 3.482 3.482-3.482\"\n    }, null, -1)\n  ]))]))\n}\nexport default { render: render }","<template>\n  <template v-if=\"props.href\">\n    <NuxtLink class=\"no-underline\" :to=\"props.href\" :class=\"{ 'w-full': widthfull }\">\n      <button\n        class=\"btn\"\n        :type=\"props.type\"\n        :class=\"{\n          [props.size]: props.size,\n          fill: props.fill,\n          [props.variant]: props.variant,\n          'w-full': props.widthfull,\n          'is--disabled': props.disable,\n        }\">\n        <span ref=\"elTextWrapper\" class=\"text-wrapper\">\n          <span ref=\"elText\" class=\"text-inner\">\n            <slot />\n          </span>\n        </span>\n      </button>\n    </NuxtLink>\n  </template>\n  <template v-else>\n    <button\n      class=\"btn\"\n      :type=\"props.type\"\n      :class=\"{\n        [props.size]: props.size,\n        fill: props.fill,\n        [props.variant]: props.variant,\n        'w-full': props.widthfull,\n        'is--disabled': props.disable,\n      }\">\n      <span ref=\"elTextWrapper\" class=\"text-wrapper\">\n        <span ref=\"elText\" class=\"text-inner\">\n          <slot />\n        </span>\n      </span>\n    </button>\n  </template>\n</template>\n\n<script setup>\nconst props = defineProps({\n  href: String,\n  text: String,\n  type: {\n    type: String,\n    default: 'button',\n  },\n  size: {\n    type: String, // small, medium\n  },\n  fill: {\n    type: Boolean,\n    default: true,\n  },\n  widthfull: {\n    type: Boolean,\n    default: false,\n  },\n  variant: {\n    type: String,\n    default: 'white',\n    validator: (value) => ['white', 'black'].includes(value),\n  },\n  disable: {\n    type: Boolean,\n    default: false,\n  },\n});\n\nconst elTextWrapper = useTemplateRef('elTextWrapper');\nconst elText = useTemplateRef('elText');\n\nonMounted(() => {\n  const clonedElement = elText.value.cloneNode(true);\n  clonedElement.classList.add('is--clone');\n  elTextWrapper.value.appendChild(clonedElement);\n});\n</script>\n\n<style scoped lang=\"scss\">\n.btn {\n  cursor: pointer;\n\n  position: relative;\n\n  overflow: hidden;\n  display: flex;\n  gap: fn.toVw(12);\n  align-items: center;\n  justify-content: center;\n\n  padding: fn.toVw(16) fn.toVw(41);\n  border: 1px solid currentcolor;\n  border-radius: fn.toVw(10);\n\n  transition: color 0.3s $transition-ease;\n\n  @include mxt.font-body16;\n\n  @include mx.mobile {\n    padding: fn.toVw(12) fn.toVw(26);\n  }\n\n  &:hover {\n    .text-wrapper {\n      .text-inner {\n        &:not(.is--clone) {\n          transform: translateY(-100%);\n        }\n\n        &.is--clone {\n          transform: translateY(0);\n        }\n      }\n    }\n  }\n\n  :deep(svg) {\n    max-height: calc(fn.toVw(35) - fn.toVw(16));\n  }\n\n  &.fill {\n    border: none;\n    background-color: $color-background;\n  }\n\n  &.black {\n    color: $color-background;\n    background-color: $color-black;\n  }\n\n  &.fill.white {\n    border: 1px solid transparent;\n\n    color: $color-text;\n\n    background:\n      linear-gradient(#ffffff, #ffffff) padding-box,\n      linear-gradient(0deg, #f2f2f2 0%, #818181 80%, #ffffff 100%) border-box;\n    backdrop-filter: blur(3.8px);\n    box-shadow: 0 29.1911px 29.1911px rgb(0 0 0 / 3%);\n  }\n\n  .text-wrapper {\n    position: relative;\n    overflow: hidden;\n\n    .text-inner {\n      display: block;\n      transition: transform $transition-default;\n\n      &.is--clone,\n      &:deep(.is--clone) {\n        position: absolute;\n        inset: 0;\n        transform: translateY(100%);\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <button class=\"menu-toggle\" :class=\"{ active: props.activeClass }\" type=\"button\" aria-label=\"Toggle menu\">\n    <span class=\"menu-toggle__icon\">\n      <svg class=\"hamburger\" width=\"20\" height=\"10\" viewBox=\"0 0 20 10\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <line x1=\"0.406738\" y1=\"0.355115\" x2=\"19.0165\" y2=\"0.355115\" stroke=\"black\" stroke-width=\"0.443089\" />\n        <line x1=\"0.406494\" y1=\"4.78608\" x2=\"19.0163\" y2=\"4.78608\" stroke=\"black\" stroke-width=\"0.443089\" />\n        <line x1=\"0.406494\" y1=\"9.21699\" x2=\"19.0163\" y2=\"9.21699\" stroke=\"black\" stroke-width=\"0.443089\" />\n      </svg>\n\n      <svg class=\"close\" width=\"15\" height=\"15\" viewBox=\"0 0 15 15\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <line x1=\"0.823223\" y1=\"14.0835\" x2=\"13.9823\" y2=\"0.924392\" stroke=\"black\" stroke-width=\"0.5\" />\n        <line\n          y1=\"-0.25\"\n          x2=\"18.6098\"\n          y2=\"-0.25\"\n          transform=\"matrix(-0.707107 -0.707107 -0.707107 0.707107 14 14.2607)\"\n          stroke=\"black\"\n          stroke-width=\"0.5\" />\n      </svg>\n    </span>\n    <span class=\"menu-toggle__label\">Menu</span>\n  </button>\n</template>\n\n<script setup>\nconst props = defineProps({\n  activeClass: {\n    type: Boolean,\n    default: false,\n  },\n});\n</script>\n\n<style scoped lang=\"scss\">\n.menu-toggle {\n  display: none;\n  align-items: center;\n\n  font-size: fn.toVw(14);\n  line-height: 1;\n  color: inherit;\n\n  @include mx.mobile {\n    display: inline-flex;\n  }\n\n  &:deep(svg) {\n    width: fn.toVw(19);\n    max-height: fn.toVw(13);\n    transition: opacity 0.3s ease;\n  }\n\n  &.active {\n    .menu-toggle__icon {\n      background-color: #f1f1f1;\n\n      .hamburger {\n        line {\n          stroke-dashoffset: 60;\n          transition-delay: 0s;\n\n          &:nth-of-type(2) {\n            transition-delay: 0.1s;\n          }\n\n          &:nth-of-type(3) {\n            transition-delay: 0.2s;\n          }\n        }\n      }\n\n      .close {\n        line {\n          stroke-dashoffset: 0;\n          transition-delay: 0.5s;\n\n          &:nth-of-type(2) {\n            transition-delay: 0.6s;\n          }\n        }\n      }\n    }\n\n    .menu-toggle__label {\n      background-color: $color-neutral;\n    }\n  }\n\n  .menu-toggle__icon {\n    position: relative;\n    z-index: 1;\n\n    overflow: hidden;\n\n    width: 100%;\n    max-width: none;\n    margin-right: fn.toVw(-27);\n    padding: fn.toVw(13) fn.toVw(15);\n    padding-right: calc(fn.toVw(27) + fn.toVw(9));\n    border-radius: fn.toVw(10);\n\n    background: #edf1f9;\n\n    transition: background-color 0.3s ease;\n\n    .hamburger {\n      line {\n        stroke-dasharray: 20;\n        stroke-dashoffset: 0;\n        transition: stroke-dashoffset $transition-default;\n        transition-delay: 0.4s;\n\n        &:nth-of-type(2) {\n          transition-delay: 0.5s;\n        }\n\n        &:nth-of-type(3) {\n          transition-delay: 0.6s;\n        }\n      }\n    }\n\n    .close {\n      position: absolute;\n      z-index: 2;\n      top: 50%;\n      left: 50%;\n      transform: translate(-100%, -50%);\n\n      line {\n        stroke-dasharray: 20;\n        stroke-dashoffset: 20;\n        transition: stroke-dashoffset $transition-default;\n        transition-delay: 0s;\n\n        &:nth-of-type(2) {\n          transition-delay: 0.075s;\n        }\n      }\n    }\n  }\n\n  .menu-toggle__label {\n    position: relative;\n    z-index: 2;\n\n    padding: fn.toVw(13) fn.toVw(15);\n    border-radius: fn.toVw(10);\n\n    font-size: fn.toVw(13);\n    font-weight: 300;\n    text-transform: uppercase;\n\n    background: $color-background;\n\n    transition: background-color 0.3s ease;\n  }\n}\n</style>\n","export const useHeaderHidden = () => useState<boolean>('stateheaderHidden', () => false);\nexport const usePreloaderItems = () => useState<any[]>('statePreloaderItems', () => []);\nexport const useTransitionComplete = () => useState<boolean>('stateTransitionComplete', () => false);\nexport const useFontDone = () => useState<boolean>('stateFontDone', () => false);\nexport const useSplitTextDone = () => useState<boolean>('stateSplitTextDone', () => false);\nexport const usePreloadDone = () => useState<boolean>('statePreloadDone', () => false);\nexport const usePreloadProgress = () => useState<number>('statePreloadProgress', () => 0);\nexport const useCursor = () =>\n  useState('stateCursor', () => ({\n    show: false,\n    clicked: false,\n  }));\n","import { shallowRef, watchEffect, readonly, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, hasInjectionContext, inject, provide, ref, isRef, unref, toValue as toValue$1, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, shallowReadonly, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn, options = {}) {\n  let v = void 0;\n  let track;\n  let trigger;\n  let dirty = true;\n  const update = () => {\n    dirty = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\", ...options });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty) {\n          v = get(v);\n          dirty = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const clear = () => {\n    fns.clear();\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger,\n    clear\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst injectLocal = /* @__NO_SIDE_EFFECTS__ */ (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null && !hasInjectionContext())\n    throw new Error(\"injectLocal must be called in setup\");\n  if (instance && localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nfunction provideLocal(key, value) {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  return provide(key, value);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? void 0 : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createRef(value, deep) {\n  if (deep === true) {\n    return ref(value);\n  } else {\n    return shallowRef(value);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!scope) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue$1;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue$1(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue$1(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue$1(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue$1(defaultValue);\n      trigger();\n    }, toValue$1(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  let lastInvoker;\n  const filter = (invoke) => {\n    const duration = toValue$1(ms);\n    const maxDuration = toValue$1(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = void 0;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      lastInvoker = invoke;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = void 0;\n          resolve(lastInvoker());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = void 0;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue$1(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter, options = {}) {\n  const {\n    initialState = \"active\"\n  } = options;\n  const isActive = toRef(initialState === \"active\");\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction pxValue(px) {\n  return px.endsWith(\"rem\") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(toValue$1(value));\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return shallowReadonly(debounced);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(toValue$1(value));\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    const [target, key, value] = args;\n    target[key] = value;\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    initialState = \"active\",\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  const targetsArray = toArray(targets);\n  return watch(\n    source,\n    (newValue) => targetsArray.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue$1(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nconst toValue = toValue$1;\nconst resolveUnref = toValue$1;\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue$1(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue$1(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue$1(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayDifference(...args) {\n  var _a, _b;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  const {\n    symmetric = false\n  } = (_b = args[3]) != null ? _b : {};\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  const diff1 = computed(() => toValue$1(list).filter((x) => toValue$1(values).findIndex((y) => compareFn(x, y)) === -1));\n  if (symmetric) {\n    const diff2 = computed(() => toValue$1(values).filter((x) => toValue$1(list).findIndex((y) => compareFn(x, y)) === -1));\n    return computed(() => symmetric ? [...toValue$1(diff1), ...toValue$1(diff2)] : toValue$1(diff1));\n  } else {\n    return diff1;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue$1(list).every((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).filter(fn));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue$1(\n    toValue$1(list).find((element, index, array) => fn(toValue$1(element), index, array))\n  ));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue$1(list).findIndex((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue$1(\n    !Array.prototype.findLast ? findLast(toValue$1(list), (element, index, array) => fn(toValue$1(element), index, array)) : toValue$1(list).findLast((element, index, array) => fn(toValue$1(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue$1(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue$1(value2);\n  return computed(() => toValue$1(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue$1(element),\n    toValue$1(value),\n    index,\n    toValue$1(array)\n  )));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).join(toValue$1(separator)));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).map(fn));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue$1(sum), toValue$1(value), index);\n  return computed(() => {\n    const resolved = toValue$1(list);\n    return args.length ? resolved.reduce(reduceCallback, typeof args[0] === \"function\" ? toValue$1(args[0]()) : toValue$1(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArraySome(list, fn) {\n  return computed(() => toValue$1(list).some((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue$1(list).map((element) => toValue$1(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = shallowRef(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count: shallowReadonly(count), inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|z{1,4}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const stripTimeZone = (dateString) => {\n    var _a2;\n    return (_a2 = dateString.split(\" \")[1]) != null ? _a2 : \"\";\n  };\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true),\n    z: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zzz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zzzz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"longOffset\" }))\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\n// @__NO_SIDE_EFFECTS__\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue$1(date)), toValue$1(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = shallowRef(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue$1(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    if (isActive.value)\n      timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive: shallowReadonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = shallowRef(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter: shallowReadonly(counter),\n      reset,\n      ...controls\n    };\n  } else {\n    return shallowReadonly(counter);\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = shallowRef((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return shallowReadonly(ms);\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  const isPending = shallowRef(false);\n  let timer;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    if (immediateCallback)\n      cb();\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = void 0;\n      cb(...args);\n    }, toValue$1(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: shallowReadonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue$1(value);\n    if (typeof method === \"function\")\n      resolved = method(resolved);\n    else if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToString(value) {\n  return computed(() => `${toValue$1(value)}`);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = shallowRef(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue$1(truthyValue);\n      _value.value = _value.value === truthy ? toValue$1(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...typeof source === \"function\" ? source() : Array.isArray(source) ? source : toValue$1(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = shallowRef(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue$1(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    let ignore = false;\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore = true;\n      updater();\n      ignore = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    let ignoreCounter = 0;\n    let syncCounter = 0;\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter = syncCounter;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter;\n      updater();\n      ignoreCounter += syncCounter - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter > 0 && ignoreCounter === syncCounter;\n          ignoreCounter = 0;\n          syncCounter = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      once: true\n    }\n  );\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue$1(item));\n  return toValue$1(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createRef, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, pxValue, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toArray, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, makeDestructurable, camelize, isClient, toArray, watchImmediate, isObject, tryOnScopeDispose, isIOS, notNullish, tryOnMounted, objectOmit, promiseTimeout, until, injectLocal, provideLocal, pxValue, increaseWithUnit, objectEntries, createRef, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, useIntervalFn, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, bypassFilter, createFilterWrapper, toRefs, watchOnce, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, tryOnUnmounted, clamp, syncRef, objectPick, watchWithFilter, identity, isDef, whenever, isWorker } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, shallowRef, ref, watchEffect, computed, inject, defineComponent, h, TransitionGroup, Fragment, shallowReactive, toValue, unref, getCurrentInstance, onMounted, watch, customRef, onUpdated, readonly, reactive, hasInjectionContext, toRaw, shallowReadonly, nextTick, markRaw, getCurrentScope, isReadonly, onBeforeUpdate } from 'vue';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  var _a;\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    flush = \"pre\",\n    evaluating = void 0,\n    shallow = true,\n    onError = (_a = globalThis.reportError) != null ? _a : noop\n  } = options;\n  const started = shallowRef(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  }, { flush });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((oldValue) => options(source, oldValue));\n  } else {\n    return computed({\n      get: (oldValue) => options.get(source, oldValue),\n      set: options.set\n    });\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createReusableTemplate(options = {}) {\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = shallowRef();\n  const define = /*@__PURE__*/ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /*@__PURE__*/ defineComponent({\n    inheritAttrs,\n    props: options.props,\n    setup(props, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, {\n          ...options.props == null ? keysToCamelKebabCase(attrs) : props,\n          $slots: slots\n        });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[camelize(key)] = obj[key];\n  return newObj;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createTemplatePromise(options = {}) {\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /*@__PURE__*/ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nfunction useEventListener(...args) {\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options) => {\n    el.addEventListener(event, listener, options);\n    return () => el.removeEventListener(event, listener, options);\n  };\n  const firstParamTargets = computed(() => {\n    const test = toArray(toValue(args[0])).filter((e) => e != null);\n    return test.every((e) => typeof e !== \"string\") ? test : void 0;\n  });\n  const stopWatch = watchImmediate(\n    () => {\n      var _a, _b;\n      return [\n        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),\n        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),\n        toArray(unref(firstParamTargets.value ? args[2] : args[1])),\n        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains\n        toValue(firstParamTargets.value ? args[3] : args[2])\n      ];\n    },\n    ([raw_targets, raw_events, raw_listeners, raw_options]) => {\n      cleanup();\n      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))\n        return;\n      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;\n      cleanups.push(\n        ...raw_targets.flatMap(\n          (el) => raw_events.flatMap(\n            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))\n          )\n        )\n      );\n    },\n    { flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(cleanup);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;\n  if (!window) {\n    return controls ? { stop: noop, cancel: noop, trigger: noop } : noop;\n  }\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    const listenerOptions = { passive: true };\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop, listenerOptions));\n    window.document.documentElement.addEventListener(\"click\", noop, listenerOptions);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return toValue(ignore).some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  function hasMultipleRoots(target2) {\n    const vm = toValue(target2);\n    return vm && vm.$.subTree.shapeFlag === 16;\n  }\n  function checkMultipleRoots(target2, event) {\n    const vm = toValue(target2);\n    const children = vm.$.subTree && vm.$.subTree.children;\n    if (children == null || !Array.isArray(children))\n      return false;\n    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));\n  }\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (event.target == null)\n      return;\n    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))\n      return;\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (\"detail\" in event && event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  let isProcessingClick = false;\n  const cleanup = [\n    useEventListener(window, \"click\", (event) => {\n      if (!isProcessingClick) {\n        isProcessingClick = true;\n        setTimeout(() => {\n          isProcessingClick = false;\n        }, 0);\n        listener(event);\n      }\n    }, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement))) {\n          handler(event);\n        }\n      }, 0);\n    }, { passive: true })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  if (controls) {\n    return {\n      stop,\n      cancel: () => {\n        shouldListen = false;\n      },\n      trigger: (event) => {\n        shouldListen = true;\n        listener(event);\n        shouldListen = false;\n      }\n    };\n  }\n  return stop;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useMounted() {\n  const isMounted = shallowRef(false);\n  const instance = getCurrentInstance();\n  if (instance) {\n    onMounted(() => {\n      isMounted.value = true;\n    }, instance);\n  }\n  return isMounted;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const value = toValue(target);\n    const items = toArray(value).map(unrefElement).filter(notNullish);\n    return new Set(items);\n  });\n  const stopWatch = watch(\n    targets,\n    (newTargets) => {\n      cleanup();\n      if (isSupported.value && newTargets.size) {\n        observer = new MutationObserver(callback);\n        newTargets.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction onElementRemoval(target, callback, options = {}) {\n  const {\n    window = defaultWindow,\n    document = window == null ? void 0 : window.document,\n    flush = \"sync\"\n  } = options;\n  if (!window || !document)\n    return noop;\n  let stopFn;\n  const cleanupAndUpdate = (fn) => {\n    stopFn == null ? void 0 : stopFn();\n    stopFn = fn;\n  };\n  const stopWatch = watchEffect(() => {\n    const el = unrefElement(target);\n    if (el) {\n      const { stop } = useMutationObserver(\n        document,\n        (mutationsList) => {\n          const targetRemoved = mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el));\n          if (targetRemoved) {\n            callback(mutationsList);\n          }\n        },\n        {\n          window,\n          childList: true,\n          subtree: true\n        }\n      );\n      cleanupAndUpdate(stop);\n    }\n  }, { flush });\n  const stopHandle = () => {\n    stopWatch();\n    cleanupAndUpdate();\n  };\n  tryOnScopeDispose(stopHandle);\n  return stopHandle;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  let startTimestamp;\n  let hasLongPressed = false;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n    startTimestamp = void 0;\n    hasLongPressed = false;\n  }\n  function getDelay(ev) {\n    const delay = options == null ? void 0 : options.delay;\n    if (typeof delay === \"function\") {\n      return delay(ev);\n    }\n    return delay != null ? delay : DEFAULT_DELAY;\n  }\n  function onRelease(ev) {\n    var _a2, _b2, _c;\n    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];\n    clear();\n    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)\n      return;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - _posStart.x;\n    const dy = ev.y - _posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    startTimestamp = ev.timeStamp;\n    timeout = setTimeout(\n      () => {\n        hasLongPressed = true;\n        handler(ev);\n      },\n      getDelay(ev)\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    if (!isFocusedElementEditable() && isTypedCharValid(event)) {\n      callback(event);\n    }\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true,\n    triggerOnRemoval = false\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = shallowRef();\n  const trigger = () => {\n    activeElement.value = getDeepActiveElement();\n  };\n  if (window) {\n    const listenerOptions = {\n      capture: true,\n      passive: true\n    };\n    useEventListener(\n      window,\n      \"blur\",\n      (event) => {\n        if (event.relatedTarget !== null)\n          return;\n        trigger();\n      },\n      listenerOptions\n    );\n    useEventListener(\n      window,\n      \"focus\",\n      trigger,\n      listenerOptions\n    );\n  }\n  if (triggerOnRemoval) {\n    onElementRemoval(activeElement, trigger, { document });\n  }\n  trigger();\n  return activeElement;\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow,\n    once = false\n  } = options;\n  const isActive = shallowRef(false);\n  const intervalLimit = computed(() => {\n    return fpsLimit ? 1e3 / toValue(fpsLimit) : null;\n  });\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    if (!previousFrameTimestamp)\n      previousFrameTimestamp = timestamp;\n    const delta = timestamp - previousFrameTimestamp;\n    if (intervalLimit.value && delta < intervalLimit.value) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    previousFrameTimestamp = timestamp;\n    fn({ delta, timestamp });\n    if (once) {\n      isActive.value = false;\n      rafId = null;\n      return;\n    }\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      previousFrameTimestamp = 0;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    if (!animate.value)\n      update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    if (el) {\n      update(true);\n    } else {\n      animate.value = void 0;\n    }\n  });\n  watch(() => keyframes, (value) => {\n    if (animate.value) {\n      update();\n      const targetEl = unrefElement(target);\n      if (targetEl) {\n        animate.value.effect = new KeyframeEffect(\n          targetEl,\n          toValue(value),\n          animateOptions\n        );\n      }\n    }\n  }, { deep: true });\n  tryOnMounted(() => update(true), false);\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    if (!animate.value)\n      animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  const listenerOptions = { passive: true };\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause, listenerOptions);\n  useEventListener(animate, \"finish\", () => {\n    var _a;\n    if (commitStyles)\n      (_a = animate.value) == null ? void 0 : _a.commitStyles();\n  }, listenerOptions);\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = shallowRef(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        if (activeIndex.value === tasks.length - 1)\n          onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  var _a;\n  const {\n    immediate = true,\n    delay = 0,\n    onError = (_a = globalThis.reportError) != null ? _a : noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = shallowRef(false);\n  const isLoading = shallowRef(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = toValue(initialState);\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate) {\n    execute(delay);\n  }\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute,\n    executeImmediate: (...args) => execute(0, ...args)\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = shallowRef(\"\");\n  const promise = shallowRef();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => {\n      base64.value = (options == null ? void 0 : options.dataUrl) === false ? res.replace(/^data:.*?;base64,/, \"\") : res;\n    });\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\n  const charging = shallowRef(false);\n  const chargingTime = shallowRef(0);\n  const dischargingTime = shallowRef(0);\n  const level = shallowRef(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef();\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = shallowRef();\n  const isConnected = shallowRef(false);\n  function reset() {\n    isConnected.value = false;\n    device.value = void 0;\n    server.value = void 0;\n  }\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      useEventListener(device, \"gattserverdisconnected\", reset, { passive: true });\n      try {\n        server.value = await device.value.gatt.connect();\n        isConnected.value = server.value.connected;\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected: readonly(isConnected),\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nconst ssrWidthSymbol = Symbol(\"vueuse-ssr-width\");\n// @__NO_SIDE_EFFECTS__\nfunction useSSRWidth() {\n  const ssrWidth = hasInjectionContext() ? injectLocal(ssrWidthSymbol, null) : null;\n  return typeof ssrWidth === \"number\" ? ssrWidth : void 0;\n}\nfunction provideSSRWidth(width, app) {\n  if (app !== void 0) {\n    app.provide(ssrWidthSymbol, width);\n  } else {\n    provideLocal(ssrWidthSymbol, width);\n  }\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow, ssrWidth = useSSRWidth() } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  const ssrSupport = shallowRef(typeof ssrWidth === \"number\");\n  const mediaQuery = shallowRef();\n  const matches = shallowRef(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  watchEffect(() => {\n    if (ssrSupport.value) {\n      ssrSupport.value = !isSupported.value;\n      const queryStrings = toValue(query).split(\",\");\n      matches.value = queryStrings.some((queryString) => {\n        const not = queryString.includes(\"not all\");\n        const minWidth = queryString.match(/\\(\\s*min-width:\\s*(-?\\d+(?:\\.\\d*)?[a-z]+\\s*)\\)/);\n        const maxWidth = queryString.match(/\\(\\s*max-width:\\s*(-?\\d+(?:\\.\\d*)?[a-z]+\\s*)\\)/);\n        let res = Boolean(minWidth || maxWidth);\n        if (minWidth && res) {\n          res = ssrWidth >= pxValue(minWidth[1]);\n        }\n        if (maxWidth && res) {\n          res = ssrWidth <= pxValue(maxWidth[1]);\n        }\n        return not ? !res : res;\n      });\n      return;\n    }\n    if (!isSupported.value)\n      return;\n    mediaQuery.value = window.matchMedia(toValue(query));\n    matches.value = mediaQuery.value.matches;\n  });\n  useEventListener(mediaQuery, \"change\", handler, { passive: true });\n  return computed(() => matches.value);\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetifyV2 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1264,\n  xl: 1904\n};\nconst breakpointsVuetifyV3 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n  xxl: 2560\n};\nconst breakpointsVuetify = breakpointsVuetifyV2;\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\nconst breakpointsElement = {\n  xs: 0,\n  sm: 768,\n  md: 992,\n  lg: 1200,\n  xl: 1920\n};\n\n// @__NO_SIDE_EFFECTS__\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = toValue(breakpoints[toValue(k)]);\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow, strategy = \"min-width\", ssrWidth = useSSRWidth() } = options;\n  const ssrSupport = typeof ssrWidth === \"number\";\n  const mounted = ssrSupport ? shallowRef(false) : { value: true };\n  if (ssrSupport) {\n    tryOnMounted(() => mounted.value = !!window);\n  }\n  function match(query, size) {\n    if (!mounted.value && ssrSupport) {\n      return query === \"min\" ? ssrWidth >= pxValue(size) : ssrWidth <= pxValue(size);\n    }\n    if (!window)\n      return false;\n    return window.matchMedia(`(${query}-width: ${size})`).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\n  };\n  const smallerOrEqual = (k) => {\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  function current() {\n    const points = Object.keys(breakpoints).map((k) => [k, shortcutMethods[k], pxValue(getValue(k))]).sort((a, b) => a[2] - b[2]);\n    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n  }\n  return Object.assign(shortcutMethods, {\n    greaterOrEqual,\n    smallerOrEqual,\n    greater(k) {\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    smaller(k) {\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(\"min\", getValue(k, 0.1));\n    },\n    isGreaterOrEqual(k) {\n      return match(\"min\", getValue(k));\n    },\n    isSmaller(k) {\n      return match(\"max\", getValue(k, -0.1));\n    },\n    isSmallerOrEqual(k) {\n      return match(\"max\", getValue(k));\n    },\n    isInBetween(a, b) {\n      return match(\"min\", getValue(a)) && match(\"max\", getValue(b, -0.1));\n    },\n    current,\n    active() {\n      const bps = current();\n      return computed(() => bps.value.length === 0 ? \"\" : bps.value.at(strategy === \"min-width\" ? -1 : 0));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = shallowRef(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      const listenerOptions = {\n        passive: true\n      };\n      useEventListener(channel, \"message\", (e) => {\n        data.value = e.data;\n      }, listenerOptions);\n      useEventListener(channel, \"messageerror\", (e) => {\n        error.value = e;\n      }, listenerOptions);\n      useEventListener(channel, \"close\", () => {\n        isClosed.value = true;\n      }, listenerOptions);\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\n// @__NO_SIDE_EFFECTS__\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref] of objectEntries(refs)) {\n    watch(ref, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    const listenerOptions = { passive: true };\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), listenerOptions);\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), listenerOptions);\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, options) {\n  const { deepRefs = true, ...watchOptions } = options || {};\n  const cachedValue = createRef(refValue.value, deepRefs);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  const permissionStatus = shallowRef();\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = shallowRef();\n  const update = () => {\n    var _a, _b;\n    state.value = (_b = (_a = permissionStatus.value) == null ? void 0 : _a.state) != null ? _b : \"prompt\";\n  };\n  useEventListener(permissionStatus, \"change\", update, { passive: true });\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus.value) {\n      try {\n        permissionStatus.value = await navigator.permissions.query(desc);\n      } catch (e) {\n        permissionStatus.value = void 0;\n      } finally {\n        update();\n      }\n    }\n    if (controls)\n      return toRaw(permissionStatus.value);\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = shallowRef(\"\");\n  const copied = shallowRef(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });\n  async function updateText() {\n    let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionRead.value));\n    if (!useLegacy) {\n      try {\n        text.value = await navigator.clipboard.readText();\n      } catch (e) {\n        useLegacy = true;\n      }\n    }\n    if (useLegacy) {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText, { passive: true });\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      let useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionWrite.value));\n      if (!useLegacy) {\n        try {\n          await navigator.clipboard.writeText(value);\n        } catch (e) {\n          useLegacy = true;\n        }\n      }\n      if (useLegacy)\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  function isAllowed(status) {\n    return status === \"granted\" || status === \"prompt\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = ref([]);\n  const copied = shallowRef(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read) {\n    useEventListener([\"copy\", \"cut\"], updateContent, { passive: true });\n  }\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content: shallowReadonly(content),\n    copied: readonly(copied),\n    copy,\n    read: updateContent\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const isModified = shallowRef(false);\n  let _lastSync = false;\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  watch(cloned, () => {\n    if (_lastSync) {\n      _lastSync = false;\n      return;\n    }\n    isModified.value = true;\n  }, {\n    deep: true,\n    flush: \"sync\"\n  });\n  function sync() {\n    _lastSync = true;\n    isModified.value = false;\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, isModified, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  const keyComputed = computed(() => toValue(key));\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    (newValue) => write(newValue),\n    { flush, deep, eventFilter }\n  );\n  watch(keyComputed, () => update(), { flush });\n  let firstMounted = false;\n  const onStorageEvent = (ev) => {\n    if (initOnMounted && !firstMounted) {\n      return;\n    }\n    update(ev);\n  };\n  const onStorageCustomEvent = (ev) => {\n    if (initOnMounted && !firstMounted) {\n      return;\n    }\n    updateFromCustomEvent(ev);\n  };\n  if (window && listenToStorageChanges) {\n    if (storage instanceof Storage)\n      useEventListener(window, \"storage\", onStorageEvent, { passive: true });\n    else\n      useEventListener(window, customStorageEventName, onStorageCustomEvent);\n  }\n  if (initOnMounted) {\n    tryOnMounted(() => {\n      firstMounted = true;\n      update();\n    });\n  } else {\n    update();\n  }\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      const payload = {\n        key: keyComputed.value,\n        oldValue,\n        newValue,\n        storageArea: storage\n      };\n      window.dispatchEvent(storage instanceof Storage ? new StorageEvent(\"storage\", payload) : new CustomEvent(customStorageEventName, {\n        detail: payload\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(keyComputed.value);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(keyComputed.value);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(keyComputed.value, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(keyComputed.value);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(keyComputed.value, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== keyComputed.value) {\n      return;\n    }\n    pauseWatch();\n    try {\n      const serializedData = serializer.write(data.value);\n      if (event === void 0 || (event == null ? void 0 : event.newValue) !== serializedData) {\n        data.value = read(event);\n      }\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nconst CSS_DISABLE_TRANS = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      const classesToAdd = /* @__PURE__ */ new Set();\n      const classesToRemove = /* @__PURE__ */ new Set();\n      let attributeToChange = null;\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            classesToAdd.add(v);\n          else\n            classesToRemove.add(v);\n        });\n      } else {\n        attributeToChange = { key: attribute2, value };\n      }\n      if (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        style.appendChild(document.createTextNode(CSS_DISABLE_TRANS));\n        window.document.head.appendChild(style);\n      }\n      for (const c of classesToAdd) {\n        el.classList.add(c);\n      }\n      for (const c of classesToRemove) {\n        el.classList.remove(c);\n      }\n      if (attributeToChange) {\n        el.setAttribute(attributeToChange.key, attributeToChange.value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  return Object.assign(auto, { store, system, state });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useConfirmDialog(revealed = shallowRef(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCountdown(initialCountdown, options) {\n  var _a, _b;\n  const remaining = shallowRef(toValue(initialCountdown));\n  const intervalController = useIntervalFn(() => {\n    var _a2, _b2;\n    const value = remaining.value - 1;\n    remaining.value = value < 0 ? 0 : value;\n    (_a2 = options == null ? void 0 : options.onTick) == null ? void 0 : _a2.call(options);\n    if (remaining.value <= 0) {\n      intervalController.pause();\n      (_b2 = options == null ? void 0 : options.onComplete) == null ? void 0 : _b2.call(options);\n    }\n  }, (_a = options == null ? void 0 : options.interval) != null ? _a : 1e3, { immediate: (_b = options == null ? void 0 : options.immediate) != null ? _b : false });\n  const reset = (countdown) => {\n    var _a2;\n    remaining.value = (_a2 = toValue(countdown)) != null ? _a2 : toValue(initialCountdown);\n  };\n  const stop = () => {\n    intervalController.pause();\n    reset();\n  };\n  const resume = () => {\n    if (!intervalController.isActive.value) {\n      if (remaining.value > 0) {\n        intervalController.resume();\n      }\n    }\n  };\n  const start = (countdown) => {\n    reset(countdown);\n    intervalController.resume();\n  };\n  return {\n    remaining,\n    reset,\n    stop,\n    start,\n    pause: intervalController.pause,\n    resume,\n    isActive: intervalController.isActive\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue, observe = false } = options;\n  const variable = shallowRef(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window && key) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || variable.value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    (_, old) => {\n      if (old[0] && old[1])\n        old[0].style.removeProperty(old[1]);\n      updateCssVar();\n    },\n    { immediate: true }\n  );\n  watch(\n    [variable, elRef],\n    ([val, el]) => {\n      const raw_prop = toValue(prop);\n      if ((el == null ? void 0 : el.style) && raw_prop) {\n        if (val == null)\n          el.style.removeProperty(raw_prop);\n        else\n          el.style.setProperty(raw_prop, val);\n      }\n    },\n    { immediate: true }\n  );\n  return variable;\n}\n\nfunction useCurrentElement(rootComponent) {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev,\n    go: set\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\"\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const system = computed(() => mode.system.value);\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter,\n    shouldCommit = () => true\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  let lastRawValue = source.value;\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n      lastRawValue = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    if (!shouldCommit(lastRawValue, source.value))\n      return;\n    lastRawValue = source.value;\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions = false,\n    eventFilter = bypassFilter\n  } = options;\n  const isSupported = useSupported(() => typeof DeviceMotionEvent !== \"undefined\");\n  const requirePermissions = useSupported(() => isSupported.value && \"requestPermission\" in DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === \"function\");\n  const permissionGranted = shallowRef(false);\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = shallowRef(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  function init() {\n    if (window) {\n      const onDeviceMotion = createFilterWrapper(\n        eventFilter,\n        (event) => {\n          var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n          acceleration.value = {\n            x: ((_a = event.acceleration) == null ? void 0 : _a.x) || null,\n            y: ((_b = event.acceleration) == null ? void 0 : _b.y) || null,\n            z: ((_c = event.acceleration) == null ? void 0 : _c.z) || null\n          };\n          accelerationIncludingGravity.value = {\n            x: ((_d = event.accelerationIncludingGravity) == null ? void 0 : _d.x) || null,\n            y: ((_e = event.accelerationIncludingGravity) == null ? void 0 : _e.y) || null,\n            z: ((_f = event.accelerationIncludingGravity) == null ? void 0 : _f.z) || null\n          };\n          rotationRate.value = {\n            alpha: ((_g = event.rotationRate) == null ? void 0 : _g.alpha) || null,\n            beta: ((_h = event.rotationRate) == null ? void 0 : _h.beta) || null,\n            gamma: ((_i = event.rotationRate) == null ? void 0 : _i.gamma) || null\n          };\n          interval.value = event.interval;\n        }\n      );\n      useEventListener(window, \"devicemotion\", onDeviceMotion, { passive: true });\n    }\n  }\n  const ensurePermissions = async () => {\n    if (!requirePermissions.value)\n      permissionGranted.value = true;\n    if (permissionGranted.value)\n      return;\n    if (requirePermissions.value) {\n      const requestPermission = DeviceMotionEvent.requestPermission;\n      try {\n        const response = await requestPermission();\n        if (response === \"granted\") {\n          permissionGranted.value = true;\n          init();\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  };\n  if (isSupported.value) {\n    if (requestPermissions && requirePermissions.value) {\n      ensurePermissions().then(() => init());\n    } else {\n      init();\n    }\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval,\n    isSupported,\n    requirePermissions,\n    ensurePermissions,\n    permissionGranted\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = shallowRef(false);\n  const alpha = shallowRef(null);\n  const beta = shallowRef(null);\n  const gamma = shallowRef(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    }, { passive: true });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = shallowRef(1);\n  const query = useMediaQuery(() => `(resolution: ${pixelRatio.value}dppx)`, options);\n  let stop = noop;\n  if (window) {\n    stop = watchImmediate(query, () => pixelRatio.value = window.devicePixelRatio);\n  }\n  return {\n    pixelRatio: readonly(pixelRatio),\n    stop\n  };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = shallowRef(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    const deviceName = constraints.video ? \"camera\" : \"microphone\";\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(deviceName, { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      let granted = true;\n      try {\n        const allDevices = await navigator.mediaDevices.enumerateDevices();\n        const hasCamera = allDevices.some((device) => device.kind === \"videoinput\");\n        const hasMicrophone = allDevices.some((device) => device.kind === \"audioinput\" || device.kind === \"audiooutput\");\n        constraints.video = hasCamera ? constraints.video : false;\n        constraints.audio = hasMicrophone ? constraints.audio : false;\n        stream = await navigator.mediaDevices.getUserMedia(constraints);\n      } catch (e) {\n        stream = null;\n        granted = false;\n      }\n      update();\n      permissionGranted.value = granted;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update, { passive: true });\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    var _a2;\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => useEventListener(t, \"ended\", stop, { passive: true }));\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return shallowRef(\"visible\");\n  const visibility = shallowRef(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  }, { passive: true });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target,\n    buttons = [0]\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (!toValue(buttons).includes(e.button))\n      return;\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = toValue(containerElement);\n    const targetRect = toValue(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = () => {\n      var _a2;\n      return {\n        capture: (_a2 = options.capture) != null ? _a2 : true,\n        passive: !toValue(preventDefault)\n      };\n    };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...toRefs(position),\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  var _a, _b;\n  const isOverDropZone = shallowRef(false);\n  const files = shallowRef(null);\n  let counter = 0;\n  let isValid = true;\n  if (isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const multiple = (_a = _options.multiple) != null ? _a : true;\n    const preventDefaultForUnhandled = (_b = _options.preventDefaultForUnhandled) != null ? _b : false;\n    const getFiles = (event) => {\n      var _a2, _b2;\n      const list = Array.from((_b2 = (_a2 = event.dataTransfer) == null ? void 0 : _a2.files) != null ? _b2 : []);\n      return list.length === 0 ? null : multiple ? list : [list[0]];\n    };\n    const checkDataTypes = (types) => {\n      const dataTypes = unref(_options.dataTypes);\n      if (typeof dataTypes === \"function\")\n        return dataTypes(types);\n      if (!(dataTypes == null ? void 0 : dataTypes.length))\n        return true;\n      if (types.length === 0)\n        return false;\n      return types.every(\n        (type) => dataTypes.some((allowedType) => type.includes(allowedType))\n      );\n    };\n    const checkValidity = (items) => {\n      const types = Array.from(items != null ? items : []).map((item) => item.type);\n      const dataTypesValid = checkDataTypes(types);\n      const multipleFilesValid = multiple || items.length <= 1;\n      return dataTypesValid && multipleFilesValid;\n    };\n    const isSafari = () => /^(?:(?!chrome|android).)*safari/i.test(navigator.userAgent) && !(\"chrome\" in window);\n    const handleDragEvent = (event, eventType) => {\n      var _a2, _b2, _c, _d, _e, _f;\n      const dataTransferItemList = (_a2 = event.dataTransfer) == null ? void 0 : _a2.items;\n      isValid = (_b2 = dataTransferItemList && checkValidity(dataTransferItemList)) != null ? _b2 : false;\n      if (preventDefaultForUnhandled) {\n        event.preventDefault();\n      }\n      if (!isSafari() && !isValid) {\n        if (event.dataTransfer) {\n          event.dataTransfer.dropEffect = \"none\";\n        }\n        return;\n      }\n      event.preventDefault();\n      if (event.dataTransfer) {\n        event.dataTransfer.dropEffect = \"copy\";\n      }\n      const currentFiles = getFiles(event);\n      switch (eventType) {\n        case \"enter\":\n          counter += 1;\n          isOverDropZone.value = true;\n          (_c = _options.onEnter) == null ? void 0 : _c.call(_options, null, event);\n          break;\n        case \"over\":\n          (_d = _options.onOver) == null ? void 0 : _d.call(_options, null, event);\n          break;\n        case \"leave\":\n          counter -= 1;\n          if (counter === 0)\n            isOverDropZone.value = false;\n          (_e = _options.onLeave) == null ? void 0 : _e.call(_options, null, event);\n          break;\n        case \"drop\":\n          counter = 0;\n          isOverDropZone.value = false;\n          if (isValid) {\n            files.value = currentFiles;\n            (_f = _options.onDrop) == null ? void 0 : _f.call(_options, currentFiles, event);\n          }\n          break;\n      }\n    };\n    useEventListener(target, \"dragenter\", (event) => handleDragEvent(event, \"enter\"));\n    useEventListener(target, \"dragover\", (event) => handleDragEvent(event, \"over\"));\n    useEventListener(target, \"dragleave\", (event) => handleDragEvent(event, \"leave\"));\n    useEventListener(target, \"drop\", (event) => handleDragEvent(event, \"drop\"));\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const _targets = toValue(target);\n    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];\n  });\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els) {\n          if (_el)\n            observer.observe(_el, observerOptions);\n        }\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true,\n    updateTiming = \"sync\"\n  } = options;\n  const height = shallowRef(0);\n  const bottom = shallowRef(0);\n  const left = shallowRef(0);\n  const right = shallowRef(0);\n  const top = shallowRef(0);\n  const width = shallowRef(0);\n  const x = shallowRef(0);\n  const y = shallowRef(0);\n  function recalculate() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  function update() {\n    if (updateTiming === \"sync\")\n      recalculate();\n    else if (updateTiming === \"next-frame\")\n      requestAnimationFrame(() => recalculate());\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  useMutationObserver(target, update, {\n    attributeFilter: [\"style\", \"class\"]\n  });\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = shallowRef(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    triggerOnRemoval = false,\n    window = defaultWindow\n  } = options;\n  const isHovered = shallowRef(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  if (triggerOnRemoval) {\n    onElementRemoval(\n      computed(() => unrefElement(el)),\n      () => toggle(false)\n    );\n  }\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = shallowRef(initialSize.width);\n  const height = shallowRef(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const rect = $elem.getBoundingClientRect();\n          width.value = rect.width;\n          height.value = rect.height;\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = toArray(boxSize);\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return toArray(_target).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = shallowRef(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const {\n    window = defaultWindow,\n    scrollTarget,\n    threshold = 0,\n    rootMargin,\n    once = false\n  } = options;\n  const elementIsVisible = shallowRef(false);\n  const { stop } = useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n      if (once) {\n        watchOnce(elementIsVisible, () => {\n          stop();\n        });\n      }\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold,\n      rootMargin: toValue(rootMargin)\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\n// @__NO_SIDE_EFFECTS__\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction resolveNestedOptions$1(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useEventSource(url, events = [], options = {}) {\n  const event = shallowRef(null);\n  const data = shallowRef(null);\n  const status = shallowRef(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const urlRef = toRef(url);\n  const lastEventId = shallowRef(null);\n  let explicitlyClosed = false;\n  let retried = 0;\n  const {\n    withCredentials = false,\n    immediate = true,\n    autoConnect = true,\n    autoReconnect,\n    serializer = {\n      read: (v) => v\n    }\n  } = options;\n  const close = () => {\n    if (isClient && eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n      explicitlyClosed = true;\n    }\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const es = new EventSource(urlRef.value, { withCredentials });\n    status.value = \"CONNECTING\";\n    eventSource.value = es;\n    es.onopen = () => {\n      status.value = \"OPEN\";\n      error.value = null;\n    };\n    es.onerror = (e) => {\n      status.value = \"CLOSED\";\n      error.value = e;\n      if (es.readyState === 2 && !explicitlyClosed && autoReconnect) {\n        es.close();\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions$1(autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    es.onmessage = (e) => {\n      var _a;\n      event.value = null;\n      data.value = (_a = serializer.read(e.data)) != null ? _a : null;\n      lastEventId.value = e.lastEventId;\n    };\n    for (const event_name of events) {\n      useEventListener(es, event_name, (e) => {\n        var _a, _b;\n        event.value = event_name;\n        data.value = (_a = serializer.read(e.data)) != null ? _a : null;\n        lastEventId.value = (_b = e.lastEventId) != null ? _b : null;\n      }, { passive: true });\n    }\n  };\n  const open = () => {\n    if (!isClient)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  if (autoConnect)\n    watch(urlRef, open);\n  tryOnScopeDispose(close);\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    open,\n    close,\n    lastEventId\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = shallowRef(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nconst reAbsolute = /^(?:[a-z][a-z\\d+\\-.]*:)?\\/\\//i;\nfunction isAbsoluteURL(url) {\n  return reAbsolute.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries(headers.entries());\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      let callback;\n      for (let i = callbacks.length - 1; i >= 0; i--) {\n        if (callbacks[i] != null) {\n          callback = callbacks[i];\n          break;\n        }\n      }\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a, _b;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_b = (_a = defaultWindow) == null ? void 0 : _a.fetch) != null ? _b : globalThis == null ? void 0 : globalThis.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = shallowRef(false);\n  const isFetching = shallowRef(false);\n  const aborted = shallowRef(false);\n  const statusCode = shallowRef(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = (reason) => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort(reason);\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2, _b2;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    const payload = toValue(config.payload);\n    if (payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const proto = Object.getPrototypeOf(payload);\n      if (!config.payloadType && payload && (proto === Object.prototype || Array.isArray(proto)) && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return fetch(\n      context.url,\n      {\n        ...defaultFetchOptions,\n        ...context.options,\n        headers: {\n          ...headersToObject(defaultFetchOptions.headers),\n          ...headersToObject((_b2 = context.options) == null ? void 0 : _b2.headers)\n        }\n      }\n    ).then(async (fetchResponse) => {\n      response.value = fetchResponse;\n      statusCode.value = fetchResponse.status;\n      responseData = await fetchResponse.clone()[config.type]();\n      if (!fetchResponse.ok) {\n        data.value = initialData || null;\n        throw new Error(fetchResponse.statusText);\n      }\n      if (options.afterFetch) {\n        ({ data: responseData } = await options.afterFetch({\n          data: responseData,\n          response: fetchResponse,\n          context,\n          execute\n        }));\n      }\n      data.value = responseData;\n      responseEvent.trigger(fetchResponse);\n      return fetchResponse;\n    }).catch(async (fetchError) => {\n      let errorData = fetchError.message || fetchError.name;\n      if (options.onFetchError) {\n        ({ error: errorData, data: responseData } = await options.onFetchError({\n          data: responseData,\n          error: fetchError,\n          response: response.value,\n          context,\n          execute\n        }));\n      }\n      error.value = errorData;\n      if (options.updateDataOnError)\n        data.value = responseData;\n      errorEvent.trigger(fetchError);\n      if (throwOnFailed)\n        throw fetchError;\n      return null;\n    }).finally(() => {\n      if (currentExecuteCounter === executeCounter)\n        loading(false);\n      if (timer)\n        timer.stop();\n      finallyEvent.trigger(null);\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished: readonly(isFinished),\n    isFetching: readonly(isFetching),\n    statusCode,\n    response,\n    error,\n    data,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\")) {\n    return `${start}/${end}`;\n  }\n  if (start.endsWith(\"/\") && end.startsWith(\"/\")) {\n    return `${start.slice(0, -1)}${end}`;\n  }\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction prepareInitialFiles(files) {\n  if (!files)\n    return null;\n  if (files instanceof FileList)\n    return files;\n  const dt = new DataTransfer();\n  for (const file of files) {\n    dt.items.add(file);\n  }\n  return dt.files;\n}\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(prepareInitialFiles(options.initialFiles));\n  const { on: onChange, trigger: changeTrigger } = createEventHook();\n  const { on: onCancel, trigger: cancelTrigger } = createEventHook();\n  const inputRef = computed(() => {\n    var _a;\n    const input = (_a = unrefElement(options.input)) != null ? _a : document ? document.createElement(\"input\") : void 0;\n    if (input) {\n      input.type = \"file\";\n      input.onchange = (event) => {\n        const result = event.target;\n        files.value = result.files;\n        changeTrigger(files.value);\n      };\n      input.oncancel = () => {\n        cancelTrigger();\n      };\n    }\n    return input;\n  });\n  const reset = () => {\n    files.value = null;\n    if (inputRef.value && inputRef.value.value) {\n      inputRef.value.value = \"\";\n      changeTrigger(null);\n    }\n  };\n  const applyOptions = (options2) => {\n    const el = inputRef.value;\n    if (!el)\n      return;\n    el.multiple = toValue(options2.multiple);\n    el.accept = toValue(options2.accept);\n    el.webkitdirectory = toValue(options2.directory);\n    if (hasOwn(options2, \"capture\"))\n      el.capture = toValue(options2.capture);\n  };\n  const open = (localOptions) => {\n    const el = inputRef.value;\n    if (!el)\n      return;\n    const mergedOptions = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    applyOptions(mergedOptions);\n    if (toValue(mergedOptions.reset))\n      reset();\n    el.click();\n  };\n  watchEffect(() => {\n    applyOptions(options);\n  });\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onCancel,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = shallowRef();\n  const data = shallowRef();\n  const file = shallowRef();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\n    fileHandle.value = handle;\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    await updateFile();\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false, preventScroll = false } = options;\n  const innerFocused = shallowRef(false);\n  const targetElement = computed(() => unrefElement(target));\n  const listenerOptions = { passive: true };\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  }, listenerOptions);\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false, listenerOptions);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nconst EVENT_FOCUS_IN = \"focusin\";\nconst EVENT_FOCUS_OUT = \"focusout\";\nconst PSEUDO_CLASS_FOCUS_WITHIN = \":focus-within\";\nfunction useFocusWithin(target, options = {}) {\n  const { window = defaultWindow } = options;\n  const targetElement = computed(() => unrefElement(target));\n  const _focused = shallowRef(false);\n  const focused = computed(() => _focused.value);\n  const activeElement = useActiveElement(options);\n  if (!window || !activeElement.value) {\n    return { focused };\n  }\n  const listenerOptions = { passive: true };\n  useEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);\n  useEventListener(targetElement, EVENT_FOCUS_OUT, () => {\n    var _a, _b, _c;\n    return _focused.value = (_c = (_b = (_a = targetElement.value) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, PSEUDO_CLASS_FOCUS_WITHIN)) != null ? _c : false;\n  }, listenerOptions);\n  return { focused };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useFps(options) {\n  var _a;\n  const fps = shallowRef(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.documentElement;\n  });\n  const isFullscreen = shallowRef(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  const listenerOptions = { capture: false, passive: true };\n  useEventListener(document, eventHandlers, handlerCallback, listenerOptions);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, listenerOptions);\n  tryOnMounted(handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\n// @__NO_SIDE_EFFECTS__\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      index: gamepad.index,\n      connected: gamepad.connected,\n      mapping: gamepad.mapping,\n      timestamp: gamepad.timestamp,\n      vibrationActuator: gamepad.vibrationActuator,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  const listenerOptions = { passive: true };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad), listenerOptions);\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad), listenerOptions);\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        onGamepadConnected(gamepad);\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = shallowRef(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = shallowRef(initialState);\n  const lastActive = shallowRef(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    const listenerOptions = { passive: true };\n    for (const event of events)\n      useEventListener(window, event, onEvent, listenerOptions);\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      }, listenerOptions);\n    }\n    if (!initialState)\n      reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy, width, height, decoding, fetchPriority, ismap, usemap } = options;\n    img.src = src;\n    if (srcset != null)\n      img.srcset = srcset;\n    if (sizes != null)\n      img.sizes = sizes;\n    if (clazz != null)\n      img.className = clazz;\n    if (loading != null)\n      img.loading = loading;\n    if (crossorigin != null)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy != null)\n      img.referrerPolicy = referrerPolicy;\n    if (width != null)\n      img.width = width;\n    if (height != null)\n      img.height = height;\n    if (decoding != null)\n      img.decoding = decoding;\n    if (fetchPriority != null)\n      img.fetchPriority = fetchPriority;\n    if (ismap != null)\n      img.isMap = ismap;\n    if (usemap != null)\n      img.useMap = usemap;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    observe: _observe = {\n      mutation: false\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const observe = typeof _observe === \"boolean\" ? {\n    mutation: _observe\n  } : _observe;\n  const internalX = shallowRef(0);\n  const internalY = shallowRef(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c, _d;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;\n    if (x != null)\n      internalX.value = scrollContainer.scrollLeft;\n    if (y != null)\n      internalY.value = scrollContainer.scrollTop;\n  }\n  const isScrolling = shallowRef(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection, direction } = getComputedStyle(el);\n    const directionMultipler = direction === \"rtl\" ? -1 : 1;\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft * directionMultipler) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft * directionMultipler) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    try {\n      const _element = toValue(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  if ((observe == null ? void 0 : observe.mutation) && element != null && element !== window && element !== document) {\n    useMutationObserver(\n      element,\n      () => {\n        const _element = toValue(element);\n        if (!_element)\n          return;\n        setArrivedState(_element);\n      },\n      {\n        attributes: true,\n        childList: true,\n        subtree: true\n      }\n    );\n  }\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  const stop = watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  tryOnUnmounted(stop);\n  return {\n    isLoading,\n    reset() {\n      nextTick(() => checkAndLoad());\n    }\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\n// @__NO_SIDE_EFFECTS__\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = shallowRef(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      }, { passive: true });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const shiftDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"shift\" && !value) {\n      const shiftDepsArray = Array.from(shiftDeps);\n      const shiftIndex = shiftDepsArray.indexOf(\"shift\");\n      shiftDepsArray.forEach((key2, index) => {\n        if (index >= shiftIndex) {\n          current.delete(key2);\n          setRefs(key2, false);\n        }\n      });\n      shiftDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Shift\") && value) {\n      [...current, ...values].forEach((key2) => shiftDeps.add(key2));\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive });\n  useEventListener(\"focus\", reset, { passive });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.map((key) => toValue(proxy[key])).every(Boolean));\n          } else {\n            refs[prop] = shallowRef(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  target = toRef(target);\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const listenerOptions = { passive: true };\n  const currentTime = shallowRef(0);\n  const duration = shallowRef(0);\n  const seeking = shallowRef(false);\n  const volume = shallowRef(1);\n  const waiting = shallowRef(false);\n  const ended = shallowRef(false);\n  const playing = shallowRef(false);\n  const rate = shallowRef(1);\n  const stalled = shallowRef(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = shallowRef(-1);\n  const isPictureInPicture = shallowRef(false);\n  const muted = shallowRef(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const playbackErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type, media }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.setAttribute(\"media\", media || \"\");\n      useEventListener(source, \"error\", sourceErrorEvent.trigger, listenerOptions);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    if (isPlaying) {\n      el.play().catch((e) => {\n        playbackErrorEvent.trigger(e);\n        throw e;\n      });\n    } else {\n      el.pause();\n    }\n  });\n  useEventListener(\n    target,\n    \"timeupdate\",\n    () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime),\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"durationchange\",\n    () => duration.value = toValue(target).duration,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"progress\",\n    () => buffered.value = timeRangeToArray(toValue(target).buffered),\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"seeking\",\n    () => seeking.value = true,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"seeked\",\n    () => seeking.value = false,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    [\"waiting\", \"loadstart\"],\n    () => {\n      waiting.value = true;\n      ignorePlayingUpdates(() => playing.value = false);\n    },\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"loadeddata\",\n    () => waiting.value = false,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"playing\",\n    () => {\n      waiting.value = false;\n      ended.value = false;\n      ignorePlayingUpdates(() => playing.value = true);\n    },\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"ratechange\",\n    () => rate.value = toValue(target).playbackRate,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"stalled\",\n    () => stalled.value = true,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"ended\",\n    () => ended.value = true,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"pause\",\n    () => ignorePlayingUpdates(() => playing.value = false),\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"play\",\n    () => ignorePlayingUpdates(() => playing.value = true),\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"enterpictureinpicture\",\n    () => isPictureInPicture.value = true,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"leavepictureinpicture\",\n    () => isPictureInPicture.value = false,\n    listenerOptions\n  );\n  useEventListener(\n    target,\n    \"volumechange\",\n    () => {\n      const el = toValue(target);\n      if (!el)\n        return;\n      volume.value = el.volume;\n      muted.value = el.muted;\n    },\n    listenerOptions\n  );\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on,\n    onPlaybackError: playbackErrorEvent.on\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return shallowReactive(options.cache);\n    return shallowReactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof MouseEvent ? [event.movementX, event.movementY] : null\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  let _prevScrollX = 0;\n  let _prevScrollY = 0;\n  const x = shallowRef(initialValue.x);\n  const y = shallowRef(initialValue.y);\n  const sourceType = shallowRef(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n    if (window) {\n      _prevScrollX = window.scrollX;\n      _prevScrollY = window.scrollY;\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX - _prevScrollX;\n      y.value = pos[1] + window.scrollY - _prevScrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, listenerOptions);\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    windowResize = true,\n    windowScroll = true,\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = shallowRef(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = shallowRef(0);\n  const elementY = shallowRef(0);\n  const elementPositionX = shallowRef(0);\n  const elementPositionY = shallowRef(0);\n  const elementHeight = shallowRef(0);\n  const elementWidth = shallowRef(0);\n  const isOutside = shallowRef(true);\n  function update() {\n    if (!window)\n      return;\n    const el = unrefElement(targetRef);\n    if (!el || !(el instanceof Element))\n      return;\n    const {\n      left,\n      top,\n      width,\n      height\n    } = el.getBoundingClientRect();\n    elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n    elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n    elementHeight.value = height;\n    elementWidth.value = width;\n    const elX = x.value - elementPositionX.value;\n    const elY = y.value - elementPositionY.value;\n    isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n    if (handleOutside || !isOutside.value) {\n      elementX.value = elX;\n      elementY.value = elY;\n    }\n  }\n  const stopFnList = [];\n  function stop() {\n    stopFnList.forEach((fn) => fn());\n    stopFnList.length = 0;\n  }\n  tryOnMounted(() => {\n    update();\n  });\n  if (window) {\n    const {\n      stop: stopResizeObserver\n    } = useResizeObserver(targetRef, update);\n    const {\n      stop: stopMutationObserver\n    } = useMutationObserver(targetRef, update, {\n      attributeFilter: [\"style\", \"class\"]\n    });\n    const stopWatch = watch(\n      [targetRef, x, y],\n      update\n    );\n    stopFnList.push(\n      stopResizeObserver,\n      stopMutationObserver,\n      stopWatch\n    );\n    useEventListener(\n      document,\n      \"mouseleave\",\n      () => isOutside.value = true,\n      { passive: true }\n    );\n    if (windowScroll) {\n      stopFnList.push(\n        useEventListener(\"scroll\", update, { capture: true, passive: true })\n      );\n    }\n    if (windowResize) {\n      stopFnList.push(\n        useEventListener(\"resize\", update, { passive: true })\n      );\n    }\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = shallowRef(initialValue);\n  const sourceType = shallowRef(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => (event) => {\n    var _a;\n    pressed.value = true;\n    sourceType.value = srcType;\n    (_a = options.onPressed) == null ? void 0 : _a.call(options, event);\n  };\n  const onReleased = (event) => {\n    var _a;\n    pressed.value = false;\n    sourceType.value = null;\n    (_a = options.onReleased) == null ? void 0 : _a.call(options, event);\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  const listenerOptions = { passive: true, capture };\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), listenerOptions);\n  useEventListener(window, \"mouseleave\", onReleased, listenerOptions);\n  useEventListener(window, \"mouseup\", onReleased, listenerOptions);\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), listenerOptions);\n    useEventListener(window, \"drop\", onReleased, listenerOptions);\n    useEventListener(window, \"dragend\", onReleased, listenerOptions);\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), listenerOptions);\n    useEventListener(window, \"touchend\", onReleased, listenerOptions);\n    useEventListener(window, \"touchcancel\", onReleased, listenerOptions);\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = shallowRef(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  }, { passive: true });\n  return {\n    isSupported,\n    language\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = shallowRef(true);\n  const saveData = shallowRef(false);\n  const offlineAt = shallowRef(void 0);\n  const onlineAt = shallowRef(void 0);\n  const downlink = shallowRef(void 0);\n  const downlinkMax = shallowRef(void 0);\n  const rtt = shallowRef(void 0);\n  const effectiveType = shallowRef(void 0);\n  const type = shallowRef(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  const listenerOptions = { passive: true };\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    }, listenerOptions);\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    }, listenerOptions);\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, listenerOptions);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline: readonly(isOnline),\n    saveData: readonly(saveData),\n    offlineAt: readonly(offlineAt),\n    onlineAt: readonly(onlineAt),\n    downlink: readonly(downlink),\n    downlinkMax: readonly(downlinkMax),\n    effectiveType: readonly(effectiveType),\n    rtt: readonly(rtt),\n    type: readonly(type)\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate }) : useIntervalFn(update, interval, { immediate });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = shallowRef();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page)) {\n    syncRef(page, currentPage, {\n      direction: isReadonly(page) ? \"ltr\" : \"both\"\n    });\n  }\n  if (isRef(pageSize)) {\n    syncRef(pageSize, currentPageSize, {\n      direction: isReadonly(pageSize) ? \"ltr\" : \"both\"\n    });\n  }\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = shallowRef(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    const listenerOptions = { passive: true };\n    useEventListener(window, \"mouseout\", handler, listenerOptions);\n    useEventListener(window.document, \"mouseleave\", handler, listenerOptions);\n    useEventListener(window.document, \"mouseenter\", handler, listenerOptions);\n  }\n  return isLeft;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = shallowRef(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    }, { passive: true });\n  }\n  const lockOrientation = (type) => {\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\n      return screenOrientation.lock(type);\n    return Promise.reject(new Error(\"Not supported\"));\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const screenOrientation = reactive(useScreenOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {\n      return \"deviceOrientation\";\n    }\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        case \"portrait-primary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-secondary\":\n          value = orientation.beta / 90;\n          break;\n        default:\n          value = -orientation.beta / 90;\n      }\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.beta / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"portrait-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        default:\n          value = orientation.gamma / 90;\n      }\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = shallowRef(false);\n  const state = shallowRef(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...toRefs(state),\n    isInside\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = shallowRef();\n  const triggerElement = shallowRef();\n  let targetElement;\n  if (isSupported.value) {\n    const listenerOptions = { passive: true };\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    }, listenerOptions);\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    }, listenerOptions);\n  }\n  async function lock(e) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock();\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    disableTextSelect = false\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = shallowRef(false);\n  const isPointerDown = shallowRef(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const listenerOptions = { passive: true };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, \"pointerup\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n    }, listenerOptions)\n  ];\n  tryOnMounted(() => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"pan-y\");\n    if (disableTextSelect) {\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\n    }\n  });\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return shallowRef([\"en\"]);\n  const navigator = window.navigator;\n  const value = shallowRef(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  }, { passive: true });\n  return value;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction usePreferredReducedTransparency(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-transparency: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = shallowRef(\"\");\n  const right = shallowRef(\"\");\n  const bottom = shallowRef(\"\");\n  const left = shallowRef(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    tryOnMounted(update);\n    useEventListener(\"resize\", useDebounceFn(update), { passive: true });\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {},\n    nonce = void 0\n  } = options;\n  const scriptTag = shallowRef(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      if (nonce) {\n        el.nonce = nonce;\n      }\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    const listenerOptions = {\n      passive: true\n    };\n    useEventListener(el, \"error\", (event) => reject(event), listenerOptions);\n    useEventListener(el, \"abort\", (event) => reject(event), listenerOptions);\n    useEventListener(el, \"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    }, listenerOptions);\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = shallowRef(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow = \"\";\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (ele.style.overflow !== \"hidden\")\n        initialOverflow = ele.style.overflow;\n      if (ele.style.overflow === \"hidden\")\n        return isLocked.value = true;\n      if (isLocked.value)\n        return ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    if (isIOS)\n      stopTouchMoveListener == null ? void 0 : stopTouchMoveListener();\n    el.style.overflow = initialOverflow;\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...toValue(shareOptions),\n        ...toValue(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    maxAlternatives = 1,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = shallowRef(false);\n  const isFinal = shallowRef(false);\n  const result = shallowRef(\"\");\n  const error = shallowRef(void 0);\n  let recognition;\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const toggle = (value = !isListening.value) => {\n    if (value) {\n      start();\n    } else {\n      stop();\n    }\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.maxAlternatives = maxAlternatives;\n    recognition.onstart = () => {\n      isListening.value = true;\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const currentResult = event.results[event.resultIndex];\n      const { transcript } = currentResult[0];\n      isFinal.value = currentResult.isFinal;\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, (newValue, oldValue) => {\n      if (newValue === oldValue)\n        return;\n      if (newValue)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow,\n    onBoundary\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = shallowRef(false);\n  const status = shallowRef(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = toValue(pitch);\n    utterance2.rate = toValue(rate);\n    utterance2.volume = toValue(volume);\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n    utterance2.onboundary = (event) => {\n      onBoundary == null ? void 0 : onBoundary(event);\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    if (utterance)\n      synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    onReady\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(toValue(initialValue));\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  const promise = new Promise((resolve) => {\n    read().then(() => {\n      onReady == null ? void 0 : onReady(data.value);\n      resolve(data);\n    });\n  });\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)), { passive: true });\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  Object.assign(data, {\n    then: promise.then.bind(promise),\n    catch: promise.catch.bind(promise)\n  });\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = shallowRef(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = shallowRef(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.nonce)\n        el.nonce = options.nonce;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = shallowRef(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  const listenerOptions = { passive, capture: !passive };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value))\n        e.preventDefault();\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop,\n    // TODO: Remove in the next major version\n    isPassiveEventSupported: true\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\n// @__NO_SIDE_EFFECTS__\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange, { passive: true });\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction tryRequestAnimationFrame(window = defaultWindow, fn) {\n  if (window && typeof window.requestAnimationFrame === \"function\") {\n    window.requestAnimationFrame(fn);\n  } else {\n    fn();\n  }\n}\nfunction useTextareaAutosize(options = {}) {\n  var _a, _b;\n  const { window = defaultWindow } = options;\n  const textarea = toRef(options == null ? void 0 : options.element);\n  const input = toRef((_a = options == null ? void 0 : options.input) != null ? _a : \"\");\n  const styleProp = (_b = options == null ? void 0 : options.styleProp) != null ? _b : \"height\";\n  const textareaScrollHeight = shallowRef(1);\n  const textareaOldWidth = shallowRef(0);\n  function triggerResize() {\n    var _a2;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style[styleProp] = \"1px\";\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\n    const _styleTarget = toValue(options == null ? void 0 : options.styleTarget);\n    if (_styleTarget)\n      _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style[styleProp] = height;\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  watch(textareaScrollHeight, () => {\n    var _a2;\n    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);\n  });\n  useResizeObserver(textarea, ([{ contentRect }]) => {\n    if (textareaOldWidth.value === contentRect.width)\n      return;\n    tryRequestAnimationFrame(window, () => {\n      textareaOldWidth.value = contentRect.width;\n      triggerResize();\n    });\n  });\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\n// @__NO_SIDE_EFFECTS__\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nconst UNITS = [\n  { name: \"year\", ms: 31536e6 },\n  { name: \"month\", ms: 2592e6 },\n  { name: \"week\", ms: 6048e5 },\n  { name: \"day\", ms: 864e5 },\n  { name: \"hour\", ms: 36e5 },\n  { name: \"minute\", ms: 6e4 },\n  { name: \"second\", ms: 1e3 }\n];\nfunction useTimeAgoIntl(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const result = computed(\n    () => getTimeAgoIntlResult(new Date(toValue(time)), options, toValue(now))\n  );\n  const parts = computed(() => result.value.parts);\n  const timeAgoIntl = computed(\n    () => formatTimeAgoIntlParts(parts.value, {\n      ...options,\n      locale: result.value.resolvedLocale\n    })\n  );\n  return exposeControls ? { timeAgoIntl, parts, ...controls } : timeAgoIntl;\n}\nfunction formatTimeAgoIntl(from, options = {}, now = Date.now()) {\n  const { parts, resolvedLocale } = getTimeAgoIntlResult(from, options, now);\n  return formatTimeAgoIntlParts(parts, {\n    ...options,\n    locale: resolvedLocale\n  });\n}\nfunction getTimeAgoIntlResult(from, options = {}, now = Date.now()) {\n  const {\n    locale,\n    relativeTimeFormatOptions = { numeric: \"auto\" }\n  } = options;\n  const rtf = new Intl.RelativeTimeFormat(locale, relativeTimeFormatOptions);\n  const { locale: resolvedLocale } = rtf.resolvedOptions();\n  const diff = +from - +now;\n  const absDiff = Math.abs(diff);\n  for (const { name, ms } of UNITS) {\n    if (absDiff >= ms) {\n      return {\n        resolvedLocale,\n        parts: rtf.formatToParts(Math.round(diff / ms), name)\n      };\n    }\n  }\n  return {\n    resolvedLocale,\n    parts: rtf.formatToParts(0, \"second\")\n  };\n}\nfunction formatTimeAgoIntlParts(parts, options = {}) {\n  const {\n    insertSpace = true,\n    joinParts,\n    locale\n  } = options;\n  if (typeof joinParts === \"function\")\n    return joinParts(parts, locale);\n  if (!insertSpace)\n    return parts.map((part) => part.value).join(\"\");\n  return parts.map((part) => part.value.trim()).join(\" \");\n}\n\nfunction useTimeoutPoll(fn, interval, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  const { start } = useTimeoutFn(loop, interval, { immediate });\n  const isActive = shallowRef(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      if (immediateCallback)\n        fn();\n      start();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (immediate && isClient)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = shallowRef(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b, _c;\n  const {\n    document = defaultDocument,\n    restoreOnUnmount = (t) => t\n  } = options;\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\n  const title = toRef((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\n  const isReadonly = !!(newTitle && typeof newTitle === \"function\");\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (newValue, oldValue) => {\n      if (newValue !== oldValue && document)\n        document.title = format(newValue != null ? newValue : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  tryOnScopeDispose(() => {\n    if (restoreOnUnmount) {\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n      if (restoredTitle != null && document)\n        document.title = restoredTitle;\n    }\n  });\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const {\n    window = defaultWindow\n  } = options;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        window == null ? void 0 : window.requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    writeMode = \"replace\",\n    window = defaultWindow,\n    stringify = (params) => params.toString()\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = stringify(params);\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${window.location.search || \"\"}${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${window.location.search || \"\"}${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params, false);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate, shouldWriteHistory = true) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    if (writeMode === \"replace\") {\n      window.history.replaceState(\n        window.history.state,\n        window.document.title,\n        window.location.pathname + constructQuery(params)\n      );\n    } else {\n      if (shouldWriteHistory) {\n        window.history.pushState(\n          window.history.state,\n          window.document.title,\n          window.location.pathname + constructQuery(params)\n        );\n      }\n    }\n    nextTick(() => resume());\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true, false);\n  }\n  const listenerOptions = { passive: true };\n  useEventListener(window, \"popstate\", onChanged, listenerOptions);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, listenerOptions);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = shallowRef((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = shallowRef((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    key = \"modelValue\";\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    let isUpdating = false;\n    watch(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          nextTick(() => isUpdating = false);\n        }\n      }\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = shallowRef(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, containerRef, calculateRange) {\n  watch([size.width, size.height, () => toValue(list), containerRef], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  const requestedType = shallowRef(false);\n  const sentinel = shallowRef(null);\n  const documentVisibility = useDocumentVisibility({ document });\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = computed(() => !!sentinel.value && documentVisibility.value === \"visible\");\n  if (isSupported.value) {\n    useEventListener(sentinel, \"release\", () => {\n      var _a, _b;\n      requestedType.value = (_b = (_a = sentinel.value) == null ? void 0 : _a.type) != null ? _b : false;\n    }, { passive: true });\n    whenever(\n      () => documentVisibility.value === \"visible\" && (document == null ? void 0 : document.visibilityState) === \"visible\" && requestedType.value,\n      (type) => {\n        requestedType.value = false;\n        forceRequest(type);\n      }\n    );\n  }\n  async function forceRequest(type) {\n    var _a;\n    await ((_a = sentinel.value) == null ? void 0 : _a.release());\n    sentinel.value = isSupported.value ? await navigator.wakeLock.request(type) : null;\n  }\n  async function request(type) {\n    if (documentVisibility.value === \"visible\")\n      await forceRequest(type);\n    else\n      requestedType.value = type;\n  }\n  async function release() {\n    requestedType.value = false;\n    const s = sentinel.value;\n    sentinel.value = null;\n    await (s == null ? void 0 : s.release());\n  }\n  return {\n    sentinel,\n    isSupported,\n    isActive,\n    request,\n    forceRequest,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => {\n    if (!window || !(\"Notification\" in window))\n      return false;\n    if (Notification.permission === \"granted\")\n      return true;\n    try {\n      const notification2 = new Notification(\"\");\n      notification2.onshow = () => {\n        notification2.close();\n      };\n    } catch (e) {\n      if (e.name === \"TypeError\")\n        return false;\n    }\n    return true;\n  });\n  const permissionGranted = shallowRef(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = ref(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    tryOnMounted(ensurePermissions);\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoConnect = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = shallowRef(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let retryTimeout;\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetRetry = () => {\n    if (retryTimeout != null) {\n      clearTimeout(retryTimeout);\n      retryTimeout = void 0;\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    resetRetry();\n    if (!isClient && !isWorker || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n    wsRef.value = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      retried = 0;\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      resetHeartbeat();\n      heartbeatPause == null ? void 0 : heartbeatPause();\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect && (wsRef.value == null || ws === wsRef.value)) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        const checkRetires = typeof retries === \"function\" ? retries : () => typeof retries === \"number\" && (retries < 0 || retried < retries);\n        if (checkRetires(retried)) {\n          retried += 1;\n          retryTimeout = setTimeout(_init, delay);\n        } else {\n          onFailed == null ? void 0 : onFailed();\n        }\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE,\n          responseMessage = message\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === toValue(responseMessage))\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(toValue(message), false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (isClient)\n      useEventListener(\"beforeunload\", () => close(), { passive: true });\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    if (!isClient && !isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  if (autoConnect)\n    watch(urlRef, open);\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction depsParser(deps, localDeps) {\n  if (deps.length === 0 && localDeps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  const depsFunctionString = localDeps.filter((dep) => typeof dep === \"function\").map((fn) => {\n    const str = fn.toString();\n    if (str.trim().startsWith(\"function\")) {\n      return str;\n    } else {\n      const name = fn.name;\n      return `const ${name} = ${str}`;\n    }\n  }).join(\";\");\n  const importString = `importScripts(${depsString});`;\n  return `${depsString.trim() === \"\" ? \"\" : importString} ${depsFunctionString}`;\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction createWorkerBlobUrl(fn, deps, localDeps) {\n  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    localDependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = shallowRef(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = shallowRef();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    var _a;\n    promise.value = {\n      resolve,\n      reject\n    };\n    (_a = worker.value) == null ? void 0 : _a.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return shallowRef(false);\n  const focused = shallowRef(window.document.hasFocus());\n  const listenerOptions = { passive: true };\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  }, listenerOptions);\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  }, listenerOptions);\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, ...rest } = options;\n  return useScroll(window, rest);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true,\n    type = \"inner\"\n  } = options;\n  const width = shallowRef(initialWidth);\n  const height = shallowRef(initialHeight);\n  const update = () => {\n    if (window) {\n      if (type === \"outer\") {\n        width.value = window.outerWidth;\n        height.value = window.outerHeight;\n      } else if (type === \"visual\" && window.visualViewport) {\n        const { width: visualViewportWidth, height: visualViewportHeight, scale } = window.visualViewport;\n        width.value = Math.round(visualViewportWidth * scale);\n        height.value = Math.round(visualViewportHeight * scale);\n      } else if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  const listenerOptions = { passive: true };\n  useEventListener(\"resize\", update, listenerOptions);\n  if (window && type === \"visual\" && window.visualViewport) {\n    useEventListener(window.visualViewport, \"resize\", update, listenerOptions);\n  }\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsElement, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, formatTimeAgoIntl, formatTimeAgoIntlParts, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onElementRemoval, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, provideSSRWidth, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCountdown, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePreferredReducedTransparency, usePrevious, useRafFn, useRefHistory, useResizeObserver, useSSRWidth, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeAgoIntl, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n * Observer 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _clamp,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _isTouch,\n    _pointerType,\n    ScrollTrigger,\n    _root,\n    _normalizer,\n    _eventTypes,\n    _context,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _startup = 1,\n    _observers = [],\n    _scrollers = [],\n    _proxies = [],\n    _getTime = Date.now,\n    _bridge = function _bridge(name, value) {\n  return value;\n},\n    _integrate = function _integrate() {\n  var core = ScrollTrigger.core,\n      data = core.bridge || {},\n      scrollers = core._scrollers,\n      proxies = core._proxies;\n  scrollers.push.apply(scrollers, _scrollers);\n  proxies.push.apply(proxies, _proxies);\n  _scrollers = scrollers;\n  _proxies = proxies;\n\n  _bridge = function _bridge(name, value) {\n    return data[name](value);\n  };\n},\n    _getProxyProp = function _getProxyProp(element, property) {\n  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n},\n    _isViewport = function _isViewport(el) {\n  return !!~_root.indexOf(el);\n},\n    _addListener = function _addListener(element, type, func, passive, capture) {\n  return element.addEventListener(type, func, {\n    passive: passive !== false,\n    capture: !!capture\n  });\n},\n    _removeListener = function _removeListener(element, type, func, capture) {\n  return element.removeEventListener(type, func, !!capture);\n},\n    _scrollLeft = \"scrollLeft\",\n    _scrollTop = \"scrollTop\",\n    _onScroll = function _onScroll() {\n  return _normalizer && _normalizer.isPressed || _scrollers.cache++;\n},\n    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {\n  var cachingFunc = function cachingFunc(value) {\n    // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n    if (value || value === 0) {\n      _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n\n      var isNormalizing = _normalizer && _normalizer.isPressed;\n      value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n\n      f(value);\n      cachingFunc.cacheID = _scrollers.cache;\n      isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n    } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n      cachingFunc.cacheID = _scrollers.cache;\n      cachingFunc.v = f();\n    }\n\n    return cachingFunc.v + cachingFunc.offset;\n  };\n\n  cachingFunc.offset = 0;\n  return f && cachingFunc;\n},\n    _horizontal = {\n  s: _scrollLeft,\n  p: \"left\",\n  p2: \"Left\",\n  os: \"right\",\n  os2: \"Right\",\n  d: \"width\",\n  d2: \"Width\",\n  a: \"x\",\n  sc: _scrollCacheFunc(function (value) {\n    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n  })\n},\n    _vertical = {\n  s: _scrollTop,\n  p: \"top\",\n  p2: \"Top\",\n  os: \"bottom\",\n  os2: \"Bottom\",\n  d: \"height\",\n  d2: \"Height\",\n  a: \"y\",\n  op: _horizontal,\n  sc: _scrollCacheFunc(function (value) {\n    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n  })\n},\n    _getTarget = function _getTarget(t, self) {\n  return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\n},\n    _isWithin = function _isWithin(element, list) {\n  // check if the element is in the list or is a descendant of an element in the list.\n  var i = list.length;\n\n  while (i--) {\n    if (list[i] === element || list[i].contains(element)) {\n      return true;\n    }\n  }\n\n  return false;\n},\n    _getScrollFunc = function _getScrollFunc(element, _ref) {\n  var s = _ref.s,\n      sc = _ref.sc;\n  // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n  _isViewport(element) && (element = _doc.scrollingElement || _docEl);\n\n  var i = _scrollers.indexOf(element),\n      offset = sc === _vertical.sc ? 1 : 2;\n\n  !~i && (i = _scrollers.push(element) - 1);\n  _scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll); // clear the cache when a scroll occurs\n\n  var prev = _scrollers[i + offset],\n      func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {\n    return arguments.length ? element[s] = value : element[s];\n  })));\n  func.target = element;\n  prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\n\n  return func;\n},\n    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {\n  var v1 = value,\n      v2 = value,\n      t1 = _getTime(),\n      t2 = t1,\n      min = minTimeRefresh || 50,\n      dropToZeroTime = Math.max(500, min * 3),\n      update = function update(value, force) {\n    var t = _getTime();\n\n    if (force || t - t1 > min) {\n      v2 = v1;\n      v1 = value;\n      t2 = t1;\n      t1 = t;\n    } else if (useDelta) {\n      v1 += value;\n    } else {\n      // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n      v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\n    }\n  },\n      reset = function reset() {\n    v2 = v1 = useDelta ? 0 : v1;\n    t2 = t1 = 0;\n  },\n      getVelocity = function getVelocity(latestValue) {\n    var tOld = t2,\n        vOld = v2,\n        t = _getTime();\n\n    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n  };\n\n  return {\n    update: update,\n    reset: reset,\n    getVelocity: getVelocity\n  };\n},\n    _getEvent = function _getEvent(e, preventDefault) {\n  preventDefault && !e._gsapAllow && e.preventDefault();\n  return e.changedTouches ? e.changedTouches[0] : e;\n},\n    _getAbsoluteMax = function _getAbsoluteMax(a) {\n  var max = Math.max.apply(Math, a),\n      min = Math.min.apply(Math, a);\n  return Math.abs(max) >= Math.abs(min) ? max : min;\n},\n    _setScrollTrigger = function _setScrollTrigger() {\n  ScrollTrigger = gsap.core.globals().ScrollTrigger;\n  ScrollTrigger && ScrollTrigger.core && _integrate();\n},\n    _initCore = function _initCore(core) {\n  gsap = core || _getGSAP();\n\n  if (!_coreInitted && gsap && typeof document !== \"undefined\" && document.body) {\n    _win = window;\n    _doc = document;\n    _docEl = _doc.documentElement;\n    _body = _doc.body;\n    _root = [_win, _doc, _docEl, _body];\n    _clamp = gsap.utils.clamp;\n\n    _context = gsap.core.context || function () {};\n\n    _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n\n    _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n    _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n    setTimeout(function () {\n      return _startup = 0;\n    }, 500);\n\n    _setScrollTrigger();\n\n    _coreInitted = 1;\n  }\n\n  return _coreInitted;\n};\n\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nexport var Observer = /*#__PURE__*/function () {\n  function Observer(vars) {\n    this.init(vars);\n  }\n\n  var _proto = Observer.prototype;\n\n  _proto.init = function init(vars) {\n    _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n    ScrollTrigger || _setScrollTrigger();\n    var tolerance = vars.tolerance,\n        dragMinimum = vars.dragMinimum,\n        type = vars.type,\n        target = vars.target,\n        lineHeight = vars.lineHeight,\n        debounce = vars.debounce,\n        preventDefault = vars.preventDefault,\n        onStop = vars.onStop,\n        onStopDelay = vars.onStopDelay,\n        ignore = vars.ignore,\n        wheelSpeed = vars.wheelSpeed,\n        event = vars.event,\n        onDragStart = vars.onDragStart,\n        onDragEnd = vars.onDragEnd,\n        onDrag = vars.onDrag,\n        onPress = vars.onPress,\n        onRelease = vars.onRelease,\n        onRight = vars.onRight,\n        onLeft = vars.onLeft,\n        onUp = vars.onUp,\n        onDown = vars.onDown,\n        onChangeX = vars.onChangeX,\n        onChangeY = vars.onChangeY,\n        onChange = vars.onChange,\n        onToggleX = vars.onToggleX,\n        onToggleY = vars.onToggleY,\n        onHover = vars.onHover,\n        onHoverEnd = vars.onHoverEnd,\n        onMove = vars.onMove,\n        ignoreCheck = vars.ignoreCheck,\n        isNormalizer = vars.isNormalizer,\n        onGestureStart = vars.onGestureStart,\n        onGestureEnd = vars.onGestureEnd,\n        onWheel = vars.onWheel,\n        onEnable = vars.onEnable,\n        onDisable = vars.onDisable,\n        onClick = vars.onClick,\n        scrollSpeed = vars.scrollSpeed,\n        capture = vars.capture,\n        allowClicks = vars.allowClicks,\n        lockAxis = vars.lockAxis,\n        onLockAxis = vars.onLockAxis;\n    this.target = target = _getTarget(target) || _docEl;\n    this.vars = vars;\n    ignore && (ignore = gsap.utils.toArray(ignore));\n    tolerance = tolerance || 1e-9;\n    dragMinimum = dragMinimum || 0;\n    wheelSpeed = wheelSpeed || 1;\n    scrollSpeed = scrollSpeed || 1;\n    type = type || \"wheel,touch,pointer\";\n    debounce = debounce !== false;\n    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n\n    var id,\n        onStopDelayedCall,\n        dragged,\n        moved,\n        wheeled,\n        locked,\n        axis,\n        self = this,\n        prevDeltaX = 0,\n        prevDeltaY = 0,\n        passive = vars.passive || !preventDefault && vars.passive !== false,\n        scrollFuncX = _getScrollFunc(target, _horizontal),\n        scrollFuncY = _getScrollFunc(target, _vertical),\n        scrollX = scrollFuncX(),\n        scrollY = scrollFuncY(),\n        limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\",\n        // for devices that accommodate mouse events and touch events, we need to distinguish.\n    isViewport = _isViewport(target),\n        ownerDoc = target.ownerDocument || _doc,\n        deltaX = [0, 0, 0],\n        // wheel, scroll, pointer/touch\n    deltaY = [0, 0, 0],\n        onClickTime = 0,\n        clickCapture = function clickCapture() {\n      return onClickTime = _getTime();\n    },\n        _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {\n      return (self.event = e) && ignore && _isWithin(e.target, ignore) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\n    },\n        onStopFunc = function onStopFunc() {\n      self._vx.reset();\n\n      self._vy.reset();\n\n      onStopDelayedCall.pause();\n      onStop && onStop(self);\n    },\n        update = function update() {\n      var dx = self.deltaX = _getAbsoluteMax(deltaX),\n          dy = self.deltaY = _getAbsoluteMax(deltaY),\n          changedX = Math.abs(dx) >= tolerance,\n          changedY = Math.abs(dy) >= tolerance;\n\n      onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n\n      if (changedX) {\n        onRight && self.deltaX > 0 && onRight(self);\n        onLeft && self.deltaX < 0 && onLeft(self);\n        onChangeX && onChangeX(self);\n        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n        prevDeltaX = self.deltaX;\n        deltaX[0] = deltaX[1] = deltaX[2] = 0;\n      }\n\n      if (changedY) {\n        onDown && self.deltaY > 0 && onDown(self);\n        onUp && self.deltaY < 0 && onUp(self);\n        onChangeY && onChangeY(self);\n        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n        prevDeltaY = self.deltaY;\n        deltaY[0] = deltaY[1] = deltaY[2] = 0;\n      }\n\n      if (moved || dragged) {\n        onMove && onMove(self);\n\n        if (dragged) {\n          onDragStart && dragged === 1 && onDragStart(self);\n          onDrag && onDrag(self);\n          dragged = 0;\n        }\n\n        moved = false;\n      }\n\n      locked && !(locked = false) && onLockAxis && onLockAxis(self);\n\n      if (wheeled) {\n        onWheel(self);\n        wheeled = false;\n      }\n\n      id = 0;\n    },\n        onDelta = function onDelta(x, y, index) {\n      deltaX[index] += x;\n      deltaY[index] += y;\n\n      self._vx.update(x);\n\n      self._vy.update(y);\n\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\n    },\n        onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {\n      if (lockAxis && !axis) {\n        self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n        locked = true;\n      }\n\n      if (axis !== \"y\") {\n        deltaX[2] += x;\n\n        self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n\n      }\n\n      if (axis !== \"x\") {\n        deltaY[2] += y;\n\n        self._vy.update(y, true);\n      }\n\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\n    },\n        _onDrag = function _onDrag(e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n\n      e = _getEvent(e, preventDefault);\n      var x = e.clientX,\n          y = e.clientY,\n          dx = x - self.x,\n          dy = y - self.y,\n          isDragging = self.isDragging;\n      self.x = x;\n      self.y = y;\n\n      if (isDragging || (dx || dy) && (Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum)) {\n        dragged = isDragging ? 2 : 1; // dragged: 0 = not dragging, 1 = first drag, 2 = normal drag\n\n        isDragging || (self.isDragging = true);\n        onTouchOrPointerDelta(dx, dy);\n      }\n    },\n        _onPress = self.onPress = function (e) {\n      if (_ignoreCheck(e, 1) || e && e.button) {\n        return;\n      }\n\n      self.axis = axis = null;\n      onStopDelayedCall.pause();\n      self.isPressed = true;\n      e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n\n      prevDeltaX = prevDeltaY = 0;\n      self.startX = self.x = e.clientX;\n      self.startY = self.y = e.clientY;\n\n      self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n\n\n      self._vy.reset();\n\n      _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\n\n      self.deltaX = self.deltaY = 0;\n      onPress && onPress(self);\n    },\n        _onRelease = self.onRelease = function (e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n\n      _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n\n      var isTrackingDrag = !isNaN(self.y - self.startY),\n          wasDragging = self.isDragging,\n          isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),\n          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n      eventData = _getEvent(e);\n\n      if (!isDragNotClick && isTrackingDrag) {\n        self._vx.reset();\n\n        self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.\n\n\n        if (preventDefault && allowClicks) {\n          gsap.delayedCall(0.08, function () {\n            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n              if (e.target.click) {\n                //some browsers (like mobile Safari) don't properly trigger the click event\n                e.target.click();\n              } else if (ownerDoc.createEvent) {\n                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                e.target.dispatchEvent(syntheticEvent);\n              }\n            }\n          });\n        }\n      }\n\n      self.isDragging = self.isGesturing = self.isPressed = false;\n      onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\n      dragged && update(); // in case debouncing, we don't want onDrag to fire AFTER onDragEnd().\n\n      onDragEnd && wasDragging && onDragEnd(self);\n      onRelease && onRelease(self, isDragNotClick);\n    },\n        _onGestureStart = function _onGestureStart(e) {\n      return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\n    },\n        _onGestureEnd = function _onGestureEnd() {\n      return (self.isGesturing = false) || onGestureEnd(self);\n    },\n        onScroll = function onScroll(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      var x = scrollFuncX(),\n          y = scrollFuncY();\n      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n      scrollX = x;\n      scrollY = y;\n      onStop && onStopDelayedCall.restart(true);\n    },\n        _onWheel = function _onWheel(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      e = _getEvent(e, preventDefault);\n      onWheel && (wheeled = true);\n      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n      onStop && !isNormalizer && onStopDelayedCall.restart(true);\n    },\n        _onMove = function _onMove(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      var x = e.clientX,\n          y = e.clientY,\n          dx = x - self.x,\n          dy = y - self.y;\n      self.x = x;\n      self.y = y;\n      moved = true;\n      onStop && onStopDelayedCall.restart(true);\n      (dx || dy) && onTouchOrPointerDelta(dx, dy);\n    },\n        _onHover = function _onHover(e) {\n      self.event = e;\n      onHover(self);\n    },\n        _onHoverEnd = function _onHoverEnd(e) {\n      self.event = e;\n      onHoverEnd(self);\n    },\n        _onClick = function _onClick(e) {\n      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n    };\n\n    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n    self.deltaX = self.deltaY = 0;\n    self._vx = _getVelocityProp(0, 50, true);\n    self._vy = _getVelocityProp(0, 50, true);\n    self.scrollX = scrollFuncX;\n    self.scrollY = scrollFuncY;\n    self.isDragging = self.isGesturing = self.isPressed = false;\n\n    _context(this);\n\n    self.enable = function (e) {\n      if (!self.isEnabled) {\n        _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n\n        type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\n        type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\n\n        if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n          _addListener(target, _eventTypes[0], _onPress, passive, capture);\n\n          _addListener(ownerDoc, _eventTypes[2], _onRelease);\n\n          _addListener(ownerDoc, _eventTypes[3], _onRelease);\n\n          allowClicks && _addListener(target, \"click\", clickCapture, true, true);\n          onClick && _addListener(target, \"click\", _onClick);\n          onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n          onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n          onHover && _addListener(target, _pointerType + \"enter\", _onHover);\n          onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n          onMove && _addListener(target, _pointerType + \"move\", _onMove);\n        }\n\n        self.isEnabled = true;\n        self.isDragging = self.isGesturing = self.isPressed = moved = dragged = false;\n\n        self._vx.reset();\n\n        self._vy.reset();\n\n        scrollX = scrollFuncX();\n        scrollY = scrollFuncY();\n        e && e.type && _onPress(e);\n        onEnable && onEnable(self);\n      }\n\n      return self;\n    };\n\n    self.disable = function () {\n      if (self.isEnabled) {\n        // only remove the _onScroll listener if there aren't any others that rely on the functionality.\n        _observers.filter(function (o) {\n          return o !== self && _isViewport(o.target);\n        }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n\n        if (self.isPressed) {\n          self._vx.reset();\n\n          self._vy.reset();\n\n          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n        }\n\n        _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n\n        _removeListener(target, \"wheel\", _onWheel, capture);\n\n        _removeListener(target, _eventTypes[0], _onPress, capture);\n\n        _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n\n        _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n\n        _removeListener(target, \"click\", clickCapture, true);\n\n        _removeListener(target, \"click\", _onClick);\n\n        _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n\n        _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n\n        _removeListener(target, _pointerType + \"enter\", _onHover);\n\n        _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n\n        _removeListener(target, _pointerType + \"move\", _onMove);\n\n        self.isEnabled = self.isPressed = self.isDragging = false;\n        onDisable && onDisable(self);\n      }\n    };\n\n    self.kill = self.revert = function () {\n      self.disable();\n\n      var i = _observers.indexOf(self);\n\n      i >= 0 && _observers.splice(i, 1);\n      _normalizer === self && (_normalizer = 0);\n    };\n\n    _observers.push(self);\n\n    isNormalizer && _isViewport(target) && (_normalizer = self);\n    self.enable(event);\n  };\n\n  _createClass(Observer, [{\n    key: \"velocityX\",\n    get: function get() {\n      return this._vx.getVelocity();\n    }\n  }, {\n    key: \"velocityY\",\n    get: function get() {\n      return this._vy.getVelocity();\n    }\n  }]);\n\n  return Observer;\n}();\nObserver.version = \"3.13.0\";\n\nObserver.create = function (vars) {\n  return new Observer(vars);\n};\n\nObserver.register = _initCore;\n\nObserver.getAll = function () {\n  return _observers.slice();\n};\n\nObserver.getById = function (id) {\n  return _observers.filter(function (o) {\n    return o.vars.id === id;\n  })[0];\n};\n\n_getGSAP() && gsap.registerPlugin(Observer);\nexport { Observer as default, _isViewport, _scrollers, _getScrollFunc, _getProxyProp, _proxies, _getVelocityProp, _vertical, _horizontal, _getTarget };","/*!\n * ScrollTrigger 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nimport { Observer, _getTarget, _vertical, _horizontal, _scrollers, _proxies, _getScrollFunc, _getProxyProp, _getVelocityProp } from \"./Observer.js\";\n\nvar gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _root,\n    _resizeDelay,\n    _toArray,\n    _clamp,\n    _time2,\n    _syncInterval,\n    _refreshing,\n    _pointerIsDown,\n    _transformProp,\n    _i,\n    _prevWidth,\n    _prevHeight,\n    _autoRefresh,\n    _sort,\n    _suppressOverwrites,\n    _ignoreResize,\n    _normalizer,\n    _ignoreMobileResize,\n    _baseScreenHeight,\n    _baseScreenWidth,\n    _fixIOSBug,\n    _context,\n    _scrollRestoration,\n    _div100vh,\n    _100vh,\n    _isReverted,\n    _clampingMax,\n    _limitCallbacks,\n    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1,\n    _getTime = Date.now,\n    _time1 = _getTime(),\n    _lastScrollTime = 0,\n    _enabled = 0,\n    _parseClamp = function _parseClamp(value, type, self) {\n  var clamp = _isString(value) && (value.substr(0, 6) === \"clamp(\" || value.indexOf(\"max\") > -1);\n  self[\"_\" + type + \"Clamp\"] = clamp;\n  return clamp ? value.substr(6, value.length - 7) : value;\n},\n    _keepClamp = function _keepClamp(value, clamp) {\n  return clamp && (!_isString(value) || value.substr(0, 6) !== \"clamp(\") ? \"clamp(\" + value + \")\" : value;\n},\n    _rafBugFix = function _rafBugFix() {\n  return _enabled && requestAnimationFrame(_rafBugFix);\n},\n    // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.\n_pointerDownHandler = function _pointerDownHandler() {\n  return _pointerIsDown = 1;\n},\n    _pointerUpHandler = function _pointerUpHandler() {\n  return _pointerIsDown = 0;\n},\n    _passThrough = function _passThrough(v) {\n  return v;\n},\n    _round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isViewport = function _isViewport(e) {\n  return !!~_root.indexOf(e);\n},\n    _getViewportDimension = function _getViewportDimension(dimensionProperty) {\n  return (dimensionProperty === \"Height\" ? _100vh : _win[\"inner\" + dimensionProperty]) || _docEl[\"client\" + dimensionProperty] || _body[\"client\" + dimensionProperty];\n},\n    _getBoundsFunc = function _getBoundsFunc(element) {\n  return _getProxyProp(element, \"getBoundingClientRect\") || (_isViewport(element) ? function () {\n    _winOffsets.width = _win.innerWidth;\n    _winOffsets.height = _100vh;\n    return _winOffsets;\n  } : function () {\n    return _getBounds(element);\n  });\n},\n    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {\n  var d = _ref.d,\n      d2 = _ref.d2,\n      a = _ref.a;\n  return (a = _getProxyProp(scroller, \"getBoundingClientRect\")) ? function () {\n    return a()[d];\n  } : function () {\n    return (isViewport ? _getViewportDimension(d2) : scroller[\"client\" + d2]) || 0;\n  };\n},\n    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n  return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {\n    return _winOffsets;\n  };\n},\n    _maxScroll = function _maxScroll(element, _ref2) {\n  var s = _ref2.s,\n      d2 = _ref2.d2,\n      d = _ref2.d,\n      a = _ref2.a;\n  return Math.max(0, (s = \"scroll\" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - _getViewportDimension(d2) : element[s] - element[\"offset\" + d2]);\n},\n    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n  for (var i = 0; i < _autoRefresh.length; i += 3) {\n    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n  }\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _endAnimation = function _endAnimation(animation, reversed, pause) {\n  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\n},\n    _callback = function _callback(self, func) {\n  if (self.enabled) {\n    var result = self._ctx ? self._ctx.add(function () {\n      return func(self);\n    }) : func(self);\n    result && result.totalTime && (self.callbackAnimation = result);\n  }\n},\n    _abs = Math.abs,\n    _left = \"left\",\n    _top = \"top\",\n    _right = \"right\",\n    _bottom = \"bottom\",\n    _width = \"width\",\n    _height = \"height\",\n    _Right = \"Right\",\n    _Left = \"Left\",\n    _Top = \"Top\",\n    _Bottom = \"Bottom\",\n    _padding = \"padding\",\n    _margin = \"margin\",\n    _Width = \"Width\",\n    _Height = \"Height\",\n    _px = \"px\",\n    _getComputedStyle = function _getComputedStyle(element) {\n  return _win.getComputedStyle(element);\n},\n    _makePositionable = function _makePositionable(element) {\n  // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\n  var position = _getComputedStyle(element).position;\n\n  element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    _getBounds = function _getBounds(element, withoutTransforms) {\n  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n    x: 0,\n    y: 0,\n    xPercent: 0,\n    yPercent: 0,\n    rotation: 0,\n    rotationX: 0,\n    rotationY: 0,\n    scale: 1,\n    skewX: 0,\n    skewY: 0\n  }).progress(1),\n      bounds = element.getBoundingClientRect();\n  tween && tween.progress(0).kill();\n  return bounds;\n},\n    _getSize = function _getSize(element, _ref3) {\n  var d2 = _ref3.d2;\n  return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\n},\n    _getLabelRatioArray = function _getLabelRatioArray(timeline) {\n  var a = [],\n      labels = timeline.labels,\n      duration = timeline.duration(),\n      p;\n\n  for (p in labels) {\n    a.push(labels[p] / duration);\n  }\n\n  return a;\n},\n    _getClosestLabel = function _getClosestLabel(animation) {\n  return function (value) {\n    return gsap.utils.snap(_getLabelRatioArray(animation), value);\n  };\n},\n    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {\n  var snap = gsap.utils.snap(snapIncrementOrArray),\n      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {\n    return a - b;\n  });\n  return a ? function (value, direction, threshold) {\n    if (threshold === void 0) {\n      threshold = 1e-3;\n    }\n\n    var i;\n\n    if (!direction) {\n      return snap(value);\n    }\n\n    if (direction > 0) {\n      value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\n\n      for (i = 0; i < a.length; i++) {\n        if (a[i] >= value) {\n          return a[i];\n        }\n      }\n\n      return a[i - 1];\n    } else {\n      i = a.length;\n      value += threshold;\n\n      while (i--) {\n        if (a[i] <= value) {\n          return a[i];\n        }\n      }\n    }\n\n    return a[0];\n  } : function (value, direction, threshold) {\n    if (threshold === void 0) {\n      threshold = 1e-3;\n    }\n\n    var snapped = snap(value);\n    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\n  };\n},\n    _getLabelAtDirection = function _getLabelAtDirection(timeline) {\n  return function (value, st) {\n    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\n  };\n},\n    _multiListener = function _multiListener(func, element, types, callback) {\n  return types.split(\",\").forEach(function (type) {\n    return func(element, type, callback);\n  });\n},\n    _addListener = function _addListener(element, type, func, nonPassive, capture) {\n  return element.addEventListener(type, func, {\n    passive: !nonPassive,\n    capture: !!capture\n  });\n},\n    _removeListener = function _removeListener(element, type, func, capture) {\n  return element.removeEventListener(type, func, !!capture);\n},\n    _wheelListener = function _wheelListener(func, el, scrollFunc) {\n  scrollFunc = scrollFunc && scrollFunc.wheelHandler;\n\n  if (scrollFunc) {\n    func(el, \"wheel\", scrollFunc);\n    func(el, \"touchmove\", scrollFunc);\n  }\n},\n    _markerDefaults = {\n  startColor: \"green\",\n  endColor: \"red\",\n  indent: 0,\n  fontSize: \"16px\",\n  fontWeight: \"normal\"\n},\n    _defaults = {\n  toggleActions: \"play\",\n  anticipatePin: 0\n},\n    _keywords = {\n  top: 0,\n  left: 0,\n  center: 0.5,\n  bottom: 1,\n  right: 1\n},\n    _offsetToPx = function _offsetToPx(value, size) {\n  if (_isString(value)) {\n    var eqIndex = value.indexOf(\"=\"),\n        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n\n    if (~eqIndex) {\n      value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n      value = value.substr(0, eqIndex - 1);\n    }\n\n    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n  }\n\n  return value;\n},\n    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\n  var startColor = _ref4.startColor,\n      endColor = _ref4.endColor,\n      fontSize = _ref4.fontSize,\n      indent = _ref4.indent,\n      fontWeight = _ref4.fontWeight;\n\n  var e = _doc.createElement(\"div\"),\n      useFixedPosition = _isViewport(container) || _getProxyProp(container, \"pinType\") === \"fixed\",\n      isScroller = type.indexOf(\"scroller\") !== -1,\n      parent = useFixedPosition ? _body : container,\n      isStart = type.indexOf(\"start\") !== -1,\n      color = isStart ? startColor : endColor,\n      css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n\n  css += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n  (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n  matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n  e._isStart = isStart;\n  e.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\n  e.style.cssText = css;\n  e.innerText = name || name === 0 ? type + \"-\" + name : type;\n  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n  e._offset = e[\"offset\" + direction.op.d2];\n\n  _positionMarker(e, 0, direction, isStart);\n\n  return e;\n},\n    _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n  var vars = {\n    display: \"block\"\n  },\n      side = direction[flipped ? \"os2\" : \"p2\"],\n      oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n  marker._isFlipped = flipped;\n  vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n  vars[direction.a] = flipped ? \"1px\" : 0;\n  vars[\"border\" + side + _Width] = 1;\n  vars[\"border\" + oppositeSide + _Width] = 0;\n  vars[direction.p] = start + \"px\";\n  gsap.set(marker, vars);\n},\n    _triggers = [],\n    _ids = {},\n    _rafID,\n    _sync = function _sync() {\n  return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));\n},\n    _onScroll = function _onScroll() {\n  // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010\n  if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\n    // if the user is dragging the scrollbar, allow it.\n    _scrollers.cache++;\n\n    if (_normalizer) {\n      _rafID || (_rafID = requestAnimationFrame(_updateAll));\n    } else {\n      _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110\n\n    }\n\n    _lastScrollTime || _dispatch(\"scrollStart\");\n    _lastScrollTime = _getTime();\n  }\n},\n    _setBaseDimensions = function _setBaseDimensions() {\n  _baseScreenWidth = _win.innerWidth;\n  _baseScreenHeight = _win.innerHeight;\n},\n    _onResize = function _onResize(force) {\n  _scrollers.cache++;\n  (force === true || !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25)) && _resizeDelay.restart(true);\n},\n    // ignore resizes triggered by refresh()\n_listeners = {},\n    _emptyArray = [],\n    _softRefresh = function _softRefresh() {\n  return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\n},\n    _dispatch = function _dispatch(type) {\n  return _listeners[type] && _listeners[type].map(function (f) {\n    return f();\n  }) || _emptyArray;\n},\n    _savedStyles = [],\n    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n  for (var i = 0; i < _savedStyles.length; i += 5) {\n    if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {\n      _savedStyles[i].style.cssText = _savedStyles[i + 1];\n      _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i + 2] || \"\");\n      _savedStyles[i + 3].uncache = 1;\n    }\n  }\n},\n    _revertAll = function _revertAll(kill, media) {\n  var trigger;\n\n  for (_i = 0; _i < _triggers.length; _i++) {\n    trigger = _triggers[_i];\n\n    if (trigger && (!media || trigger._ctx === media)) {\n      if (kill) {\n        trigger.kill(1);\n      } else {\n        trigger.revert(true, true);\n      }\n    }\n  }\n\n  _isReverted = true;\n  media && _revertRecorded(media);\n  media || _dispatch(\"revert\");\n},\n    _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {\n  // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\n  _scrollers.cache++;\n  (force || !_refreshingAll) && _scrollers.forEach(function (obj) {\n    return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);\n  });\n  _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);\n},\n    _refreshingAll,\n    _refreshID = 0,\n    _queueRefreshID,\n    _queueRefreshAll = function _queueRefreshAll() {\n  // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's \"load\" or \"DOMContentLoaded\" events to trigger it.\n  if (_queueRefreshID !== _refreshID) {\n    var id = _queueRefreshID = _refreshID;\n    requestAnimationFrame(function () {\n      return id === _refreshID && _refreshAll(true);\n    });\n  }\n},\n    _refresh100vh = function _refresh100vh() {\n  _body.appendChild(_div100vh);\n\n  _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;\n\n  _body.removeChild(_div100vh);\n},\n    _hideAllMarkers = function _hideAllMarkers(hide) {\n  return _toArray(\".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end\").forEach(function (el) {\n    return el.style.display = hide ? \"none\" : \"block\";\n  });\n},\n    _refreshAll = function _refreshAll(force, skipRevert) {\n  _docEl = _doc.documentElement; // some frameworks like Astro may cache the <body> and replace it during routing, so we'll just re-record the _docEl and _body for safety (otherwise, the markers may not get added properly).\n\n  _body = _doc.body;\n  _root = [_win, _doc, _docEl, _body];\n\n  if (_lastScrollTime && !force && !_isReverted) {\n    _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\n    return;\n  }\n\n  _refresh100vh();\n\n  _refreshingAll = ScrollTrigger.isRefreshing = true;\n\n  _scrollers.forEach(function (obj) {\n    return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj());\n  }); // force the clearing of the cache because some browsers take a little while to dispatch the \"scroll\" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away\n\n\n  var refreshInits = _dispatch(\"refreshInit\");\n\n  _sort && ScrollTrigger.sort();\n  skipRevert || _revertAll();\n\n  _scrollers.forEach(function (obj) {\n    if (_isFunction(obj)) {\n      obj.smooth && (obj.target.style.scrollBehavior = \"auto\"); // smooth scrolling interferes\n\n      obj(0);\n    }\n  });\n\n  _triggers.slice(0).forEach(function (t) {\n    return t.refresh();\n  }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\n\n\n  _isReverted = false;\n\n  _triggers.forEach(function (t) {\n    // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.\n    if (t._subPinOffset && t.pin) {\n      var prop = t.vars.horizontal ? \"offsetWidth\" : \"offsetHeight\",\n          original = t.pin[prop];\n      t.revert(true, 1);\n      t.adjustPinSpacing(t.pin[prop] - original);\n      t.refresh();\n    }\n  });\n\n  _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.\n\n  _hideAllMarkers(true);\n\n  _triggers.forEach(function (t) {\n    // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: \"max\". Same for anything with a clamped end\n    var max = _maxScroll(t.scroller, t._dir),\n        endClamp = t.vars.end === \"max\" || t._endClamp && t.end > max,\n        startClamp = t._startClamp && t.start >= max;\n\n    (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);\n  });\n\n  _hideAllMarkers(false);\n\n  _clampingMax = 0;\n  refreshInits.forEach(function (result) {\n    return result && result.render && result.render(-1);\n  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n\n  _scrollers.forEach(function (obj) {\n    if (_isFunction(obj)) {\n      obj.smooth && requestAnimationFrame(function () {\n        return obj.target.style.scrollBehavior = \"smooth\";\n      });\n      obj.rec && obj(obj.rec);\n    }\n  });\n\n  _clearScrollMemory(_scrollRestoration, 1);\n\n  _resizeDelay.pause();\n\n  _refreshID++;\n  _refreshingAll = 2;\n\n  _updateAll(2);\n\n  _triggers.forEach(function (t) {\n    return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);\n  });\n\n  _refreshingAll = ScrollTrigger.isRefreshing = false;\n\n  _dispatch(\"refresh\");\n},\n    _lastScroll = 0,\n    _direction = 1,\n    _primary,\n    _updateAll = function _updateAll(force) {\n  if (force === 2 || !_refreshingAll && !_isReverted) {\n    // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.\n    ScrollTrigger.isUpdating = true;\n    _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.\n\n    var l = _triggers.length,\n        time = _getTime(),\n        recordVelocity = time - _time1 >= 50,\n        scroll = l && _triggers[0].scroll();\n\n    _direction = _lastScroll > scroll ? -1 : 1;\n    _refreshingAll || (_lastScroll = scroll);\n\n    if (recordVelocity) {\n      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n        _lastScrollTime = 0;\n\n        _dispatch(\"scrollEnd\");\n      }\n\n      _time2 = _time1;\n      _time1 = time;\n    }\n\n    if (_direction < 0) {\n      _i = l;\n\n      while (_i-- > 0) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n\n      _direction = 1;\n    } else {\n      for (_i = 0; _i < l; _i++) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n    }\n\n    ScrollTrigger.isUpdating = false;\n  }\n\n  _rafID = 0;\n},\n    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, \"display\", \"flexShrink\", \"float\", \"zIndex\", \"gridColumnStart\", \"gridColumnEnd\", \"gridRowStart\", \"gridRowEnd\", \"gridArea\", \"justifySelf\", \"alignSelf\", \"placeSelf\", \"order\"],\n    _stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\" + _Width, \"max\" + _Height, \"position\", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\n    _swapPinOut = function _swapPinOut(pin, spacer, state) {\n  _setState(state);\n\n  var cache = pin._gsap;\n\n  if (cache.spacerIsNative) {\n    _setState(cache.spacerState);\n  } else if (pin._gsap.swappedIn) {\n    var parent = spacer.parentNode;\n\n    if (parent) {\n      parent.insertBefore(pin, spacer);\n      parent.removeChild(spacer);\n    }\n  }\n\n  pin._gsap.swappedIn = false;\n},\n    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n  if (!pin._gsap.swappedIn) {\n    var i = _propNamesToCopy.length,\n        spacerStyle = spacer.style,\n        pinStyle = pin.style,\n        p;\n\n    while (i--) {\n      p = _propNamesToCopy[i];\n      spacerStyle[p] = cs[p];\n    }\n\n    spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n    cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n    pinStyle[_bottom] = pinStyle[_right] = \"auto\";\n    spacerStyle.flexBasis = cs.flexBasis || \"auto\";\n    spacerStyle.overflow = \"visible\";\n    spacerStyle.boxSizing = \"border-box\";\n    spacerStyle[_width] = _getSize(pin, _horizontal) + _px;\n    spacerStyle[_height] = _getSize(pin, _vertical) + _px;\n    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n\n    _setState(spacerState);\n\n    pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n    pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n    pinStyle[_padding] = cs[_padding];\n\n    if (pin.parentNode !== spacer) {\n      pin.parentNode.insertBefore(spacer, pin);\n      spacer.appendChild(pin);\n    }\n\n    pin._gsap.swappedIn = true;\n  }\n},\n    _capsExp = /([A-Z])/g,\n    _setState = function _setState(state) {\n  if (state) {\n    var style = state.t.style,\n        l = state.length,\n        i = 0,\n        p,\n        value;\n    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n\n    for (; i < l; i += 2) {\n      value = state[i + 1];\n      p = state[i];\n\n      if (value) {\n        style[p] = value;\n      } else if (style[p]) {\n        style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n      }\n    }\n  }\n},\n    _getState = function _getState(element) {\n  // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n  var l = _stateProps.length,\n      style = element.style,\n      state = [],\n      i = 0;\n\n  for (; i < l; i++) {\n    state.push(_stateProps[i], style[_stateProps[i]]);\n  }\n\n  state.t = element;\n  return state;\n},\n    _copyState = function _copyState(state, override, omitOffsets) {\n  var result = [],\n      l = state.length,\n      i = omitOffsets ? 8 : 0,\n      // skip top, left, right, bottom if omitOffsets is true\n  p;\n\n  for (; i < l; i += 2) {\n    p = state[i];\n    result.push(p, p in override ? override[p] : state[i + 1]);\n  }\n\n  result.t = state.t;\n  return result;\n},\n    _winOffsets = {\n  left: 0,\n  top: 0\n},\n    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\n// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\n// \tscroller = _getTarget(scroller || _win);\n// \tlet direction = horizontal ? _horizontal : _vertical,\n// \t\tisViewport = _isViewport(scroller);\n// \t_getSizeFunc(scroller, isViewport, direction);\n// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\n// },\n_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {\n  _isFunction(value) && (value = value(self));\n\n  if (_isString(value) && value.substr(0, 3) === \"max\") {\n    value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n  }\n\n  var time = containerAnimation ? containerAnimation.time() : 0,\n      p1,\n      p2,\n      element;\n  containerAnimation && containerAnimation.seek(0);\n  isNaN(value) || (value = +value); // convert a string number like \"45\" to an actual number\n\n  if (!_isNumber(value)) {\n    _isFunction(trigger) && (trigger = trigger(self));\n    var offsets = (value || \"0\").split(\" \"),\n        bounds,\n        localOffset,\n        globalOffset,\n        display;\n    element = _getTarget(trigger, self) || _body;\n    bounds = _getBounds(element) || {};\n\n    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n      // if display is \"none\", it won't report getBoundingClientRect() properly\n      display = element.style.display;\n      element.style.display = \"block\";\n      bounds = _getBounds(element);\n      display ? element.style.display = display : element.style.removeProperty(\"display\");\n    }\n\n    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n    globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n  } else {\n    containerAnimation && (value = gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));\n    markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);\n  }\n\n  if (clampZeroProp) {\n    self[clampZeroProp] = value || -0.001;\n    value < 0 && (value = 0);\n  }\n\n  if (marker) {\n    var position = value + scrollerSize,\n        isStart = marker._isStart;\n    p1 = \"scroll\" + direction.d2;\n\n    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);\n\n    if (useFixedPosition) {\n      scrollerBounds = _getBounds(markerScroller);\n      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n    }\n  }\n\n  if (containerAnimation && element) {\n    p1 = _getBounds(element);\n    containerAnimation.seek(scrollerMax);\n    p2 = _getBounds(element);\n    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n    value = value / containerAnimation._caScrollDist * scrollerMax;\n  }\n\n  containerAnimation && containerAnimation.seek(time);\n  return containerAnimation ? value : Math.round(value);\n},\n    _prefixExp = /(webkit|moz|length|cssText|inset)/i,\n    _reparent = function _reparent(element, parent, top, left) {\n  if (element.parentNode !== parent) {\n    var style = element.style,\n        p,\n        cs;\n\n    if (parent === _body) {\n      element._stOrig = style.cssText; // record original inline styles so we can revert them later\n\n      cs = _getComputedStyle(element);\n\n      for (p in cs) {\n        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n          style[p] = cs[p];\n        }\n      }\n\n      style.top = top;\n      style.left = left;\n    } else {\n      style.cssText = element._stOrig;\n    }\n\n    gsap.core.getCache(element).uncache = 1;\n    parent.appendChild(element);\n  }\n},\n    _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {\n  var last1 = initialValue,\n      last2 = last1;\n  return function (value) {\n    var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.\n\n    if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {\n      // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\n      value = current;\n      onInterrupt && onInterrupt();\n    }\n\n    last2 = last1;\n    last1 = Math.round(value);\n    return last1;\n  };\n},\n    _shiftMarker = function _shiftMarker(marker, direction, value) {\n  var vars = {};\n  vars[direction.p] = \"+=\" + value;\n  gsap.set(marker, vars);\n},\n    // _mergeAnimations = animations => {\n// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\n// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\n// \ttl.smoothChildTiming = false;\n// \treturn tl;\n// },\n// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n  var getScroll = _getScrollFunc(scroller, direction),\n      prop = \"_scroll\" + direction.p2,\n      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n  getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n    var tween = getTween.tween,\n        onComplete = vars.onComplete,\n        modifiers = {};\n    initialValue = initialValue || getScroll();\n\n    var checkForInterruption = _interruptionTracker(getScroll, initialValue, function () {\n      tween.kill();\n      getTween.tween = 0;\n    });\n\n    change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.\n\n    change1 = change1 || scrollTo - initialValue;\n    tween && tween.kill();\n    vars[prop] = scrollTo;\n    vars.inherit = false;\n    vars.modifiers = modifiers;\n\n    modifiers[prop] = function () {\n      return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);\n    };\n\n    vars.onUpdate = function () {\n      _scrollers.cache++;\n      getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()\n    };\n\n    vars.onComplete = function () {\n      getTween.tween = 0;\n      onComplete && onComplete.call(tween);\n    };\n\n    tween = getTween.tween = gsap.to(scroller, vars);\n    return tween;\n  };\n\n  scroller[prop] = getScroll;\n\n  getScroll.wheelHandler = function () {\n    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\n  };\n\n  _addListener(scroller, \"wheel\", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\n\n\n  ScrollTrigger.isTouch && _addListener(scroller, \"touchmove\", getScroll.wheelHandler);\n  return getTween;\n};\n\nexport var ScrollTrigger = /*#__PURE__*/function () {\n  function ScrollTrigger(vars, animation) {\n    _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n\n    _context(this);\n\n    this.init(vars, animation);\n  }\n\n  var _proto = ScrollTrigger.prototype;\n\n  _proto.init = function init(vars, animation) {\n    this.progress = this.start = 0;\n    this.vars && this.kill(true, true); // in case it's being initted again\n\n    if (!_enabled) {\n      this.update = this.refresh = this.kill = _passThrough;\n      return;\n    }\n\n    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n      trigger: vars\n    } : vars, _defaults);\n\n    var _vars = vars,\n        onUpdate = _vars.onUpdate,\n        toggleClass = _vars.toggleClass,\n        id = _vars.id,\n        onToggle = _vars.onToggle,\n        onRefresh = _vars.onRefresh,\n        scrub = _vars.scrub,\n        trigger = _vars.trigger,\n        pin = _vars.pin,\n        pinSpacing = _vars.pinSpacing,\n        invalidateOnRefresh = _vars.invalidateOnRefresh,\n        anticipatePin = _vars.anticipatePin,\n        onScrubComplete = _vars.onScrubComplete,\n        onSnapComplete = _vars.onSnapComplete,\n        once = _vars.once,\n        snap = _vars.snap,\n        pinReparent = _vars.pinReparent,\n        pinSpacer = _vars.pinSpacer,\n        containerAnimation = _vars.containerAnimation,\n        fastScrollEnd = _vars.fastScrollEnd,\n        preventOverlaps = _vars.preventOverlaps,\n        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,\n        isToggle = !scrub && scrub !== 0,\n        scroller = _getTarget(vars.scroller || _win),\n        scrollerCache = gsap.core.getCache(scroller),\n        isViewport = _isViewport(scroller),\n        useFixedPosition = (\"pinType\" in vars ? vars.pinType : _getProxyProp(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\",\n        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n        toggleActions = isToggle && vars.toggleActions.split(\" \"),\n        markers = \"markers\" in vars ? vars.markers : _defaults.markers,\n        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0,\n        self = this,\n        onRefreshInit = vars.onRefreshInit && function () {\n      return vars.onRefreshInit(self);\n    },\n        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),\n        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\n        lastSnap = 0,\n        lastRefresh = 0,\n        prevProgress = 0,\n        scrollFunc = _getScrollFunc(scroller, direction),\n        tweenTo,\n        pinCache,\n        snapFunc,\n        scroll1,\n        scroll2,\n        start,\n        end,\n        markerStart,\n        markerEnd,\n        markerStartTrigger,\n        markerEndTrigger,\n        markerVars,\n        executingOnRefresh,\n        change,\n        pinOriginalState,\n        pinActiveState,\n        pinState,\n        spacer,\n        offset,\n        pinGetter,\n        pinSetter,\n        pinStart,\n        pinChange,\n        spacingStart,\n        spacerState,\n        markerStartSetter,\n        pinMoves,\n        markerEndSetter,\n        cs,\n        snap1,\n        snap2,\n        scrubTween,\n        scrubSmooth,\n        snapDurClamp,\n        snapDelayedCall,\n        prevScroll,\n        prevAnimProgress,\n        caMarkerSetter,\n        customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start=\"clamp(top bottom)\" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.\n\n\n    self._startClamp = self._endClamp = false;\n    self._dir = direction;\n    anticipatePin *= 45;\n    self.scroller = scroller;\n    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n    scroll1 = scrollFunc();\n    self.vars = vars;\n    animation = animation || vars.animation;\n\n    if (\"refreshPriority\" in vars) {\n      _sort = 1;\n      vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother\n    }\n\n    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n      top: _getTweenCreator(scroller, _vertical),\n      left: _getTweenCreator(scroller, _horizontal)\n    };\n    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n\n    self.scrubDuration = function (value) {\n      scrubSmooth = _isNumber(value) && value;\n\n      if (!scrubSmooth) {\n        scrubTween && scrubTween.progress(1).kill();\n        scrubTween = 0;\n      } else {\n        scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\n          ease: \"expo\",\n          totalProgress: \"+=0\",\n          inherit: false,\n          duration: scrubSmooth,\n          paused: true,\n          onComplete: function onComplete() {\n            return onScrubComplete && onScrubComplete(self);\n          }\n        });\n      }\n    };\n\n    if (animation) {\n      animation.vars.lazy = false;\n      animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010\n\n      self.animation = animation.pause();\n      animation.scrollTrigger = self;\n      self.scrubDuration(scrub);\n      snap1 = 0;\n      id || (id = animation.vars.id);\n    }\n\n    if (snap) {\n      // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.\n      if (!_isObject(snap) || snap.push) {\n        snap = {\n          snapTo: snap\n        };\n      }\n\n      \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {\n        scrollBehavior: \"auto\"\n      }); // smooth scrolling doesn't work with snap.\n\n      _scrollers.forEach(function (o) {\n        return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = false);\n      }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters\n\n\n      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {\n        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\n      } : gsap.utils.snap(snap.snapTo);\n      snapDurClamp = snap.duration || {\n        min: 0.1,\n        max: 2\n      };\n      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {\n        var scroll = scrollFunc(),\n            refreshedRecently = _getTime() - lastRefresh < 500,\n            tween = tweenTo.tween;\n\n        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\n          var progress = (scroll - start) / change,\n              totalProgress = animation && !isToggle ? animation.totalProgress() : progress,\n              velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,\n              change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),\n              naturalEnd = progress + (snap.inertia === false ? 0 : change1),\n              endValue,\n              endScroll,\n              _snap = snap,\n              onStart = _snap.onStart,\n              _onInterrupt = _snap.onInterrupt,\n              _onComplete = _snap.onComplete;\n          endValue = snapFunc(naturalEnd, self);\n          _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd\n\n          endScroll = Math.max(0, Math.round(start + endValue * change));\n\n          if (scroll <= end && scroll >= start && endScroll !== scroll) {\n            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\n              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n              return;\n            }\n\n            if (snap.inertia === false) {\n              change1 = endValue - progress;\n            }\n\n            tweenTo(endScroll, {\n              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n              ease: snap.ease || \"power3\",\n              data: _abs(endScroll - scroll),\n              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n              onInterrupt: function onInterrupt() {\n                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\n              },\n              onComplete: function onComplete() {\n                self.update();\n                lastSnap = scrollFunc();\n\n                if (animation && !isToggle) {\n                  // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap\n                  scrubTween ? scrubTween.resetTo(\"totalProgress\", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);\n                }\n\n                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                onSnapComplete && onSnapComplete(self);\n                _onComplete && _onComplete(self);\n              }\n            }, scroll, change1 * change, endScroll - scroll - change1 * change);\n            onStart && onStart(self, tweenTo.tween);\n          }\n        } else if (self.isActive && lastSnap !== scroll) {\n          snapDelayedCall.restart(true);\n        }\n      }).pause();\n    }\n\n    id && (_ids[id] = self);\n    trigger = self.trigger = _getTarget(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the \"y\" or \"x\" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.\n\n    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\n    customRevertReturn && (customRevertReturn = customRevertReturn(self));\n    pin = pin === true ? trigger : _getTarget(pin);\n    _isString(toggleClass) && (toggleClass = {\n      targets: trigger,\n      className: toggleClass\n    });\n\n    if (pin) {\n      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)\n\n      self.pin = pin;\n      pinCache = gsap.core.getCache(pin);\n\n      if (!pinCache.spacer) {\n        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n        if (pinSpacer) {\n          pinSpacer = _getTarget(pinSpacer);\n          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\n\n          pinCache.spacerIsNative = !!pinSpacer;\n          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n        }\n\n        pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n        spacer.classList.add(\"pin-spacer\");\n        id && spacer.classList.add(\"pin-spacer-\" + id);\n        pinCache.pinState = pinOriginalState = _getState(pin);\n      } else {\n        pinOriginalState = pinCache.pinState;\n      }\n\n      vars.force3D !== false && gsap.set(pin, {\n        force3D: true\n      });\n      self.spacer = spacer = pinCache.spacer;\n      cs = _getComputedStyle(pin);\n      spacingStart = cs[pinSpacing + direction.os2];\n      pinGetter = gsap.getProperty(pin);\n      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n\n      _swapPinIn(pin, spacer, cs);\n\n      pinState = _getState(pin);\n    }\n\n    if (markers) {\n      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n      markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n      markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n      offset = markerStartTrigger[\"offset\" + direction.op.d2];\n\n      var content = _getTarget(_getProxyProp(scroller, \"content\") || scroller);\n\n      markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\n      markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\n      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));\n\n      if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, \"fixedMarkers\") === true)) {\n        _makePositionable(isViewport ? _body : scroller);\n\n        gsap.set([markerStartTrigger, markerEndTrigger], {\n          force3D: true\n        });\n        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n      }\n    }\n\n    if (containerAnimation) {\n      var oldOnUpdate = containerAnimation.vars.onUpdate,\n          oldParams = containerAnimation.vars.onUpdateParams;\n      containerAnimation.eventCallback(\"onUpdate\", function () {\n        self.update(0, 0, 1);\n        oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);\n      });\n    }\n\n    self.previous = function () {\n      return _triggers[_triggers.indexOf(self) - 1];\n    };\n\n    self.next = function () {\n      return _triggers[_triggers.indexOf(self) + 1];\n    };\n\n    self.revert = function (revert, temp) {\n      if (!temp) {\n        return self.kill(true);\n      } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()\n\n\n      var r = revert !== false || !self.enabled,\n          prevRefreshing = _refreshing;\n\n      if (r !== self.isReverted) {\n        if (r) {\n          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n\n          prevProgress = self.progress;\n          prevAnimProgress = animation && animation.progress();\n        }\n\n        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n          return m.style.display = r ? \"none\" : \"block\";\n        });\n\n        if (r) {\n          _refreshing = self;\n          self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out\n        }\n\n        if (pin && (!pinReparent || !self.isActive)) {\n          if (r) {\n            _swapPinOut(pin, spacer, pinOriginalState);\n          } else {\n            _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);\n          }\n        }\n\n        r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.\n\n        _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.\n\n        self.isReverted = r;\n      }\n    };\n\n    self.refresh = function (soft, force, position, pinOffset) {\n      // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects\n      if ((_refreshing || !self.enabled) && !force) {\n        return;\n      }\n\n      if (pin && soft && _lastScrollTime) {\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\n        return;\n      }\n\n      !_refreshingAll && onRefreshInit && onRefreshInit(self);\n      _refreshing = self;\n\n      if (tweenTo.tween && !position) {\n        // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.\n        tweenTo.tween.kill();\n        tweenTo.tween = 0;\n      }\n\n      scrubTween && scrubTween.pause();\n\n      if (invalidateOnRefresh && animation) {\n        animation.revert({\n          kill: false\n        }).invalidate();\n        animation.getChildren && animation.getChildren(true, true, false).forEach(function (t) {\n          return t.vars.immediateRender && t.render(0, true, true);\n        }); // any from() or fromTo() tweens inside a timeline should render immediately (well, unless they have immediateRender: false)\n      }\n\n      self.isReverted || self.revert(true, true);\n      self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any\n\n      var size = getScrollerSize(),\n          scrollerBounds = getScrollerOffsets(),\n          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),\n          isFirstRefresh = change <= 0.01 || !change,\n          offset = 0,\n          otherPinOffset = pinOffset || 0,\n          parsedEnd = _isObject(position) ? position.end : vars.end,\n          parsedEndTrigger = vars.endTrigger || trigger,\n          parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"),\n          pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self),\n          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,\n          i = triggerIndex,\n          cs,\n          bounds,\n          scroll,\n          isVertical,\n          override,\n          curTrigger,\n          curPin,\n          oppositeScroll,\n          initted,\n          revertedPins,\n          forcedOverflow,\n          markerStartOffset,\n          markerEndOffset;\n\n      if (markers && _isObject(position)) {\n        // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.\n        markerStartOffset = gsap.getProperty(markerStartTrigger, direction.p);\n        markerEndOffset = gsap.getProperty(markerEndTrigger, direction.p);\n      }\n\n      while (i-- > 0) {\n        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n        curTrigger = _triggers[i];\n        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\n\n        curPin = curTrigger.pin;\n\n        if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {\n          revertedPins || (revertedPins = []);\n          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\n\n          curTrigger.revert(true, true);\n        }\n\n        if (curTrigger !== _triggers[i]) {\n          // in case it got removed.\n          triggerIndex--;\n          i--;\n        }\n      }\n\n      _isFunction(parsedStart) && (parsedStart = parsedStart(self));\n      parsedStart = _parseClamp(parsedStart, \"start\", self);\n      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && \"_startClamp\") || (pin ? -0.001 : 0);\n      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n\n      if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n        if (~parsedEnd.indexOf(\" \")) {\n          parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n        } else {\n          offset = _offsetToPx(parsedEnd.substr(2), size);\n          parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n\n          parsedEndTrigger = trigger;\n        }\n      }\n\n      parsedEnd = _parseClamp(parsedEnd, \"end\", self);\n      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && \"_endClamp\")) || -0.001;\n      offset = 0;\n      i = triggerIndex;\n\n      while (i--) {\n        curTrigger = _triggers[i];\n        curPin = curTrigger.pin;\n\n        if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {\n          cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);\n\n          if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {\n            // numeric start values shouldn't be offset at all - treat them as absolute\n            offset += cs * (1 - curTrigger.progress);\n          }\n\n          curPin === pin && (otherPinOffset += cs);\n        }\n      }\n\n      start += offset;\n      end += offset;\n      self._startClamp && (self._startClamp += offset);\n\n      if (self._endClamp && !_refreshingAll) {\n        self._endClamp = end || -0.001;\n        end = Math.min(end, _maxScroll(scroller, direction));\n      }\n\n      change = end - start || (start -= 0.01) && 0.001;\n\n      if (isFirstRefresh) {\n        // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.\n        prevProgress = gsap.utils.clamp(0, 1, gsap.utils.normalize(start, end, prevScroll));\n      }\n\n      self._pinPush = otherPinOffset;\n\n      if (markerStart && offset) {\n        // offset the markers if necessary\n        cs = {};\n        cs[direction.a] = \"+=\" + offset;\n        pinnedContainer && (cs[direction.p] = \"-=\" + scrollFunc());\n        gsap.set([markerStart, markerEnd], cs);\n      }\n\n      if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {\n        cs = _getComputedStyle(pin);\n        isVertical = direction === _vertical;\n        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll\n\n        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n\n        if (!max && end > 1) {\n          // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n          forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;\n          forcedOverflow = {\n            style: forcedOverflow,\n            value: forcedOverflow[\"overflow\" + direction.a.toUpperCase()]\n          };\n\n          if (isViewport && _getComputedStyle(_body)[\"overflow\" + direction.a.toUpperCase()] !== \"scroll\") {\n            // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to \"scroll\"\n            forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = \"scroll\";\n          }\n        }\n\n        _swapPinIn(pin, spacer, cs);\n\n        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n\n        bounds = _getBounds(pin, true);\n        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();\n\n        if (pinSpacing) {\n          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];\n          spacerState.t = spacer;\n          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n\n          if (i) {\n            spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n\n            spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n          }\n\n          _setState(spacerState);\n\n          if (pinnedContainer) {\n            // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.\n            _triggers.forEach(function (t) {\n              if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {\n                t._subPinOffset = true;\n              }\n            });\n          }\n\n          useFixedPosition && scrollFunc(prevScroll);\n        } else {\n          i = _getSize(pin, direction);\n          i && spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n        }\n\n        if (useFixedPosition) {\n          override = {\n            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n            boxSizing: \"border-box\",\n            position: \"fixed\"\n          };\n          override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n          override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n          override[_padding] = cs[_padding];\n          override[_padding + _Top] = cs[_padding + _Top];\n          override[_padding + _Right] = cs[_padding + _Right];\n          override[_padding + _Bottom] = cs[_padding + _Bottom];\n          override[_padding + _Left] = cs[_padding + _Left];\n          pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n          _refreshingAll && scrollFunc(0);\n        }\n\n        if (animation) {\n          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n\n          _suppressOverwrites(1);\n\n          animation.render(animation.duration(), true, true);\n          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n          pinMoves = Math.abs(change - pinChange) > 1;\n          useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n\n          animation.render(0, true, true);\n          initted || animation.invalidate(true);\n          animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.\n\n          _suppressOverwrites(0);\n        } else {\n          pinChange = change;\n        }\n\n        forcedOverflow && (forcedOverflow.value ? forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty(\"overflow-\" + direction.a));\n      } else if (trigger && scrollFunc() && !containerAnimation) {\n        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n        bounds = trigger.parentNode;\n\n        while (bounds && bounds !== _body) {\n          if (bounds._pinOffset) {\n            start -= bounds._pinOffset;\n            end -= bounds._pinOffset;\n          }\n\n          bounds = bounds.parentNode;\n        }\n      }\n\n      revertedPins && revertedPins.forEach(function (t) {\n        return t.revert(false, true);\n      });\n      self.start = start;\n      self.end = end;\n      scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity\n\n      if (!containerAnimation && !_refreshingAll) {\n        scroll1 < prevScroll && scrollFunc(prevScroll);\n        self.scroll.rec = 0;\n      }\n\n      self.revert(false, true);\n      lastRefresh = _getTime();\n\n      if (snapDelayedCall) {\n        lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value\n        // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.\n\n        snapDelayedCall.restart(true);\n      }\n\n      _refreshing = 0;\n      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n\n      if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh || animation && !animation._initted) {\n        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n        animation && !isToggle && (animation._initted || prevProgress || animation.vars.immediateRender !== false) && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n\n        self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;\n      }\n\n      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n      scrubTween && scrubTween.invalidate();\n\n      if (!isNaN(markerStartOffset)) {\n        // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like \"top\", \"center\", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.\n        markerStartOffset -= gsap.getProperty(markerStartTrigger, direction.p);\n        markerEndOffset -= gsap.getProperty(markerEndTrigger, direction.p);\n\n        _shiftMarker(markerStartTrigger, direction, markerStartOffset);\n\n        _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));\n\n        _shiftMarker(markerEndTrigger, direction, markerEndOffset);\n\n        _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));\n      }\n\n      isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a \"scroll\" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.\n\n      if (onRefresh && !_refreshingAll && !executingOnRefresh) {\n        // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.\n        executingOnRefresh = true;\n        onRefresh(self);\n        executingOnRefresh = false;\n      }\n    };\n\n    self.getVelocity = function () {\n      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n    };\n\n    self.endAnimation = function () {\n      _endAnimation(self.callbackAnimation);\n\n      if (animation) {\n        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\n      }\n    };\n\n    self.labelToScroll = function (label) {\n      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;\n    };\n\n    self.getTrailing = function (name) {\n      var i = _triggers.indexOf(self),\n          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);\n\n      return (_isString(name) ? a.filter(function (t) {\n        return t.vars.preventOverlaps === name;\n      }) : a).filter(function (t) {\n        return self.direction > 0 ? t.end <= start : t.start >= end;\n      });\n    };\n\n    self.update = function (reset, recordVelocity, forceFake) {\n      if (containerAnimation && !forceFake && !reset) {\n        return;\n      }\n\n      var scroll = _refreshingAll === true ? prevScroll : self.scroll(),\n          p = reset ? 0 : (scroll - start) / change,\n          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n          prevProgress = self.progress,\n          isActive,\n          wasActive,\n          toggleState,\n          action,\n          stateChanged,\n          toggled,\n          isAtMax,\n          isTakingAction;\n\n      if (recordVelocity) {\n        scroll2 = scroll1;\n        scroll1 = containerAnimation ? scrollFunc() : scroll;\n\n        if (snap) {\n          snap2 = snap1;\n          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n        }\n      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n\n\n      if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {\n        if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n          clipped = 0.0001;\n        } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n          clipped = 0.9999;\n        }\n      }\n\n      if (clipped !== prevProgress && self.enabled) {\n        isActive = self.isActive = !!clipped && clipped < 1;\n        wasActive = !!prevProgress && prevProgress < 1;\n        toggled = isActive !== wasActive;\n        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n\n        self.direction = clipped > prevProgress ? 1 : -1;\n        self.progress = clipped;\n\n        if (stateChanged && !_refreshing) {\n          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n\n          if (isToggle) {\n            action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n\n            isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n          }\n        }\n\n        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {\n          return t.endAnimation();\n        }));\n\n        if (!isToggle) {\n          if (scrubTween && !_refreshing && !_startup) {\n            scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.\n\n            if (scrubTween.resetTo) {\n              scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\n            } else {\n              // legacy support (courtesy), before 3.10.0\n              scrubTween.vars.totalProgress = clipped;\n              scrubTween.invalidate().restart();\n            }\n          } else if (animation) {\n            animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));\n          }\n        }\n\n        if (pin) {\n          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n\n          if (!useFixedPosition) {\n            pinSetter(_round(pinStart + pinChange * clipped));\n          } else if (stateChanged) {\n            isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n\n            if (pinReparent) {\n              if (!reset && (isActive || isAtMax)) {\n                var bounds = _getBounds(pin, true),\n                    _offset = scroll - start;\n\n                _reparent(pin, _body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);\n              } else {\n                _reparent(pin, spacer);\n              }\n            }\n\n            _setState(isActive || isAtMax ? pinActiveState : pinState);\n\n            pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\n          }\n        }\n\n        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {\n          return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n        }); // classes could affect positioning, so do it even if reset or refreshing is true.\n\n        onUpdate && !isToggle && !reset && onUpdate(self);\n\n        if (stateChanged && !_refreshing) {\n          if (isToggle) {\n            if (isTakingAction) {\n              if (action === \"complete\") {\n                animation.pause().totalProgress(1);\n              } else if (action === \"reset\") {\n                animation.restart(true).pause();\n              } else if (action === \"restart\") {\n                animation.restart(true);\n              } else {\n                animation[action]();\n              }\n            }\n\n            onUpdate && onUpdate(self);\n          }\n\n          if (toggled || !_limitCallbacks) {\n            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n            onToggle && toggled && _callback(self, onToggle);\n            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\n\n            if (!toggled) {\n              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n              toggleState = clipped === 1 ? 1 : 3;\n              callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n            }\n          }\n\n          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n            _endAnimation(self.callbackAnimation);\n\n            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === \"reverse\" ? 1 : !clipped, 1);\n          }\n        } else if (isToggle && onUpdate && !_refreshing) {\n          onUpdate(self);\n        }\n      } // update absolutely-positioned markers (only if the scroller isn't the viewport)\n\n\n      if (markerEndSetter) {\n        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\n        markerEndSetter(n);\n      }\n\n      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n    };\n\n    self.enable = function (reset, refresh) {\n      if (!self.enabled) {\n        self.enabled = true;\n\n        _addListener(scroller, \"resize\", _onResize);\n\n        isViewport || _addListener(scroller, \"scroll\", _onScroll);\n        onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\n        if (reset !== false) {\n          self.progress = prevProgress = 0;\n          scroll1 = scroll2 = lastSnap = scrollFunc();\n        }\n\n        refresh !== false && self.refresh();\n      }\n    };\n\n    self.getTween = function (snap) {\n      return snap && tweenTo ? tweenTo.tween : scrubTween;\n    };\n\n    self.setPositions = function (newStart, newEnd, keepClamp, pinOffset) {\n      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()\n      if (containerAnimation) {\n        // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.\n        var st = containerAnimation.scrollTrigger,\n            duration = containerAnimation.duration(),\n            _change = st.end - st.start;\n\n        newStart = st.start + _change * newStart / duration;\n        newEnd = st.start + _change * newEnd / duration;\n      }\n\n      self.refresh(false, false, {\n        start: _keepClamp(newStart, keepClamp && !!self._startClamp),\n        end: _keepClamp(newEnd, keepClamp && !!self._endClamp)\n      }, pinOffset);\n      self.update();\n    };\n\n    self.adjustPinSpacing = function (amount) {\n      if (spacerState && amount) {\n        var i = spacerState.indexOf(direction.d) + 1;\n        spacerState[i] = parseFloat(spacerState[i]) + amount + _px;\n        spacerState[1] = parseFloat(spacerState[1]) + amount + _px;\n\n        _setState(spacerState);\n      }\n    };\n\n    self.disable = function (reset, allowAnimation) {\n      if (self.enabled) {\n        reset !== false && self.revert(true, true);\n        self.enabled = self.isActive = false;\n        allowAnimation || scrubTween && scrubTween.pause();\n        prevScroll = 0;\n        pinCache && (pinCache.uncache = 1);\n        onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\n        if (snapDelayedCall) {\n          snapDelayedCall.pause();\n          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n        }\n\n        if (!isViewport) {\n          var i = _triggers.length;\n\n          while (i--) {\n            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n              return; //don't remove the listeners if there are still other triggers referencing it.\n            }\n          }\n\n          _removeListener(scroller, \"resize\", _onResize);\n\n          isViewport || _removeListener(scroller, \"scroll\", _onScroll);\n        }\n      }\n    };\n\n    self.kill = function (revert, allowAnimation) {\n      self.disable(revert, allowAnimation);\n      scrubTween && !allowAnimation && scrubTween.kill();\n      id && delete _ids[id];\n\n      var i = _triggers.indexOf(self);\n\n      i >= 0 && _triggers.splice(i, 1);\n      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\n\n      i = 0;\n\n      _triggers.forEach(function (t) {\n        return t.scroller === self.scroller && (i = 1);\n      });\n\n      i || _refreshingAll || (self.scroll.rec = 0);\n\n      if (animation) {\n        animation.scrollTrigger = null;\n        revert && animation.revert({\n          kill: false\n        });\n        allowAnimation || animation.kill();\n      }\n\n      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n        return m.parentNode && m.parentNode.removeChild(m);\n      });\n      _primary === self && (_primary = 0);\n\n      if (pin) {\n        pinCache && (pinCache.uncache = 1);\n        i = 0;\n\n        _triggers.forEach(function (t) {\n          return t.pin === pin && i++;\n        });\n\n        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n      }\n\n      vars.onKill && vars.onKill(self);\n    };\n\n    _triggers.push(self);\n\n    self.enable(false, false);\n    customRevertReturn && customRevertReturn(self);\n\n    if (animation && animation.add && !change) {\n      // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\n      var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().\n\n      self.update = function () {\n        self.update = updateFunc;\n        _scrollers.cache++; // otherwise a cached scroll position may get used in the refresh() in a very rare scenario, like if ScrollTriggers are created inside a DOMContentLoaded event and the queued requestAnimationFrame() fires beforehand. See https://gsap.com/community/forums/topic/41267-scrolltrigger-breaks-on-refresh-when-using-domcontentloaded/\n\n        start || end || self.refresh();\n      };\n\n      gsap.delayedCall(0.01, self.update);\n      change = 0.01;\n      start = end = 0;\n    } else {\n      self.refresh();\n    }\n\n    pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()\n  };\n\n  ScrollTrigger.register = function register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n      _windowExists() && window.document && ScrollTrigger.enable();\n      _coreInitted = _enabled;\n    }\n\n    return _coreInitted;\n  };\n\n  ScrollTrigger.defaults = function defaults(config) {\n    if (config) {\n      for (var p in config) {\n        _defaults[p] = config[p];\n      }\n    }\n\n    return _defaults;\n  };\n\n  ScrollTrigger.disable = function disable(reset, kill) {\n    _enabled = 0;\n\n    _triggers.forEach(function (trigger) {\n      return trigger[kill ? \"kill\" : \"disable\"](reset);\n    });\n\n    _removeListener(_win, \"wheel\", _onScroll);\n\n    _removeListener(_doc, \"scroll\", _onScroll);\n\n    clearInterval(_syncInterval);\n\n    _removeListener(_doc, \"touchcancel\", _passThrough);\n\n    _removeListener(_body, \"touchstart\", _passThrough);\n\n    _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n\n    _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n\n    _resizeDelay.kill();\n\n    _iterateAutoRefresh(_removeListener);\n\n    for (var i = 0; i < _scrollers.length; i += 3) {\n      _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);\n\n      _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);\n    }\n  };\n\n  ScrollTrigger.enable = function enable() {\n    _win = window;\n    _doc = document;\n    _docEl = _doc.documentElement;\n    _body = _doc.body;\n\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _clamp = gsap.utils.clamp;\n      _context = gsap.core.context || _passThrough;\n      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n      _scrollRestoration = _win.history.scrollRestoration || \"auto\";\n      _lastScroll = _win.pageYOffset || 0;\n      gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n\n      if (_body) {\n        _enabled = 1;\n        _div100vh = document.createElement(\"div\"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.\n\n        _div100vh.style.height = \"100vh\";\n        _div100vh.style.position = \"absolute\";\n\n        _refresh100vh();\n\n        _rafBugFix();\n\n        Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n\n        ScrollTrigger.isTouch = Observer.isTouch;\n        _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503\n\n        _ignoreMobileResize = Observer.isTouch === 1;\n\n        _addListener(_win, \"wheel\", _onScroll); // mostly for 3rd party smooth scrolling libraries.\n\n\n        _root = [_win, _doc, _docEl, _body];\n\n        if (gsap.matchMedia) {\n          ScrollTrigger.matchMedia = function (vars) {\n            var mm = gsap.matchMedia(),\n                p;\n\n            for (p in vars) {\n              mm.add(p, vars[p]);\n            }\n\n            return mm;\n          };\n\n          gsap.addEventListener(\"matchMediaInit\", function () {\n            return _revertAll();\n          });\n          gsap.addEventListener(\"matchMediaRevert\", function () {\n            return _revertRecorded();\n          });\n          gsap.addEventListener(\"matchMedia\", function () {\n            _refreshAll(0, 1);\n\n            _dispatch(\"matchMedia\");\n          });\n          gsap.matchMedia().add(\"(orientation: portrait)\", function () {\n            // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.\n            _setBaseDimensions();\n\n            return _setBaseDimensions;\n          });\n        } else {\n          console.warn(\"Requires GSAP 3.11.0 or later\");\n        }\n\n        _setBaseDimensions();\n\n        _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n\n\n        var bodyHasStyle = _body.hasAttribute(\"style\"),\n            bodyStyle = _body.style,\n            border = bodyStyle.borderTopStyle,\n            AnimationProto = gsap.core.Animation.prototype,\n            bounds,\n            i;\n\n        AnimationProto.revert || Object.defineProperty(AnimationProto, \"revert\", {\n          value: function value() {\n            return this.time(-0.01, true);\n          }\n        }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)\n\n        bodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n\n        bounds = _getBounds(_body);\n        _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n\n        _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;\n        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\");\n\n        if (!bodyHasStyle) {\n          // SSR frameworks like Next.js complain if this attribute gets added.\n          _body.setAttribute(\"style\", \"\"); // it's not enough to just removeAttribute() - we must first set it to empty, otherwise Next.js complains.\n\n\n          _body.removeAttribute(\"style\");\n        } // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.\n\n\n        _syncInterval = setInterval(_sync, 250);\n        gsap.delayedCall(0.5, function () {\n          return _startup = 0;\n        });\n\n        _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n\n\n        _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n\n        _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n\n        _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n\n        _transformProp = gsap.utils.checkPrefix(\"transform\");\n\n        _stateProps.push(_transformProp);\n\n        _coreInitted = _getTime();\n        _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n        _autoRefresh = [_doc, \"visibilitychange\", function () {\n          var w = _win.innerWidth,\n              h = _win.innerHeight;\n\n          if (_doc.hidden) {\n            _prevWidth = w;\n            _prevHeight = h;\n          } else if (_prevWidth !== w || _prevHeight !== h) {\n            _onResize();\n          }\n        }, _doc, \"DOMContentLoaded\", _refreshAll, _win, \"load\", _refreshAll, _win, \"resize\", _onResize];\n\n        _iterateAutoRefresh(_addListener);\n\n        _triggers.forEach(function (trigger) {\n          return trigger.enable(0, 1);\n        });\n\n        for (i = 0; i < _scrollers.length; i += 3) {\n          _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);\n\n          _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);\n        }\n      }\n    }\n  };\n\n  ScrollTrigger.config = function config(vars) {\n    \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n    var ms = vars.syncInterval;\n    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n    \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);\n\n    if (\"autoRefreshEvents\" in vars) {\n      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n      _ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\n    }\n  };\n\n  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n    var t = _getTarget(target),\n        i = _scrollers.indexOf(t),\n        isViewport = _isViewport(t);\n\n    if (~i) {\n      _scrollers.splice(i, isViewport ? 6 : 2);\n    }\n\n    if (vars) {\n      isViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);\n    }\n  };\n\n  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\n    _triggers.forEach(function (t) {\n      return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);\n    });\n  };\n\n  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {\n    var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(),\n        offset = bounds[horizontal ? _width : _height] * ratio || 0;\n    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\n  };\n\n  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\n    _isString(element) && (element = _getTarget(element));\n    var bounds = element.getBoundingClientRect(),\n        size = bounds[horizontal ? _width : _height],\n        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\n    return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\n  };\n\n  ScrollTrigger.killAll = function killAll(allowListeners) {\n    _triggers.slice(0).forEach(function (t) {\n      return t.vars.id !== \"ScrollSmoother\" && t.kill();\n    });\n\n    if (allowListeners !== true) {\n      var listeners = _listeners.killAll || [];\n      _listeners = {};\n      listeners.forEach(function (f) {\n        return f();\n      });\n    }\n  };\n\n  return ScrollTrigger;\n}();\nScrollTrigger.version = \"3.13.0\";\n\nScrollTrigger.saveStyles = function (targets) {\n  return targets ? _toArray(targets).forEach(function (target) {\n    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\n    if (target && target.style) {\n      var i = _savedStyles.indexOf(target);\n\n      i >= 0 && _savedStyles.splice(i, 5);\n\n      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _context());\n    }\n  }) : _savedStyles;\n};\n\nScrollTrigger.revert = function (soft, media) {\n  return _revertAll(!soft, media);\n};\n\nScrollTrigger.create = function (vars, animation) {\n  return new ScrollTrigger(vars, animation);\n};\n\nScrollTrigger.refresh = function (safe) {\n  return safe ? _onResize(true) : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\n};\n\nScrollTrigger.update = function (force) {\n  return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);\n};\n\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\n\nScrollTrigger.maxScroll = function (element, horizontal) {\n  return _maxScroll(element, horizontal ? _horizontal : _vertical);\n};\n\nScrollTrigger.getScrollFunc = function (element, horizontal) {\n  return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);\n};\n\nScrollTrigger.getById = function (id) {\n  return _ids[id];\n};\n\nScrollTrigger.getAll = function () {\n  return _triggers.filter(function (t) {\n    return t.vars.id !== \"ScrollSmoother\";\n  });\n}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.\n\n\nScrollTrigger.isScrolling = function () {\n  return !!_lastScrollTime;\n};\n\nScrollTrigger.snapDirectional = _snapDirectional;\n\nScrollTrigger.addEventListener = function (type, callback) {\n  var a = _listeners[type] || (_listeners[type] = []);\n  ~a.indexOf(callback) || a.push(callback);\n};\n\nScrollTrigger.removeEventListener = function (type, callback) {\n  var a = _listeners[type],\n      i = a && a.indexOf(callback);\n  i >= 0 && a.splice(i, 1);\n};\n\nScrollTrigger.batch = function (targets, vars) {\n  var result = [],\n      varsCopy = {},\n      interval = vars.interval || 0.016,\n      batchMax = vars.batchMax || 1e9,\n      proxyCallback = function proxyCallback(type, callback) {\n    var elements = [],\n        triggers = [],\n        delay = gsap.delayedCall(interval, function () {\n      callback(elements, triggers);\n      elements = [];\n      triggers = [];\n    }).pause();\n    return function (self) {\n      elements.length || delay.restart(true);\n      elements.push(self.trigger);\n      triggers.push(self);\n      batchMax <= elements.length && delay.progress(1);\n    };\n  },\n      p;\n\n  for (p in vars) {\n    varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n  }\n\n  if (_isFunction(batchMax)) {\n    batchMax = batchMax();\n\n    _addListener(ScrollTrigger, \"refresh\", function () {\n      return batchMax = vars.batchMax();\n    });\n  }\n\n  _toArray(targets).forEach(function (target) {\n    var config = {};\n\n    for (p in varsCopy) {\n      config[p] = varsCopy[p];\n    }\n\n    config.trigger = target;\n    result.push(ScrollTrigger.create(config));\n  });\n\n  return result;\n}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).\n\n\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {\n  current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\n  return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\n},\n    _allowNativePanning = function _allowNativePanning(target, direction) {\n  if (direction === true) {\n    target.style.removeProperty(\"touch-action\");\n  } else {\n    target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\" + direction + (Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.\n  }\n\n  target === _docEl && _allowNativePanning(_body, direction);\n},\n    _overflow = {\n  auto: 1,\n  scroll: 1\n},\n    _nestedScroll = function _nestedScroll(_ref5) {\n  var event = _ref5.event,\n      target = _ref5.target,\n      axis = _ref5.axis;\n\n  var node = (event.changedTouches ? event.changedTouches[0] : event).target,\n      cache = node._gsap || gsap.core.getCache(node),\n      time = _getTime(),\n      cs;\n\n  if (!cache._isScrollT || time - cache._isScrollT > 2000) {\n    // cache for 2 seconds to improve performance.\n    while (node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {\n      node = node.parentNode;\n    }\n\n    cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\n    cache._isScrollT = time;\n  }\n\n  if (cache._isScroll || axis === \"x\") {\n    event.stopPropagation();\n    event._gsapAllow = true;\n  }\n},\n    // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor\n_inputObserver = function _inputObserver(target, type, inputs, nested) {\n  return Observer.create({\n    target: target,\n    capture: true,\n    debounce: false,\n    lockAxis: true,\n    type: type,\n    onWheel: nested = nested && _nestedScroll,\n    onPress: nested,\n    onDrag: nested,\n    onScroll: nested,\n    onEnable: function onEnable() {\n      return inputs && _addListener(_doc, Observer.eventTypes[0], _captureInputs, false, true);\n    },\n    onDisable: function onDisable() {\n      return _removeListener(_doc, Observer.eventTypes[0], _captureInputs, true);\n    }\n  });\n},\n    _inputExp = /(input|label|select|textarea)/i,\n    _inputIsFocused,\n    _captureInputs = function _captureInputs(e) {\n  var isInput = _inputExp.test(e.target.tagName);\n\n  if (isInput || _inputIsFocused) {\n    e._gsapAllow = true;\n    _inputIsFocused = isInput;\n  }\n},\n    _getScrollNormalizer = function _getScrollNormalizer(vars) {\n  _isObject(vars) || (vars = {});\n  vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\n  vars.type || (vars.type = \"wheel,touch\");\n  vars.debounce = !!vars.debounce;\n  vars.id = vars.id || \"normalizer\";\n\n  var _vars2 = vars,\n      normalizeScrollX = _vars2.normalizeScrollX,\n      momentum = _vars2.momentum,\n      allowNestedScroll = _vars2.allowNestedScroll,\n      onRelease = _vars2.onRelease,\n      self,\n      maxY,\n      target = _getTarget(vars.target) || _docEl,\n      smoother = gsap.core.globals().ScrollSmoother,\n      smootherInstance = smoother && smoother.get(),\n      content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),\n      scrollFuncY = _getScrollFunc(target, _vertical),\n      scrollFuncX = _getScrollFunc(target, _horizontal),\n      scale = 1,\n      initialScale = (Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,\n      wheelRefresh = 0,\n      resolveMomentumDuration = _isFunction(momentum) ? function () {\n    return momentum(self);\n  } : function () {\n    return momentum || 2.8;\n  },\n      lastRefreshID,\n      skipTouchMove,\n      inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),\n      resumeTouchMove = function resumeTouchMove() {\n    return skipTouchMove = false;\n  },\n      scrollClampX = _passThrough,\n      scrollClampY = _passThrough,\n      updateClamps = function updateClamps() {\n    maxY = _maxScroll(target, _vertical);\n    scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\n    normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _horizontal)));\n    lastRefreshID = _refreshID;\n  },\n      removeContentOffset = function removeContentOffset() {\n    content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + \"px\";\n    content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + parseFloat(content._gsap.y) + \", 0, 1)\";\n    scrollFuncY.offset = scrollFuncY.cacheID = 0;\n  },\n      ignoreDrag = function ignoreDrag() {\n    if (skipTouchMove) {\n      requestAnimationFrame(resumeTouchMove);\n\n      var offset = _round(self.deltaY / 2),\n          scroll = scrollClampY(scrollFuncY.v - offset);\n\n      if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {\n        scrollFuncY.offset = scroll - scrollFuncY.v;\n\n        var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);\n\n        content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n        content._gsap.y = y + \"px\";\n        scrollFuncY.cacheID = _scrollers.cache;\n\n        _updateAll();\n      }\n\n      return true;\n    }\n\n    scrollFuncY.offset && removeContentOffset();\n    skipTouchMove = true;\n  },\n      tween,\n      startScrollX,\n      startScrollY,\n      onStopDelayedCall,\n      onResize = function onResize() {\n    // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.\n    updateClamps();\n\n    if (tween.isActive() && tween.vars.scrollY > maxY) {\n      scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\n    }\n  };\n\n  content && gsap.set(content, {\n    y: \"+=0\"\n  }); // to ensure there's a cache (element._gsap)\n\n  vars.ignoreCheck = function (e) {\n    return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\n  };\n\n  vars.onPress = function () {\n    skipTouchMove = false;\n    var prevScale = scale;\n    scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\n    tween.pause();\n    prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\n    startScrollX = scrollFuncX();\n    startScrollY = scrollFuncY();\n    updateClamps();\n    lastRefreshID = _refreshID;\n  };\n\n  vars.onRelease = vars.onGestureStart = function (self, wasDragging) {\n    scrollFuncY.offset && removeContentOffset();\n\n    if (!wasDragging) {\n      onStopDelayedCall.restart(true);\n    } else {\n      _scrollers.cache++; // make sure we're pulling the non-cached value\n      // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),\tdur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)\n\n      var dur = resolveMomentumDuration(),\n          currentScroll,\n          endScroll;\n\n      if (normalizeScrollX) {\n        currentScroll = scrollFuncX();\n        endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.\n\n        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));\n        tween.vars.scrollX = scrollClampX(endScroll);\n      }\n\n      currentScroll = scrollFuncY();\n      endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)\n\n      dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));\n      tween.vars.scrollY = scrollClampY(endScroll);\n      tween.invalidate().duration(dur).play(0.01);\n\n      if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\n        // iOS bug: it'll show the address bar but NOT fire the window \"resize\" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.\n        gsap.to({}, {\n          onUpdate: onResize,\n          duration: dur\n        });\n      }\n    }\n\n    onRelease && onRelease(self);\n  };\n\n  vars.onWheel = function () {\n    tween._ts && tween.pause();\n\n    if (_getTime() - wheelRefresh > 1000) {\n      // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.\n      lastRefreshID = 0;\n      wheelRefresh = _getTime();\n    }\n  };\n\n  vars.onChange = function (self, dx, dy, xArray, yArray) {\n    _refreshID !== lastRefreshID && updateClamps();\n    dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.\n\n    if (dy) {\n      scrollFuncY.offset && removeContentOffset();\n      var isTouch = yArray[2] === dy,\n          y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],\n          yClamped = scrollClampY(y);\n      isTouch && y !== yClamped && (startScrollY += yClamped - y);\n      scrollFuncY(yClamped);\n    }\n\n    (dy || dx) && _updateAll();\n  };\n\n  vars.onEnable = function () {\n    _allowNativePanning(target, normalizeScrollX ? false : \"x\");\n\n    ScrollTrigger.addEventListener(\"refresh\", onResize);\n\n    _addListener(_win, \"resize\", onResize);\n\n    if (scrollFuncY.smooth) {\n      scrollFuncY.target.style.scrollBehavior = \"auto\";\n      scrollFuncY.smooth = scrollFuncX.smooth = false;\n    }\n\n    inputObserver.enable();\n  };\n\n  vars.onDisable = function () {\n    _allowNativePanning(target, true);\n\n    _removeListener(_win, \"resize\", onResize);\n\n    ScrollTrigger.removeEventListener(\"refresh\", onResize);\n    inputObserver.kill();\n  };\n\n  vars.lockAxis = vars.lockAxis !== false;\n  self = new Observer(vars);\n  self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.\n\n  _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.\n\n  _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping\n\n  onStopDelayedCall = self._dc;\n  tween = gsap.to(self, {\n    ease: \"power4\",\n    paused: true,\n    inherit: false,\n    scrollX: normalizeScrollX ? \"+=0.1\" : \"+=0\",\n    scrollY: \"+=0.1\",\n    modifiers: {\n      scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function () {\n        return tween.pause();\n      })\n    },\n    onUpdate: _updateAll,\n    onComplete: onStopDelayedCall.vars.onComplete\n  }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.\n\n  return self;\n};\n\nScrollTrigger.sort = function (func) {\n  if (_isFunction(func)) {\n    return _triggers.sort(func);\n  }\n\n  var scroll = _win.pageYOffset || 0;\n  ScrollTrigger.getAll().forEach(function (t) {\n    return t._sortY = t.trigger ? scroll + t.trigger.getBoundingClientRect().top : t.start + _win.innerHeight;\n  });\n  return _triggers.sort(func || function (a, b) {\n    return (a.vars.refreshPriority || 0) * -1e6 + (a.vars.containerAnimation ? 1e6 : a._sortY) - ((b.vars.containerAnimation ? 1e6 : b._sortY) + (b.vars.refreshPriority || 0) * -1e6);\n  }); // anything with a containerAnimation should refresh last.\n};\n\nScrollTrigger.observe = function (vars) {\n  return new Observer(vars);\n};\n\nScrollTrigger.normalizeScroll = function (vars) {\n  if (typeof vars === \"undefined\") {\n    return _normalizer;\n  }\n\n  if (vars === true && _normalizer) {\n    return _normalizer.enable();\n  }\n\n  if (vars === false) {\n    _normalizer && _normalizer.kill();\n    _normalizer = vars;\n    return;\n  }\n\n  var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);\n  _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\n  _isViewport(normalizer.target) && (_normalizer = normalizer);\n  return normalizer;\n};\n\nScrollTrigger.core = {\n  // smaller file size way to leverage in ScrollSmoother and Observer\n  _getVelocityProp: _getVelocityProp,\n  _inputObserver: _inputObserver,\n  _scrollers: _scrollers,\n  _proxies: _proxies,\n  bridge: {\n    // when normalizeScroll sets the scroll position (ss = setScroll)\n    ss: function ss() {\n      _lastScrollTime || _dispatch(\"scrollStart\");\n      _lastScrollTime = _getTime();\n    },\n    // a way to get the _refreshing value in Observer\n    ref: function ref() {\n      return _refreshing;\n    }\n  }\n};\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\nexport { ScrollTrigger as default };","import variables from '~~/config/variables.json';\n\nexport const useScreenQuery = () => {\n  const breakpoints = useBreakpoints(\n    {\n      mobile: 0,\n      desktop: variables.base.query,\n    },\n    // { ssrWidth: variables.base.query },\n  );\n\n  // for device detection use useDevice().isMobile // isDesktop\n  const isMobile = breakpoints.smallerOrEqual('desktop');\n  const isDesktop = breakpoints.greater('desktop');\n\n  return {\n    breakpoints,\n    isMobile,\n    isDesktop,\n  };\n};\n","// Server vs Browser\n// See: https://github.com/vercel/next.js/issues/5354#issuecomment-520305040\nexport const IS_SERVER = import.meta.server;\nexport const IS_BROWSER = import.meta.client;\n\n// for device detection use useDevice().isMobile // isDesktop\nexport const IS_DESKTOP = useScreenQuery().isDesktop;\nexport const IS_MOBILE = useScreenQuery().isMobile;\n\n// Environment Constants\nexport const DEV = process.env.NODE_ENV === 'development';\nexport const PROD = process.env.NODE_ENV !== 'development';\n","<template>\n   <SectionContact />\n  <header\n    id=\"header\"\n    ref=\"el\"\n    :class=\"{\n      'is--hidden': isHeaderHidden,\n      active: headerActive,\n    }\">\n    <div class=\"container\">\n      <nav class=\"nav\">\n        <div class=\"logo\">\n          <TextLogo />\n        </div>\n\n        <ul class=\"nav__list\">\n          <template v-for=\"(menu, key, idx) in menus\" :key=\"key\">\n            <li\n              :ref=\"(el) => setLiRef(key as MenuKey, el as HTMLElement)\"\n              class=\"has-dropdown\"\n              @mouseenter=\"handleOpen(key as MenuKey)\"\n              @mouseleave=\"handleClose\">\n              <NuxtLink\n                class=\"nav__item\"\n                :class=\"{ active: openMenuKey === (key as MenuKey) }\"\n                to=\"/\"\n                :aria-expanded=\"openMenuKey === (key as MenuKey)\">\n                <span class=\"text\">{{ menu.label }}</span>\n                <span class=\"placeholder\">{{ menu.label }}</span>\n                <IconChevron :class=\"{ open: openMenuKey === (key as MenuKey) }\" />\n              </NuxtLink>\n\n              <div\n                :ref=\"(el) => setPanelRef(key as MenuKey, el as HTMLElement)\"\n                class=\"dropdown\"\n                role=\"menu\"\n                :aria-label=\"menu.label\"\n                :class=\"{ 'is-open': openMenuKey === (key as MenuKey), 'is-closing': closingKey === (key as MenuKey) }\"\n                :style=\"panelStyles[key as MenuKey]\">\n                <ul class=\"dropdown__list\">\n                  <div :ref=\"(el) => setBgSelectorRef(key as MenuKey, el as HTMLElement)\" class=\"bg-selector\" aria-label=\"hidden\">\n                    <IconChevron class=\"submenu-icon\" />\n                  </div>\n\n                  <li\n                    v-for=\"(item, idx) in menu.items\"\n                    :key=\"idx\"\n                    :ref=\"(el) => setItemRef(key as MenuKey, idx, el as HTMLLIElement)\"\n                    @mouseenter=\"handleItemEnter(key as MenuKey, idx)\">\n                    <NuxtLink class=\"dropdown__item\" :to=\"item.to\">\n                      {{ item.label }}\n                    </NuxtLink>\n                  </li>\n                </ul>\n              </div>\n            </li>\n            <li v-if=\"idx === 2\">\n              <NuxtLink class=\"nav__item\" to=\"/\">\n                <span class=\"text\">Investor Relations</span>\n                <span class=\"placeholder\">Investor Relations</span>\n              </NuxtLink>\n            </li>\n          </template>\n        </ul>\n\n        <div class=\"cta\">\n          <ButtonCta class=\"btn-request\"> Contact Us </ButtonCta>\n        </div>\n\n        <!-- Mobile: Menu Toggle -->\n        <ButtonMenu :active-class=\"isMenuOpen\" @click=\"handleToggleMenu\" />\n\n        <ClientOnly>\n          <Teleport to=\"body\">\n            <div ref=\"elMobileMenu\" class=\"mobile-menu\" :class=\"{ 'is-open': isMenuOpen }\">\n              <div class=\"mobile-menu__overlay\" />\n              <aside ref=\"elMobilePanel\" class=\"mobile-menu__panel\" role=\"dialog\" aria-modal=\"true\" aria-label=\"Main navigation\">\n                <div class=\"mobile-menu__top\">\n                  <div class=\"logo\">\n                    <TextLogo />\n                  </div>\n\n                  <ButtonMenu :active-class=\"isMenuOpen\" @click=\"handleToggleMenu\" />\n                </div>\n\n                <ul class=\"mobile-menu__list\">\n                  <li v-for=\"(menu, key) in menus\" :key=\"key\">\n                    <button\n                      type=\"button\"\n                      class=\"mobile-menu__item\"\n                      :aria-expanded=\"mobileOpenKey === (key as MenuKey)\"\n                      :aria-controls=\"`submenu-${String(key)}`\"\n                      @click=\"handleMobileToggle(key as MenuKey)\">\n                      <span>{{ menu.label }}</span>\n                      <IconChevron class=\"arrow\" :class=\"{ open: mobileOpenKey === (key as MenuKey) }\" />\n                    </button>\n                    <Transition name=\"accordion\">\n                      <ul v-if=\"mobileOpenKey === (key as MenuKey)\" :id=\"`submenu-${String(key)}`\" class=\"mobile-submenu\">\n                        <li v-for=\"(item, idx) in menu.items\" :key=\"idx\">\n                          <NuxtLink class=\"mobile-submenu__item\" :to=\"item.to\" @click=\"handleCloseMenu\">\n                            {{ item.label }}\n                          </NuxtLink>\n                        </li>\n                      </ul>\n                    </Transition>\n                  </li>\n                  <li>\n                    <NuxtLink class=\"mobile-menu__item\" to=\"/\">\n                      <span>Investor Relations</span>\n                    </NuxtLink>\n                  </li>\n                </ul>\n\n                <div class=\"mobile-menu__cta\">\n                  <ButtonCta class=\"btn-request\" @click=\"handleCloseMenu\"> Contact Us </ButtonCta>\n                </div>\n              </aside>\n            </div>\n          </Teleport>\n        </ClientOnly>\n      </nav>\n    </div>\n  </header>\n</template>\n\n<script setup lang=\"ts\">\ninterface ScrollEvent {\n  isLocked: boolean;\n  actualScroll: number;\n  direction: number;\n}\n\nconst el = useTemplateRef('el');\nconst headerActive = ref<boolean>(false);\nconst isHeaderHidden = useHeaderHidden();\nconst isMenuOpen = ref<boolean>(false);\nconst mobileOpenKey = ref<MenuKey | null>(null);\nconst elMobileMenu = useTemplateRef<HTMLElement>('elMobileMenu');\nconst elMobilePanel = useTemplateRef<HTMLElement>('elMobilePanel');\n\nconst nuxtApp = useNuxtApp();\nconst lenis = nuxtApp.$lenis;\n\ntype MenuKey = 'about' | 'solutions' | 'technology' | 'resources';\n\nconst menus: Record<MenuKey, { label: string; items: { label: string; to: string }[] }> = {\n  about: {\n    label: 'About',\n    items: [\n      { label: 'Leadership & Vision', to: '/' },\n      { label: 'Technology Arm', to: '/' },\n      { label: 'Company Timeline', to: '/' },\n      { label: 'Investment Thesis', to: '/' },\n      { label: 'Leadership Team', to: '/' },\n    ],\n  },\n  solutions: {\n    label: 'Solutions',\n    items: [\n      { label: 'Portfolio Management', to: '/' },\n      { label: 'Research & Analytics', to: '/' },\n      { label: 'Risk Management', to: '/' },\n      { label: 'Advisory Services', to: '/' },\n      { label: 'Education Hub', to: '/' },\n    ],\n  },\n  technology: {\n    label: 'Technology',\n    items: [\n      { label: 'Platform Overview', to: '/' },\n      { label: 'Data Pipeline', to: '/' },\n      { label: 'Security & Compliance', to: '/' },\n      { label: 'API & Integrations', to: '/' },\n      { label: 'Infrastructure', to: '/' },\n    ],\n  },\n  resources: {\n    label: 'Resources',\n    items: [\n      { label: 'Blog', to: '/' },\n      { label: 'Case Studies', to: '/' },\n      { label: 'Press', to: '/' },\n      { label: 'FAQs', to: '/' },\n      { label: 'Support', to: '/' },\n    ],\n  },\n};\n\nconst openMenuKey = ref<MenuKey | null>(null);\nconst closingKey = ref<MenuKey | null>(null);\n\nconst liRefs = reactive<Record<MenuKey, HTMLElement | null>>({\n  about: null,\n  solutions: null,\n  technology: null,\n  resources: null,\n});\nconst panelRefs = reactive<Record<MenuKey, HTMLElement | null>>({\n  about: null,\n  solutions: null,\n  technology: null,\n  resources: null,\n});\n\nconst bgSelectorRefs = reactive<Record<MenuKey, HTMLElement | null>>({\n  about: null,\n  solutions: null,\n  technology: null,\n  resources: null,\n});\n\nconst itemRefs = reactive<Record<MenuKey, (HTMLLIElement | null)[]>>({\n  about: [],\n  solutions: [],\n  technology: [],\n  resources: [],\n});\n\nconst panelStyles = reactive<Record<MenuKey, any>>({\n  about: {},\n  solutions: {},\n  technology: {},\n  resources: {},\n});\n\nconst setLiRef = (key: MenuKey, el: HTMLElement | null) => (liRefs[key] = el);\nconst setPanelRef = (key: MenuKey, el: HTMLElement | null) => (panelRefs[key] = el);\nconst setBgSelectorRef = (key: MenuKey, el: HTMLElement | null) => (bgSelectorRefs[key] = el);\nconst setItemRef = (key: MenuKey, index: number, el: HTMLLIElement | null) => {\n  if (!itemRefs[key]) itemRefs[key] = [];\n  itemRefs[key][index] = el;\n};\n\nfunction handleOpen(key: MenuKey): void {\n  openMenuKey.value = key;\n  nextTick(() => positionPanel(key));\n}\n\nfunction handleClose(): void {\n  openMenuKey.value = null;\n}\n\n// hover only; no click toggle\n\nObject.keys(menus).forEach((k) => {\n  const key = k as MenuKey;\n  const elRef = computed(() => liRefs[key]);\n  onClickOutside(elRef, () => {\n    if (openMenuKey.value === key) openMenuKey.value = null;\n  });\n});\n\nuseEventListener('keydown', (e: KeyboardEvent) => {\n  if (e.key === 'Escape') openMenuKey.value = null;\n});\n\nnuxtApp.hook('page:transition:finish', () => {\n  if (!isHeaderHidden.value) return;\n  isHeaderHidden.value = false;\n});\n\nconst isPreloadDone = usePreloadDone();\n\nlet ctx: gsap.Context;\n\nonMounted(() => {\n  const scrollLock = useScrollLock(document?.body as unknown as HTMLElement);\n\n  watch(isMenuOpen, (open) => {\n    scrollLock.value = open;\n  });\n\n  const animateOpen = (target: HTMLElement) => {\n    gsap.killTweensOf(target);\n    gsap.fromTo(target, { opacity: 0, y: 8, scale: 0.98 }, { opacity: 1, y: 0, scale: 1, duration: 0.28, ease: 'power2.out' });\n  };\n\n  const animateClose = (target: HTMLElement) => {\n    gsap.killTweensOf(target);\n    gsap.to(target, { opacity: 0, y: 8, scale: 0.98, duration: 0.24, ease: 'power2.inOut' });\n  };\n\n  watch(openMenuKey, (key, prev) => {\n    // Pause/resume Lenis when dropdown opens/closes\n    if (key) {\n      lenis.pause();\n    } else {\n      lenis.resume();\n    }\n\n    // close previous\n    if (prev) {\n      const prevEl = panelRefs[prev];\n      if (prevEl) {\n        closingKey.value = prev;\n        animateClose(prevEl);\n        // after close animation, clear closing flag\n        setTimeout(() => {\n          if (closingKey.value === prev) closingKey.value = null;\n        }, 260);\n      }\n      const prevBg = bgSelectorRefs[prev];\n      if (prevBg) {\n        gsap.to(prevBg, { opacity: 0, duration: 0.18, ease: 'power2.out' });\n      }\n    }\n\n    // open next\n    if (key) {\n      const nextEl = panelRefs[key];\n      if (nextEl) animateOpen(nextEl);\n      nextTick(() => {\n        initializeBgSelectorPosition(key as MenuKey);\n      });\n    }\n  });\n\n  useWindowResize(() => {\n    if (openMenuKey.value) positionPanel(openMenuKey.value as MenuKey);\n  });\n\n  lenis.on('scroll', (e: ScrollEvent) => {\n    if (!el.value) return;\n    if (e.isLocked) return;\n\n    if (e.actualScroll <= 130) return;\n    if (e.direction === 1) {\n      isHeaderHidden.value = true;\n    } else if (e.direction === -1) {\n      isHeaderHidden.value = false;\n    }\n  });\n\n  ctx = gsap.context(() => {\n    ScrollTrigger.create({\n      trigger: document.body,\n      start: `${window.innerHeight - 300}px`,\n      invalidateOnRefresh: true,\n      onEnter: () => {\n        headerActive.value = true;\n      },\n      onLeaveBack: () => {\n        headerActive.value = false;\n      },\n    });\n\n    const tlIntro = gsap.timeline({\n      paused: !isPreloadDone.value,\n    });\n\n    tlIntro.from('.nav > *', {\n      yPercent: -190,\n      stagger: 0.15,\n      willChange: 'transform',\n    });\n\n    const { trigger } = watchTriggerable(isPreloadDone, (value) => {\n      if (value) {\n        tlIntro.play();\n      }\n    });\n\n    trigger();\n  }, el.value);\n\n  useEventListener(window, 'keydown', (e: KeyboardEvent) => {\n    if (e.key === 'Escape' && isMenuOpen.value) handleCloseMenu();\n  });\n\n  // Drag-to-close: allow dragging the mobile panel downward to close\n  const menuEl = elMobileMenu;\n  const panelEl = elMobilePanel;\n\n  let isDraggingMenu = false;\n  let dragStartY = 0;\n  let currentDragY = 0;\n  const DRAG_CLOSE_THRESHOLD = 120;\n\n  useEventListener(panelEl, 'pointerdown', (e: PointerEvent) => {\n    if (!isMenuOpen.value) return;\n    const panel = panelEl.value;\n    if (!panel) return;\n    // Only start drag when scrolled to top to avoid conflicting with content scroll\n    if (panel.scrollTop > 0) {\n      isDraggingMenu = false;\n      return;\n    }\n    isDraggingMenu = true;\n    dragStartY = e.clientY;\n    currentDragY = 0;\n  });\n\n  useEventListener(panelEl, 'pointermove', (e: PointerEvent) => {\n    if (!isDraggingMenu) return;\n    const delta = e.clientY - dragStartY;\n    currentDragY = Math.max(0, delta);\n    const menu = menuEl.value;\n    if (!menu) return;\n    if (currentDragY === 0) return;\n    gsap.set(menu, { y: currentDragY });\n  });\n\n  const endDrag = () => {\n    if (!isDraggingMenu) return;\n    const menu = menuEl.value;\n    isDraggingMenu = false;\n    if (!menu) return;\n    if (currentDragY > DRAG_CLOSE_THRESHOLD) {\n      gsap.to(menu, {\n        y: '100%',\n        duration: 0.22,\n        ease: 'power3.out',\n        onComplete: () => {\n          gsap.set(menu, { clearProps: 'transform' });\n          handleCloseMenu();\n        },\n      });\n    } else {\n      gsap.to(menu, {\n        y: 0,\n        duration: 0.22,\n        ease: 'power3.out',\n        onComplete: () => {\n          gsap.set(menu, { clearProps: 'transform' });\n        },\n      });\n    }\n    currentDragY = 0;\n  };\n\n  useEventListener(panelEl, 'pointerup', endDrag);\n  useEventListener(panelEl, 'pointercancel', endDrag);\n});\n\nonUnmounted(() => {\n  ctx?.revert();\n});\n\nfunction positionPanel(key: MenuKey): void {\n  const liEl = liRefs[key];\n  const panelEl = panelRefs[key];\n  if (!liEl || !panelEl) return;\n\n  const liRect = liEl.getBoundingClientRect();\n  const navRect = liEl.closest('.nav__list')?.getBoundingClientRect();\n  if (!navRect) return;\n\n  const panelRect = panelEl.getBoundingClientRect();\n  const navWidth = navRect.width;\n\n  const liLeftWithinNav = liRect.left - navRect.left;\n  const liCenterWithinNav = liLeftWithinNav + liRect.width / 2;\n\n  // Desired panel left so its center aligns with the li center\n  const desiredLeftWithinNav = liCenterWithinNav - panelRect.width / 2;\n  // Clamp to stay within nav bounds\n  const clampedLeftWithinNav = Math.max(0, Math.min(desiredLeftWithinNav, navWidth - panelRect.width));\n  // Convert to left relative to li (since panel is absolutely positioned inside li)\n  const leftRelativeToLi = clampedLeftWithinNav - liLeftWithinNav;\n\n  // Caret should point to li center relative to the panel\n  const caretLeft = liCenterWithinNav - clampedLeftWithinNav;\n  const caretClamped = Math.max(12, Math.min(caretLeft, panelRect.width - 12));\n\n  panelStyles[key] = {\n    left: `${leftRelativeToLi}px`,\n    '--caret-left': `${caretClamped}px`,\n  };\n}\n\nfunction initializeBgSelectorPosition(key: MenuKey): void {\n  const items = itemRefs[key];\n  const bg = bgSelectorRefs[key];\n  if (!items || !items.length || !bg) return;\n  const firstItem = items[0];\n  if (!firstItem) return;\n  const top = firstItem.offsetTop;\n  const height = firstItem.offsetHeight;\n  gsap.set(bg, { y: top, height, opacity: 1 });\n\n  gsap.to(bg, {\n    scale: 0,\n  });\n}\n\nfunction handleItemEnter(key: MenuKey, index: number): void {\n  moveBgToItem(key, index);\n}\n\nfunction moveBgToItem(key: MenuKey, index: number): void {\n  const bg = bgSelectorRefs[key];\n  const items = itemRefs[key];\n  if (!bg || !items || !items[index]) return;\n\n  const item = items[index] as HTMLLIElement;\n  const top = item.offsetTop;\n  const height = item.offsetHeight;\n\n  gsap.killTweensOf(bg);\n\n  gsap.to(bg, {\n    y: top,\n    height,\n    opacity: 1,\n    scale: 1,\n    duration: 0.3,\n  });\n}\n\nfunction handleToggleMenu(): void {\n  isMenuOpen.value = !isMenuOpen.value;\n}\n\nfunction handleCloseMenu(): void {\n  isMenuOpen.value = false;\n  mobileOpenKey.value = null;\n}\n\nfunction handleMobileToggle(key: MenuKey): void {\n  mobileOpenKey.value = mobileOpenKey.value === key ? null : key;\n}\n</script>\n\n<style scoped lang=\"scss\">\n#header {\n  will-change: transform;\n\n  position: fixed;\n  z-index: 9999;\n  top: 0;\n  left: 0;\n\n  width: 100%;\n  padding: fn.toVw(20) 0;\n\n  transition:\n    transform 0.6s $transition-ease,\n    background-color 0.6s $transition-ease;\n\n  &.is--hidden {\n    transform: translate3d(0, -120%, 0) !important;\n  }\n\n  &.active {\n    background-color: $color-background;\n  }\n}\n\n.nav {\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n\n  .nav__list {\n    display: flex;\n    gap: fn.toVw(57);\n    align-items: center;\n\n    padding: fn.toVw(15) fn.toVw(40);\n    border-radius: fn.toVw(10);\n\n    font-size: fn.toVw(16);\n\n    background: rgb(255 255 255 / 60%);\n\n    @include mx.mobile {\n      display: none;\n    }\n\n    > li {\n      position: relative;\n    }\n\n    .has-dropdown::after {\n      content: '';\n\n      position: absolute;\n      top: 100%;\n      right: 0;\n      left: 0;\n\n      height: fn.toVw(28);\n    }\n\n    .nav__item {\n      position: relative;\n\n      overflow: hidden;\n      display: flex;\n      gap: fn.toVw(6);\n      align-items: center;\n\n      &:deep(svg) {\n        width: fn.toVw(12);\n        opacity: 1;\n        transition:\n          opacity 0.2s ease,\n          transform 0.2s ease;\n      }\n\n      &:hover,\n      &.active {\n        font-weight: 500;\n\n        .text {\n          transform: translateY(-101%);\n        }\n\n        .placeholder {\n          transform: translateY(0);\n        }\n      }\n\n      :deep(.open) {\n        transform: rotate(180deg);\n        opacity: 1;\n        transition:\n          opacity 0.2s ease,\n          transform 0.2s ease;\n      }\n\n      .text {\n        will-change: transform;\n        position: absolute;\n        inset: 0;\n        transition: transform $transition-default;\n      }\n\n      .placeholder {\n        pointer-events: none;\n        will-change: transform;\n\n        transform: translateY(100%);\n\n        font-weight: 500;\n\n        transition: transform $transition-default;\n      }\n    }\n\n    .dropdown {\n      pointer-events: none;\n\n      position: absolute;\n      z-index: 10;\n      top: calc(100% + fn.toVw(30));\n      left: 0;\n      transform-origin: top left;\n      transform: none;\n\n      min-width: fn.toVw(300);\n      padding: fn.toVw(30) fn.toVw(27);\n      border-radius: fn.toVw(15);\n\n      font-size: fn.toVw(16);\n      font-weight: 300;\n\n      visibility: hidden;\n      opacity: 0;\n      background: $color-background;\n      box-shadow: 0 fn.toVw(20) fn.toVw(60) rgb(16 24 40 / 8%);\n\n      &::before {\n        content: '';\n\n        position: absolute;\n        top: fn.toVw(-8);\n        left: var(--caret-left, fn.toVw(28));\n        transform: translateX(-50%) rotate(45deg);\n\n        width: fn.toVw(16);\n        height: fn.toVw(16);\n\n        background: $color-background;\n        box-shadow: -1px -1px 1px rgb(16 24 40 / 3%);\n      }\n\n      &.is-open {\n        pointer-events: auto;\n        visibility: visible;\n        opacity: 1;\n      }\n\n      &.is-closing {\n        pointer-events: none;\n        visibility: visible;\n      }\n\n      .dropdown__list {\n        position: relative;\n        display: flex;\n        flex-direction: column;\n        gap: fn.toVw(6);\n      }\n\n      .bg-selector {\n        pointer-events: none;\n\n        position: absolute;\n        z-index: -1;\n        transform: scale(0);\n\n        display: flex;\n        justify-content: flex-end;\n\n        width: 100%;\n        height: fn.toVw(50);\n        padding: fn.toVw(16) fn.toVw(18);\n        border-radius: fn.toVw(10);\n\n        background-color: $color-neutral;\n\n        .submenu-icon {\n          transform: rotate(270deg) translateY(-4px);\n          width: fn.toVw(12);\n        }\n      }\n\n      .dropdown__item {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n\n        padding: fn.toVw(16) fn.toVw(18);\n        border-radius: fn.toVw(10);\n\n        color: inherit;\n\n        background: transparent;\n      }\n    }\n  }\n\n  .cta {\n    @include mx.mobile {\n      display: none;\n    }\n  }\n}\n\n.mobile-menu {\n  pointer-events: none;\n\n  position: fixed;\n  z-index: 10001;\n  bottom: 0;\n  left: fn.toVw(10);\n  transform: translateY(100%);\n\n  overflow: hidden;\n\n  width: calc(100% - fn.toVw(20));\n  height: calc(100dvh - 14px);\n  border-radius: fn.toVw(13);\n\n  transition: transform 0.6s $transition-easegsap-power4-out;\n\n  @include mx.desktop {\n    display: none;\n  }\n\n  &.is-open {\n    pointer-events: auto;\n    transform: translateY(0);\n  }\n\n  .mobile-menu__overlay {\n    pointer-events: none;\n    position: absolute;\n    inset: 0;\n  }\n\n  .mobile-menu__panel {\n    overflow-y: auto;\n    display: flex;\n    flex-direction: column;\n\n    width: 100%;\n    height: 100%;\n    padding: fn.toVw(15);\n\n    background-color: $color-background;\n  }\n\n  .mobile-menu__top {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: fn.toSvh(65);\n  }\n\n  .mobile-menu__list {\n    display: flex;\n    flex-direction: column;\n    gap: fn.toVw(30);\n\n    margin-bottom: fn.toVw(30);\n    padding: 0 fn.toVw(16);\n\n    font-size: fn.toVw(22);\n    font-weight: 300;\n  }\n\n  .mobile-menu__item {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n\n    width: 100%;\n    padding: fn.toVw(8) 0;\n    border-radius: fn.toVw(10);\n\n    color: inherit;\n    text-align: left;\n\n    background: transparent;\n\n    &:deep(.arrow) {\n      transform: rotate(-90deg);\n      width: fn.toVw(12);\n      opacity: 1;\n    }\n\n    &:deep(.arrow.open) {\n      transform: rotate(0deg);\n      transition: transform 0.2s ease;\n    }\n  }\n\n  .mobile-submenu {\n    display: flex;\n    flex-direction: column;\n    gap: fn.toVw(16);\n\n    margin-top: fn.toVw(12);\n    padding-left: fn.toVw(12);\n    border-left: 1px solid rgb(0 0 0 / 6%);\n  }\n\n  .mobile-submenu__item {\n    display: block;\n    padding: fn.toVw(6) 0;\n    color: inherit;\n  }\n\n  :deep(.accordion-enter-active),\n  :deep(.accordion-leave-active) {\n    transition: all 0.2s ease;\n  }\n\n  :deep(.accordion-enter-from),\n  :deep(.accordion-leave-to) {\n    transform: translateY(-6px);\n    opacity: 0;\n  }\n\n  .mobile-menu__cta {\n    margin-top: auto;\n    margin-bottom: calc(fn.toVw(27) - fn.toVw(15));\n\n    &:deep(.btn) {\n      background:\n        linear-gradient($color-neutral, $color-neutral) padding-box,\n        linear-gradient(0deg, #f2f2f2, #818181 80%, $color-neutral) border-box;\n    }\n  }\n}\n</style>\n","import { computed, getCurrentScope, onScopeDispose, shallowRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nfunction defaultEstimatedProgress(duration, elapsed) {\n  const completionPercentage = elapsed / duration * 100;\n  return 2 / Math.PI * 100 * Math.atan(completionPercentage / 50);\n}\nfunction createLoadingIndicator(opts = {}) {\n  const { duration = 2e3, throttle = 200, hideDelay = 500, resetDelay = 400 } = opts;\n  const getProgress = opts.estimatedProgress || defaultEstimatedProgress;\n  const nuxtApp = useNuxtApp();\n  const progress = shallowRef(0);\n  const isLoading = shallowRef(false);\n  const error = shallowRef(false);\n  let done = false;\n  let rafId;\n  let throttleTimeout;\n  let hideTimeout;\n  let resetTimeout;\n  const start = (opts2 = {}) => {\n    _clearTimeouts();\n    error.value = false;\n    set(0, opts2);\n  };\n  function set(at = 0, opts2 = {}) {\n    if (nuxtApp.isHydrating) {\n      return;\n    }\n    if (at >= 100) {\n      return finish({ force: opts2.force });\n    }\n    clear();\n    progress.value = at < 0 ? 0 : at;\n    const throttleTime = opts2.force ? 0 : throttle;\n    if (throttleTime && import.meta.client) {\n      throttleTimeout = setTimeout(() => {\n        isLoading.value = true;\n        _startProgress();\n      }, throttleTime);\n    } else {\n      isLoading.value = true;\n      _startProgress();\n    }\n  }\n  function _hide() {\n    if (import.meta.client) {\n      hideTimeout = setTimeout(() => {\n        isLoading.value = false;\n        resetTimeout = setTimeout(() => {\n          progress.value = 0;\n        }, resetDelay);\n      }, hideDelay);\n    }\n  }\n  function finish(opts2 = {}) {\n    progress.value = 100;\n    done = true;\n    clear();\n    _clearTimeouts();\n    if (opts2.error) {\n      error.value = true;\n    }\n    if (opts2.force) {\n      progress.value = 0;\n      isLoading.value = false;\n    } else {\n      _hide();\n    }\n  }\n  function _clearTimeouts() {\n    if (import.meta.client) {\n      clearTimeout(hideTimeout);\n      clearTimeout(resetTimeout);\n    }\n  }\n  function clear() {\n    if (import.meta.client) {\n      clearTimeout(throttleTimeout);\n      cancelAnimationFrame(rafId);\n    }\n  }\n  function _startProgress() {\n    done = false;\n    let startTimeStamp;\n    function step(timeStamp) {\n      if (done) {\n        return;\n      }\n      startTimeStamp ??= timeStamp;\n      const elapsed = timeStamp - startTimeStamp;\n      progress.value = Math.max(0, Math.min(100, getProgress(duration, elapsed)));\n      if (import.meta.client) {\n        rafId = requestAnimationFrame(step);\n      }\n    }\n    if (import.meta.client) {\n      rafId = requestAnimationFrame(step);\n    }\n  }\n  let _cleanup = () => {\n  };\n  if (import.meta.client) {\n    const unsubLoadingStartHook = nuxtApp.hook(\"page:loading:start\", () => {\n      start();\n    });\n    const unsubLoadingFinishHook = nuxtApp.hook(\"page:loading:end\", () => {\n      finish();\n    });\n    const unsubError = nuxtApp.hook(\"vue:error\", () => finish());\n    _cleanup = () => {\n      unsubError();\n      unsubLoadingStartHook();\n      unsubLoadingFinishHook();\n      clear();\n    };\n  }\n  return {\n    _cleanup,\n    progress: computed(() => progress.value),\n    isLoading: computed(() => isLoading.value),\n    error: computed(() => error.value),\n    start,\n    set,\n    finish,\n    clear\n  };\n}\nexport function useLoadingIndicator(opts = {}) {\n  const nuxtApp = useNuxtApp();\n  const indicator = nuxtApp._loadingIndicator ||= createLoadingIndicator(opts);\n  if (import.meta.client && getCurrentScope()) {\n    nuxtApp._loadingIndicatorDeps ||= 0;\n    nuxtApp._loadingIndicatorDeps++;\n    onScopeDispose(() => {\n      nuxtApp._loadingIndicatorDeps--;\n      if (nuxtApp._loadingIndicatorDeps === 0) {\n        indicator._cleanup();\n        delete nuxtApp._loadingIndicator;\n      }\n    });\n  }\n  return indicator;\n}\n","<template>\n  <div v-if=\"isLoadingMotion\" ref=\"el\" class=\"base-indicator\" />\n</template>\n\n<script setup>\nimport gsap from 'gsap';\n\nconst el = useTemplateRef('el');\nconst isLoadingMotion = ref(true);\n\nconst preloadProgress = usePreloadProgress();\n\nconst { progress, isLoading, start, finish, clear } = useLoadingIndicator({\n  duration: 800,\n  throttle: 50,\n  estimatedProgress: (duration, elapsed) => (2 / Math.PI) * 100 * Math.atan(((elapsed / duration) * 100) / 50),\n});\n\nconst animateProgress = (value) => {\n  ctx = gsap.context(() => {\n    gsap.to(el.value, {\n      scaleX: gsap.utils.mapRange(1, 100, 0, 1, value),\n      xPercent: value < 100 ? 0 : 100,\n      duration: value < 100 ? 0.3 : 0.8,\n      transformOrigin: 'left',\n      ease: value < 100 ? 'power2.out' : 'power2.inOut',\n      onComplete: () => {\n        if (value >= 100) {\n          clear();\n          isLoadingMotion.value = false;\n        }\n      },\n    });\n  });\n};\n\nlet ctx;\n\nonMounted(() => {\n  callOnce(() => {\n    watch(preloadProgress, (val) => {\n      animateProgress(val);\n    });\n  });\n\n  watch(isLoading, (val) => {\n    if (val) {\n      isLoadingMotion.value = true;\n      start();\n    } else {\n      finish();\n    }\n  });\n\n  watch(progress, (val) => {\n    if (!isLoading.value) return;\n    animateProgress(val);\n  });\n});\n\nonUnmounted(() => {\n  ctx?.revert();\n});\n</script>\n\n<style scoped lang=\"scss\">\n.base-indicator {\n  will-change: transform;\n\n  position: fixed;\n  z-index: 10000;\n  top: 0;\n  left: 0;\n  transform-origin: left;\n  transform: scaleX(0);\n\n  overflow: hidden;\n\n  width: 100%;\n  height: 4px;\n\n  background-color: $color-primary;\n}\n</style>\n","<template>\n  <div v-if=\"!isPreloadDone\" ref=\"el\" class=\"preloader\">\n    <div class=\"preloader__inner\">\n      <div class=\"preloader__text-wrapper masking-text\">\n        <p ref=\"elText\" class=\"preloader__text\">{{ integerNumber }}</p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport variables from '~~/config/variables.json';\n\nconst isPreloadDone = usePreloadDone();\nconst mediaStore = useMediaStore();\nconst preloaderItems = usePreloaderItems();\nconst preloadProgress = usePreloadProgress();\n\n// Remove duplicates and add images to preloader items\nconst uniqueImages = [...new Set(mediaStore.images.value)];\nconst existingImageSrcs = new Set(preloaderItems.value.filter((item) => item.type === 'image').map((item) => item.src));\nconst newImages = uniqueImages.filter((img) => !existingImageSrcs.has(img));\npreloaderItems.value.push(...newImages.map((img) => ({ src: img, type: 'image' })));\n\n// Get font families from variables.json and add to preloader items (only if preloaderfont is enabled)\nif (variables.component.preloaderfont) {\n  const fontNames = new Set();\n  for (const value of Object.values(variables.font.family)) {\n    const fontName = value.split(',')[0].replace(/['\"]/g, '').trim();\n    fontNames.add(fontName);\n  }\n\n  const existingFontIds = new Set(preloaderItems.value.filter((item) => item.type === 'font').map((item) => item.id));\n  for (const fontName of fontNames) {\n    if (!existingFontIds.has(fontName)) {\n      const fontObject = {\n        id: fontName,\n        type: 'font',\n      };\n\n      preloaderItems.value.push(fontObject);\n    }\n  }\n}\n\nconst el = useTemplateRef('el');\nconst elText = useTemplateRef('elText');\n\nconst loadedCount = ref(0);\nconst totalItems = ref(0);\n\nconst integerNumber = computed(() => Math.floor(preloadProgress.value));\n\nconst updateProgress = () => {\n  if (totalItems.value === 0) return;\n\n  const targetProgress = (100 * loadedCount.value) / totalItems.value;\n  gsap.to(preloadProgress, {\n    value: targetProgress,\n    duration: 0.1,\n    ease: 'none',\n    onUpdate: () => {\n      preloadProgress.value = Number(preloadProgress.value.toFixed(0));\n    },\n  });\n};\n\nconst loadImage = (src) => {\n  return new Promise((resolve) => {\n    const img = new Image();\n\n    const handleComplete = () => {\n      loadedCount.value++;\n      updateProgress();\n      resolve(img);\n    };\n\n    img.onload = handleComplete;\n    img.onerror = () => {\n      if (DEV) {\n        console.error(`Failed to load image: ${src}`);\n      }\n      handleComplete();\n    };\n\n    img.src = src;\n  });\n};\n\nconst loadFont = () => {\n  return new Promise((resolve) => {\n    if (document.fonts && document.fonts.ready) {\n      document.fonts.ready\n        .then(() => {\n          loadedCount.value++;\n          updateProgress();\n          resolve();\n        })\n        .catch(() => {\n          // Fallback if fonts.ready fails\n          loadedCount.value++;\n          updateProgress();\n          resolve();\n        });\n    } else {\n      // Fallback for older browsers\n      requestAnimationFrame(() => {\n        loadedCount.value++;\n        updateProgress();\n        resolve();\n      });\n    }\n  });\n};\n\nconst loadItem = (item) => {\n  if (item.type === 'image') {\n    return loadImage(item.src);\n  } else if (item.type === 'font') {\n    return loadFont();\n  }\n\n  // Fallback for unknown types\n  return new Promise((resolve) => {\n    loadedCount.value++;\n    updateProgress();\n    resolve();\n  });\n};\n\nconst leave = () => {\n  gsap.to(preloadProgress, {\n    value: 100,\n    duration: 0.1,\n    ease: 'none',\n    onUpdate: () => {\n      preloadProgress.value = Number(preloadProgress.value.toFixed(0));\n    },\n  });\n\n  const tl = gsap.timeline({\n    onComplete: () => {\n      isPreloadDone.value = true;\n    },\n  });\n\n  tl.to(elText.value, {\n    yPercent: -101,\n    duration: 0.5,\n  });\n\n  tl.to(\n    el.value,\n    {\n      opacity: 0,\n      duration: 0.5,\n    },\n    '<=50%',\n  );\n};\n\nconst afterDone = () => {\n  ScrollTrigger.refresh();\n};\n\nwatch(isPreloadDone, (value) => {\n  if (value) {\n    afterDone();\n  }\n});\n\nconst lenis = useNuxtApp().$lenis;\n\nonMounted(() => {\n  if (isPreloadDone.value) return;\n\n  lenis.scrollTo(0, {\n    duration: 0,\n    force: true,\n    immediate: true,\n  });\n\n  const preload = () => {\n    // Calculate total items from preloaderItems array\n    totalItems.value = preloaderItems.value.length;\n\n    // If no items to preload, immediately complete\n    if (totalItems.value === 0) {\n      totalItems.value = 1;\n      loadedCount.value = 1;\n      updateProgress();\n      leave();\n      return;\n    }\n\n    // Load all items from preloaderItems array\n    const loadPromises = preloaderItems.value.map((item) => loadItem(item));\n\n    Promise.all(loadPromises).finally(() => {\n      leave();\n    });\n  };\n\n  preload();\n});\n</script>\n\n<style scoped lang=\"scss\">\n.preloader {\n  position: fixed;\n  z-index: 9999;\n  inset: 0;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  width: 100%;\n  height: 100vh;\n\n  color: $color-text;\n\n  background-color: $color-background;\n}\n\n.preloader__inner {\n  position: relative;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  width: 100%;\n  height: 100%;\n  padding: fn.toVw(20);\n\n  @include mx.mobile {\n    height: calc(100vh - var(--vhmobilebar));\n    padding: fn.toVw(20);\n  }\n}\n\n.preloader__text {\n  font-size: 14px;\n  transition: transform 0.5s $transition-ease;\n}\n</style>\n","import { isRef, ref, toValue, watch } from \"vue\";\nimport { tryUseNuxtApp, onNuxtReady, requestIdleCallback } from \"nuxt/app\";\nexport function useScriptTriggerConsent(options) {\n  if (import.meta.server)\n    return new Promise(() => {\n    });\n  const consented = ref(false);\n  const nuxtApp = tryUseNuxtApp();\n  const promise = new Promise((resolve) => {\n    watch(consented, (ready) => {\n      if (ready) {\n        const runner = nuxtApp?.runWithContext || ((cb) => cb());\n        if (options?.postConsentTrigger instanceof Promise) {\n          options.postConsentTrigger.then(() => runner(resolve));\n          return;\n        }\n        if (typeof options?.postConsentTrigger === \"function\") {\n          if (options?.postConsentTrigger.length === 1) {\n            options.postConsentTrigger(resolve);\n            return;\n          }\n          const val = options.postConsentTrigger();\n          if (val instanceof Promise) {\n            return val.then(() => runner(resolve));\n          }\n          return;\n        }\n        if (options?.postConsentTrigger === \"onNuxtReady\") {\n          const idleTimeout = options?.postConsentTrigger ? nuxtApp ? onNuxtReady : requestIdleCallback : (cb) => cb();\n          runner(() => idleTimeout(resolve));\n          return;\n        }\n        runner(resolve);\n      }\n    });\n    if (options?.consent) {\n      if (isRef(options?.consent)) {\n        watch(options.consent, (_val) => {\n          const val = toValue(_val);\n          consented.value = Boolean(val);\n        }, { immediate: true });\n      } else if (typeof options?.consent === \"boolean\") {\n        consented.value = options?.consent;\n      } else if (options?.consent instanceof Promise) {\n        options?.consent.then((res) => {\n          consented.value = typeof res === \"boolean\" ? res : true;\n        });\n      }\n    }\n  });\n  promise.accept = () => {\n    consented.value = true;\n  };\n  return promise;\n}\n","import { useScript as useScript$1 } from 'unhead/scripts';\nimport { getCurrentInstance, onMounted, isRef, watch, onScopeDispose, ref } from 'vue';\nimport { i as injectHead } from './vue.BYLJNEcq.mjs';\n\nfunction registerVueScopeHandlers(script, scope) {\n  if (!scope) {\n    return;\n  }\n  const _registerCb = (key, cb) => {\n    if (!script._cbs[key]) {\n      cb(script.instance);\n      return () => {\n      };\n    }\n    let i = script._cbs[key].push(cb);\n    const destroy = () => {\n      if (i) {\n        script._cbs[key]?.splice(i - 1, 1);\n        i = null;\n      }\n    };\n    onScopeDispose(destroy);\n    return destroy;\n  };\n  script.onLoaded = (cb) => _registerCb(\"loaded\", cb);\n  script.onError = (cb) => _registerCb(\"error\", cb);\n  onScopeDispose(() => {\n    script._triggerAbortController?.abort();\n  });\n}\nfunction useScript(_input, _options) {\n  const input = typeof _input === \"string\" ? { src: _input } : _input;\n  const options = _options || {};\n  const head = options?.head || injectHead();\n  options.head = head;\n  const scope = getCurrentInstance();\n  options.eventContext = scope;\n  if (scope && typeof options.trigger === \"undefined\") {\n    options.trigger = onMounted;\n  } else if (isRef(options.trigger)) {\n    const refTrigger = options.trigger;\n    let off;\n    options.trigger = new Promise((resolve) => {\n      off = watch(refTrigger, (val) => {\n        if (val) {\n          resolve(true);\n        }\n      }, {\n        immediate: true\n      });\n      onScopeDispose(() => resolve(false), true);\n    }).then((val) => {\n      off?.();\n      return val;\n    });\n  }\n  head._scriptStatusWatcher = head._scriptStatusWatcher || head.hooks.hook(\"script:updated\", ({ script: s }) => {\n    s._statusRef.value = s.status;\n  });\n  const script = useScript$1(head, input, options);\n  script._statusRef = script._statusRef || ref(script.status);\n  registerVueScopeHandlers(script, scope);\n  return new Proxy(script, {\n    get(_, key, a) {\n      return Reflect.get(_, key === \"status\" ? \"_statusRef\" : key, a);\n    }\n  });\n}\n\nexport { useScript as u };\n","import { defu } from \"defu\";\nimport { useScript as _useScript } from \"@unhead/vue/scripts\";\nimport { reactive } from \"vue\";\nimport { onNuxtReady, useNuxtApp, useRuntimeConfig, injectHead } from \"#imports\";\nfunction useNuxtScriptRuntimeConfig() {\n  return useRuntimeConfig().public[\"nuxt-scripts\"];\n}\nexport function resolveScriptKey(input) {\n  return input.key || input.src || (typeof input.innerHTML === \"string\" ? input.innerHTML : \"\");\n}\nexport function useScript(input, options) {\n  input = typeof input === \"string\" ? { src: input } : input;\n  options = defu(options, useNuxtScriptRuntimeConfig()?.defaultScriptOptions);\n  const id = String(resolveScriptKey(input));\n  const nuxtApp = useNuxtApp();\n  options.head = options.head || injectHead();\n  if (!options.head) {\n    throw new Error(\"useScript() has been called without Nuxt context.\");\n  }\n  nuxtApp.$scripts = nuxtApp.$scripts || reactive({});\n  const exists = !!nuxtApp.$scripts?.[id];\n  if (options.trigger === \"onNuxtReady\" || options.trigger === \"client\") {\n    if (!options.warmupStrategy) {\n      options.warmupStrategy = \"preload\";\n    }\n    if (options.trigger === \"onNuxtReady\") {\n      options.trigger = onNuxtReady;\n    }\n  }\n  const instance = _useScript(input, options);\n  const _remove = instance.remove;\n  instance.remove = () => {\n    nuxtApp.$scripts[id] = void 0;\n    return _remove();\n  };\n  nuxtApp.$scripts[id] = instance;\n  if (import.meta.dev && import.meta.client) {\n    let syncScripts = function() {\n      nuxtApp._scripts[instance.id] = payload;\n      nuxtApp.hooks.callHook(\"scripts:updated\", { scripts: nuxtApp._scripts });\n    };\n    if (exists) {\n      return instance;\n    }\n    const payload = {\n      ...options.devtools,\n      src: input.src,\n      $script: null,\n      events: []\n    };\n    nuxtApp._scripts = nuxtApp._scripts || {};\n    if (!nuxtApp._scripts[instance.id]) {\n      options.head.hooks.hook(\"script:updated\", (ctx) => {\n        if (ctx.script.id !== instance.id)\n          return;\n        payload.events.push({\n          type: \"status\",\n          status: ctx.script.status,\n          at: Date.now()\n        });\n        payload.$script = instance;\n        syncScripts();\n      });\n      options.head.hooks.hook(\"script:instance-fn\", (ctx) => {\n        if (ctx.script.id !== instance.id || String(ctx.fn).startsWith(\"__v_\"))\n          return;\n        payload.events.push({\n          type: \"fn-call\",\n          fn: ctx.fn,\n          at: Date.now()\n        });\n        syncScripts();\n      });\n      payload.$script = instance;\n      payload.events.push({\n        type: \"status\",\n        status: \"awaitingLoad\",\n        trigger: options?.trigger,\n        at: Date.now()\n      });\n      syncScripts();\n    }\n  }\n  return instance;\n}\n","const noop = Object.freeze(\n  Object.assign(\n    () => {\n    },\n    { __mock__: true }\n  )\n);\nexport const parse = noop;\nexport const object = noop;\nexport const array = noop;\nexport const string = noop;\nexport const number = noop;\nexport const boolean = noop;\nexport const optional = noop;\nexport const literal = noop;\nexport const union = noop;\nexport const record = noop;\nexport const any = noop;\nexport const minLength = noop;\nexport const pipe = noop;\nexport const custom = noop;\n","import { defu } from \"defu\";\nimport { useRuntimeConfig } from \"nuxt/app\";\nimport { useScript } from \"./composables/useScript.js\";\nimport { parse } from \"#nuxt-scripts-validator\";\nfunction validateScriptInputSchema(key, schema, options) {\n  if (import.meta.dev) {\n    try {\n      parse(schema, options);\n    } catch (_e) {\n      const e = _e;\n      console.error(e.issues.map((i) => `${key}.${i.path?.map((i2) => i2.key).join(\",\")}: ${i.message}`).join(\"\\n\"));\n    }\n  }\n}\nexport function scriptRuntimeConfig(key) {\n  return (useRuntimeConfig().public.scripts || {})[key];\n}\nexport function useRegistryScript(registryKey, optionsFn, _userOptions) {\n  const scriptConfig = scriptRuntimeConfig(registryKey);\n  const userOptions = Object.assign(_userOptions || {}, typeof scriptConfig === \"object\" ? scriptConfig : {});\n  const options = optionsFn(userOptions);\n  const scriptInput = defu(userOptions.scriptInput, options.scriptInput, { key: registryKey });\n  const scriptOptions = Object.assign(userOptions?.scriptOptions || {}, options.scriptOptions || {});\n  if (import.meta.dev) {\n    scriptOptions.devtools = defu(scriptOptions.devtools, { registryKey });\n    if (options.schema) {\n      const registryMeta = {};\n      for (const k in options.schema.entries) {\n        if (options.schema.entries[k].type !== \"optional\") {\n          registryMeta[k] = String(userOptions[k]);\n        }\n      }\n      scriptOptions.devtools.registryMeta = registryMeta;\n    }\n  }\n  const init = scriptOptions.beforeInit;\n  scriptOptions.beforeInit = () => {\n    if (import.meta.dev && !scriptOptions.skipValidation && options.schema) {\n      if (!userOptions.scriptInput?.src) {\n        validateScriptInputSchema(registryKey, options.schema, userOptions);\n      }\n    }\n    init?.();\n    if (import.meta.client) {\n      options.clientInit?.();\n    }\n  };\n  return useScript(scriptInput, scriptOptions);\n}\nexport function pick(obj, keys) {\n  const res = {};\n  for (const k of keys) {\n    if (k in obj) {\n      res[k] = obj[k];\n    }\n  }\n  return res;\n}\n","import { withQuery } from \"ufo\";\nimport { useRegistryScript } from \"#nuxt-scripts/utils\";\nimport { object, string, optional } from \"#nuxt-scripts-validator\";\nexport const GoogleAnalyticsOptions = object({\n  id: string(),\n  // The GA4 measurement ID (format: G-XXXXXXXX)\n  l: optional(string())\n  // Optional global name for dataLayer (defaults to 'dataLayer')\n});\nexport function useScriptGoogleAnalytics(_options) {\n  return useRegistryScript(_options?.key || \"googleAnalytics\", (options) => {\n    const dataLayerName = options?.l ?? \"dataLayer\";\n    const w = import.meta.client ? window : {};\n    return {\n      scriptInput: {\n        src: withQuery(\"https://www.googletagmanager.com/gtag/js\", { id: options?.id, l: options?.l })\n      },\n      schema: import.meta.dev ? GoogleAnalyticsOptions : void 0,\n      scriptOptions: {\n        use: () => {\n          return {\n            dataLayer: w[dataLayerName],\n            gtag: w.gtag\n          };\n        },\n        performanceMarkFeature: \"nuxt-third-parties-ga\",\n        tagPriority: 1\n      },\n      clientInit: import.meta.server ? void 0 : () => {\n        w[dataLayerName] = w[dataLayerName] || [];\n        w.gtag = function() {\n          w[dataLayerName].push(arguments);\n        };\n        _options?.onBeforeGtagStart?.(w.gtag);\n        w.gtag(\"js\", /* @__PURE__ */ new Date());\n        w.gtag(\"config\", options?.id);\n      }\n    };\n  }, _options);\n}\n","<template>\n  <Transition :css=\"false\" @leave=\"onLeave\">\n    <div v-if=\"!cookie && !isReject\" ref=\"el\" class=\"popup-cookies\">\n      <div ref=\"elContent\" class=\"content\">\n        <div class=\"text\">\n          <Text class=\"title\"> We value your privacy </Text>\n          <Text>\n            We use cookies to enhance your browsing experience, serve personalized ads or content, and analyze our traffic. By clicking \"Accept All,\"\n            you consent to our use of cookies.\n          </Text>\n        </div>\n\n        <div class=\"buttons\">\n          <button @click=\"handleOpenConfig()\">Configure</button>\n          <button @click=\"rejectCookies\">Reject All</button>\n          <button class=\"accept\" @click=\"acceptCookies\">Accept All</button>\n        </div>\n      </div>\n    </div>\n  </Transition>\n\n  <ClientOnly>\n    <Teleport to=\"body\">\n      <Transition name=\"fade\">\n        <div v-if=\"popupConfig\" class=\"cookies-config\">\n          <div class=\"content\">\n            <div class=\"modal-header\">\n              <Text class=\"title\" variant=\"heading2\">Cookies preferences</Text>\n              <button class=\"close\" type=\"button\" aria-label=\"Close\" @click=\"popupConfig = false\">\n                <IconClose />\n              </button>\n            </div>\n\n            <Text>\n              We use cookies to help you navigate efficiently and perform certain functions. You will find detailed information about all cookies\n              under each consent category below.\n              <br ><br >\n              The cookies that are categorized as \"Necessary\" are stored on your browser as they are essential for enabling the basic functionalities\n              of the site.\n              <br ><br >\n              We also use third-party cookies that help us analyze how you use this website, store your preferences, and provide the content and\n              advertisements that are relevant to you. These cookies will only be stored in your browser with your prior consent.\n              <br ><br >\n              You can choose to enable or disable some or all of these cookies, but disabling some of them may affect your browsing experience.\n            </Text>\n\n            <div class=\"cookies-type\">\n              <div class=\"cookies-item\">\n                <div class=\"info\">\n                  <Text class=\"title\" variant=\"body28\">Necessary</Text>\n                  <Text class=\"desc\" variant=\"body14\"\n                    >Required for core site functionality such as security, network management, and accessibility.</Text\n                  >\n                </div>\n                <Text class=\"color-purple\">Always Active</Text>\n              </div>\n\n              <div v-if=\"gaId\" class=\"cookies-item\">\n                <div class=\"info\">\n                  <Text class=\"title\" variant=\"body28\">Analytics</Text>\n                  <Text class=\"desc\" variant=\"body14\">\n                    Helps us understand how visitors interact with the site to improve content and performance.\n                  </Text>\n                </div>\n                <button\n                  class=\"switch\"\n                  :class=\"{ on: preferences.analytics }\"\n                  type=\"button\"\n                  role=\"switch\"\n                  :aria-checked=\"preferences.analytics\"\n                  @click=\"handleToggle('analytics')\"\n                  @keydown.enter.prevent=\"handleToggle('analytics')\"\n                  @keydown.space.prevent=\"handleToggle('analytics')\">\n                  <span class=\"knob\" />\n                </button>\n              </div>\n            </div>\n\n            <div class=\"config-buttons\">\n              <button class=\"reject\" type=\"button\" @click=\"handleRejectAll\">Reject All</button>\n              <button class=\"accept\" type=\"button\" @click=\"handleSavePreferences\">Accept</button>\n            </div>\n          </div>\n\n          <div class=\"overlay-black\" @click=\"popupConfig = false\" />\n        </div>\n      </Transition>\n    </Teleport>\n  </ClientOnly>\n\n  <ClientOnly>\n    <Teleport to=\"body\">\n      <Transition name=\"fade\">\n        <button\n          v-if=\"cookie || isReject\"\n          class=\"cookies-settings-btn\"\n          type=\"button\"\n          aria-label=\"Open cookie settings\"\n          @click=\"handleOpenConfigFromFab\">\n          <svg width=\"46\" height=\"46\" viewBox=\"0 0 46 46\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path\n              fill-rule=\"evenodd\"\n              clip-rule=\"evenodd\"\n              d=\"M39.766 10.454C40.2303 10.454 40.6052 10.831 40.6052 11.2933C40.6052 11.7595 40.2282 12.1366 39.766 12.1366C39.3017 12.1366 38.9267 11.7596 38.9267 11.2933C38.9267 10.829 39.3037 10.454 39.766 10.454ZM45.5519 23.6842C45.2642 35.7757 35.3733 45.4996 23.2326 45.4996C10.9091 45.4996 0.905273 35.4795 0.905273 23.1402C0.905273 11.5887 9.66921 2.07103 20.8992 0.904297C20.8734 1.15231 20.8595 1.4043 20.8595 1.66026C20.8595 5.15034 23.3119 8.06889 26.5819 8.78508C26.1355 9.73152 25.8855 10.7871 25.8855 11.9021C25.8855 15.9279 29.1514 19.1956 33.1693 19.1956C34.699 19.1956 36.1197 18.7234 37.2923 17.9159C37.961 21.2531 40.9074 23.7708 44.4349 23.7708C44.8159 23.7708 45.1889 23.7411 45.552 23.6835L45.5519 23.6842ZM7.82388 21.1962C6.80008 21.1962 5.96874 22.0275 5.96874 23.0553C5.96874 24.0791 6.80008 24.9104 7.82388 24.9104C8.84965 24.9104 9.68303 24.0791 9.68303 23.0553C9.68303 22.0295 8.85169 21.1962 7.82388 21.1962ZM16.0641 34.6067C15.0403 34.6067 14.209 35.44 14.209 36.4658C14.209 37.4896 15.0403 38.325 16.0641 38.325C17.0879 38.325 17.9233 37.4917 17.9233 36.4658C17.9233 35.442 17.09 34.6067 16.0641 34.6067ZM36.2983 32.7277C35.2745 32.7277 34.4391 33.5591 34.4391 34.5869C34.4391 35.6107 35.2725 36.442 36.2983 36.442C37.3221 36.442 38.1574 35.6107 38.1574 34.5869C38.1574 33.5611 37.3241 32.7277 36.2983 32.7277ZM15.2326 26.4065C14.7684 26.4065 14.3934 26.7835 14.3934 27.2457C14.3934 27.71 14.7704 28.085 15.2326 28.085C15.6989 28.085 16.0759 27.708 16.0759 27.2457C16.0759 26.7814 15.6989 26.4065 15.2326 26.4065ZM19.2108 16.7059C18.7465 16.7059 18.3715 17.0829 18.3715 17.5492C18.3715 18.0135 18.7485 18.3884 19.2108 18.3884C19.6771 18.3884 20.0541 18.0114 20.0541 17.5492C20.0541 17.0829 19.6771 16.7059 19.2108 16.7059ZM25.9369 35.9064C25.4726 35.9064 25.0976 36.2834 25.0976 36.7497C25.0976 37.214 25.4746 37.5889 25.9369 37.5889C26.4012 37.5889 26.7762 37.212 26.7762 36.7497C26.7762 36.2834 26.3992 35.9064 25.9369 35.9064ZM36.3674 25.0355C35.9031 25.0355 35.5241 25.4125 35.5241 25.8788C35.5241 26.3431 35.9031 26.7181 36.3674 26.7181C36.8316 26.7181 37.2066 26.3411 37.2066 25.8788C37.2066 25.4126 36.8296 25.0355 36.3674 25.0355ZM15.6588 9.25955C14.633 9.25955 13.7996 10.0909 13.7996 11.1187C13.7996 12.1425 14.631 12.9738 15.6588 12.9738C16.6826 12.9738 17.5139 12.1425 17.5139 11.1187C17.5139 10.0929 16.6826 9.25955 15.6588 9.25955ZM25.8531 23.6824C24.8293 23.6824 23.9939 24.5137 23.9939 25.5416C23.9939 26.5653 24.8273 27.3967 25.8531 27.3967C26.8769 27.3967 27.7122 26.5653 27.7122 25.5416C27.7122 24.5158 26.8789 23.6824 25.8531 23.6824ZM34.006 2.3572C35.3929 2.3572 36.5159 3.4802 36.5159 4.86712C36.5159 6.25206 35.3929 7.37505 34.006 7.37505C32.621 7.37505 31.498 6.25206 31.498 4.86712C31.498 3.4802 32.621 2.3572 34.006 2.3572ZM42.647 4.32149C43.2581 4.32149 43.7541 4.81752 43.7541 5.42666C43.7541 6.03578 43.2581 6.53183 42.647 6.53183C42.0379 6.53183 41.5418 6.0358 41.5418 5.42666C41.5418 4.81754 42.0378 4.32149 42.647 4.32149Z\"\n              fill=\"#6F72EE\" />\n          </svg>\n        </button>\n      </Transition>\n    </Teleport>\n  </ClientOnly>\n</template>\n\n<script setup>\nimport gsap from 'gsap';\n\nconst runtimeConfig = useRuntimeConfig();\nconst gaId = computed(() => runtimeConfig.public.scripts.googleAnalytics.id);\n\nconst cookie = useCookie('accept-cookies');\nconst isReject = ref(false);\n\nconst popupConfig = ref(false);\n\nconst cookiePreferences = gaId.value\n  ? useCookie('cookie-preferences', {\n      default: () => ({ analytics: false }),\n      path: '/',\n    })\n  : ref({ analytics: null });\n\nconst preferences = reactive({\n  necessary: true,\n  analytics: gaId.value ? (cookiePreferences.value?.analytics ?? false) : null,\n});\n\nif (gaId.value) {\n  const consentTrigger = useScriptTriggerConsent();\n\n  const ga = useScriptGoogleAnalytics({\n    scriptOptions: {\n      trigger: consentTrigger,\n    },\n  });\n\n  watch(cookiePreferences, (value) => {\n    if (value.analytics) {\n      consentTrigger.accept();\n      ga?.load();\n    } else {\n      ga?.remove();\n    }\n  });\n}\n\nconst nuxtApp = useNuxtApp();\nconst lenis = nuxtApp.$lenis;\n\nwatch(popupConfig, (isOpen) => {\n  if (!lenis) return;\n  if (isOpen) {\n    lenis.pause();\n  } else {\n    lenis.resume();\n  }\n});\n\nfunction handleToggle(key) {\n  if (key === 'necessary') return;\n  preferences[key] = !preferences[key];\n  cookiePreferences.value = {\n    analytics: preferences.analytics,\n  };\n}\n\nconst acceptCookies = () => {\n  cookie.value = true;\n  // Accept all optional categories\n  preferences.analytics = true;\n  cookiePreferences.value = { analytics: true };\n};\n\nconst rejectCookies = () => {\n  cookie.value = false;\n  isReject.value = true;\n  // Reject all optional categories\n  preferences.analytics = false;\n  cookiePreferences.value = { analytics: false };\n};\n\nfunction handleOpenConfig() {\n  popupConfig.value = true;\n}\n\nfunction handleOpenConfigFromFab() {\n  popupConfig.value = true;\n}\n\nconst handleSavePreferences = () => {\n  cookie.value = true;\n  cookiePreferences.value = {\n    analytics: preferences.analytics,\n  };\n  popupConfig.value = false;\n};\n\nconst handleRejectAll = () => {\n  rejectCookies();\n  popupConfig.value = false;\n};\n\nconst el = useTemplateRef('el');\n\nconst isPreloadDone = usePreloadDone();\n\nlet ctx;\n\nconst onLeave = (el, done) => {\n  ctx = gsap.context(() => {\n    if (el) {\n      gsap.to(el, {\n        yPercent: 120,\n        duration: 1.2,\n        ease: 'expo.inOut',\n        overwrite: true,\n        onComplete: done,\n      });\n    }\n  }, el.value);\n};\n\nonKeyStroke('Escape', () => {\n  if (!popupConfig.value) return;\n  popupConfig.value = false;\n});\n\nonMounted(() => {\n  if (cookie.value === true) return;\n\n  ctx = gsap.context(() => {\n    const tl = gsap.timeline({\n      paused: true,\n      delay: 1.3,\n    });\n\n    tl.from(el.value, {\n      yPercent: 120,\n      duration: 1.4,\n      ease: 'expo.out',\n    });\n\n    watch(isPreloadDone, (value) => {\n      if (value) {\n        tl.play();\n      }\n    });\n  }, el.value);\n});\n\nonUnmounted(() => {\n  ctx?.revert();\n  // Ensure scrolling is resumed if component unmounts while paused\n  if (lenis) {\n    lenis.resume();\n  }\n});\n</script>\n\n<style scoped lang=\"scss\">\n.popup-cookies {\n  position: fixed;\n  z-index: 50;\n  bottom: calc(fn.toVw(15) * 2);\n  left: fn.toVw(15);\n\n  width: calc(100% - fn.toVw(15) * 2);\n  border-radius: fn.toVw(10);\n\n  font-size: fn.toVw(16);\n  font-weight: 300;\n  line-height: calc(24 / 16);\n\n  &:hover {\n    .content {\n      background-color: $color-secondary;\n    }\n\n    .link {\n      &::before {\n        transform-origin: right;\n        transform: scale3d(0, 1, 1);\n      }\n    }\n  }\n\n  .content {\n    overflow: hidden;\n    display: flex;\n    gap: fn.toVw(20);\n    align-items: flex-start;\n    justify-content: space-between;\n\n    padding: fn.toVw(43) fn.toVw(60);\n    border-radius: fn.toVw(10);\n\n    background: $color-background;\n    box-shadow: 0 fn.toVw(20) fn.toVw(60) rgb(16 24 40 / 8%);\n\n    @include mx.mobile {\n      flex-direction: column;\n      padding: fn.toVw(20) fn.toVw(30);\n    }\n\n    .text {\n      width: 100%;\n      max-width: fn.toVw(1300);\n\n      .title {\n        font-weight: 400;\n      }\n    }\n  }\n\n  .buttons {\n    display: flex;\n    gap: fn.toVw(10);\n    font-weight: 400;\n\n    @include mx.mobile {\n      flex-direction: column;\n      width: 100%;\n    }\n\n    button {\n      cursor: pointer;\n\n      padding: fn.toVw(13) fn.toVw(44);\n      border: 1px solid #c0c0c0;\n      border-radius: fn.toVw(8.7);\n\n      font-size: fn.toVw(14);\n      white-space: nowrap;\n\n      transition: background-color 0.3s ease;\n\n      @include mx.mobile {\n        width: 100%;\n      }\n\n      &:hover {\n        background-color: #eeeeee;\n      }\n\n      &.accept {\n        border-color: #6f72ee;\n        color: $color-background;\n        background: #6f72ee;\n\n        &:hover {\n          background-color: #6567da;\n        }\n      }\n    }\n  }\n}\n\n.cookies-config {\n  position: fixed;\n  z-index: 9999;\n  inset: 0;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  width: 100%;\n  height: 100dvh;\n\n  .overlay-black {\n    pointer-events: inherit;\n  }\n\n  .content {\n    position: relative;\n    z-index: 2;\n\n    overflow-y: auto;\n\n    width: 80%;\n    max-height: 80%;\n    padding: fn.toVw(30) fn.toVw(50);\n    border-radius: fn.toVw(30);\n\n    background-color: $color-background;\n\n    @include mx.mobile {\n      width: 94%;\n      max-height: 90%;\n      padding: fn.toVw(16) fn.toVw(20);\n      border-radius: fn.toVw(18);\n\n      font-size: fn.toVw(12);\n    }\n\n    .title {\n      margin-bottom: fn.toVw(10);\n    }\n\n    .modal-header {\n      display: flex;\n      align-items: flex-start;\n      justify-content: space-between;\n      margin-bottom: fn.toVw(20);\n\n      .close {\n        cursor: pointer;\n\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n\n        width: fn.toVw(24);\n        height: fn.toVw(24);\n\n        background: $color-background;\n\n        transition: background-color 0.3s ease;\n      }\n    }\n\n    .cookies-type {\n      display: flex;\n      flex-direction: column;\n      gap: fn.toVw(14);\n      margin-top: fn.toVw(30);\n\n      .cookies-item {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n\n        padding: fn.toVw(14) fn.toVw(18);\n        border: 1px solid #e9e9e9;\n        border-radius: fn.toVw(12);\n\n        @include mx.mobile {\n          flex-direction: column;\n          gap: fn.toVw(10);\n          align-items: flex-start;\n        }\n\n        .info {\n          display: flex;\n          flex-direction: column;\n\n          .desc {\n            max-width: fn.toVw(880);\n            color: $color-gray;\n          }\n        }\n      }\n\n      .switch {\n        cursor: pointer;\n\n        position: relative;\n\n        width: fn.toVw(52);\n        height: fn.toVw(30);\n        border-radius: fn.toVw(20);\n\n        background-color: #d9d9d9;\n\n        transition: background-color 0.25s ease;\n\n        &.on {\n          background-color: #6f72ee;\n        }\n\n        &.disabled {\n          cursor: not-allowed;\n          background-color: #bfbfbf;\n        }\n\n        .knob {\n          position: absolute;\n          top: 50%;\n          left: fn.toVw(4);\n          transform: translateY(-50%);\n\n          width: fn.toVw(22);\n          height: fn.toVw(22);\n          border-radius: 50%;\n\n          background-color: $color-background;\n          box-shadow: 0 2px 6px rgb(0 0 0 / 20%);\n\n          transition: left 0.25s ease;\n        }\n\n        &.on .knob {\n          left: calc(100% - fn.toVw(26));\n        }\n\n        @include mx.mobile {\n          align-self: flex-start;\n        }\n      }\n    }\n\n    .config-buttons {\n      display: flex;\n      gap: fn.toVw(10);\n      justify-content: flex-end;\n      margin-top: fn.toVw(24);\n\n      button {\n        cursor: pointer;\n\n        padding: fn.toVw(13) fn.toVw(44);\n        border: 1px solid #c0c0c0;\n        border-radius: fn.toVw(8.7);\n\n        font-size: fn.toVw(14);\n        white-space: nowrap;\n\n        transition: background-color 0.3s ease;\n\n        &:hover {\n          background-color: #eeeeee;\n        }\n\n        &.accept {\n          border-color: #6f72ee;\n          color: $color-background;\n          background: #6f72ee;\n\n          &:hover {\n            background-color: #6567da;\n          }\n        }\n      }\n\n      @include mx.mobile {\n        gap: fn.toVw(8);\n        justify-content: stretch;\n\n        button {\n          flex: 1;\n          padding: fn.toVw(12) fn.toVw(16);\n        }\n      }\n    }\n  }\n}\n\n.cookies-settings-btn {\n  cursor: pointer;\n\n  position: fixed;\n  z-index: 60;\n  bottom: fn.toVw(20);\n  left: fn.toVw(20);\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  width: fn.toVw(60);\n  height: fn.toVw(60);\n  border: 1px solid #e9e9e9;\n  border-radius: 50%;\n\n  background: $color-background;\n\n  svg {\n    width: fn.toVw(30);\n  }\n\n  @include mx.mobile {\n    bottom: fn.toVw(14);\n    left: fn.toVw(14);\n    width: fn.toVw(52);\n    height: fn.toVw(52);\n\n    svg {\n      width: fn.toVw(28);\n    }\n  }\n}\n</style>\n","import { defineAsyncComponent } from 'vue'\nexport default {\n  default: defineAsyncComponent(() => import(\"/Users/marina/Trabajos/Pia/solstrategies/repository/app/layouts/default.vue\").then(m => m.default || m))\n}","import { Suspense, computed, defineComponent, h, inject, mergeProps, nextTick, onMounted, provide, shallowReactive, shallowRef, unref } from \"vue\";\nimport { useRoute, useRouter } from \"../composables/router.js\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { _wrapInTransition } from \"./utils.js\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"./injections.js\";\nimport { useRoute as useVueRouterRoute } from \"#build/pages\";\nimport layouts from \"#build/layouts\";\nimport { appLayoutTransition as defaultLayoutTransition } from \"#build/nuxt.config.mjs\";\nconst LayoutLoader = defineComponent({\n  name: \"LayoutLoader\",\n  inheritAttrs: false,\n  props: {\n    name: String,\n    layoutProps: Object\n  },\n  setup(props, context) {\n    return () => h(layouts[props.name], props.layoutProps, context.slots);\n  }\n});\nconst nuxtLayoutProps = {\n  name: {\n    type: [String, Boolean, Object],\n    default: null\n  },\n  fallback: {\n    type: [String, Object],\n    default: null\n  }\n};\nexport default defineComponent({\n  name: \"NuxtLayout\",\n  inheritAttrs: false,\n  props: nuxtLayoutProps,\n  setup(props, context) {\n    const nuxtApp = useNuxtApp();\n    const injectedRoute = inject(PageRouteSymbol);\n    const shouldUseEagerRoute = !injectedRoute || injectedRoute === useRoute();\n    const route = shouldUseEagerRoute ? useVueRouterRoute() : injectedRoute;\n    const layout = computed(() => {\n      let layout2 = unref(props.name) ?? route?.meta.layout ?? \"default\";\n      if (layout2 && !(layout2 in layouts)) {\n        if (import.meta.dev && layout2 !== \"default\") {\n          console.warn(`Invalid layout \\`${layout2}\\` selected.`);\n        }\n        if (props.fallback) {\n          layout2 = unref(props.fallback);\n        }\n      }\n      return layout2;\n    });\n    const layoutRef = shallowRef();\n    context.expose({ layoutRef });\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    let lastLayout;\n    return () => {\n      const hasLayout = layout.value && layout.value in layouts;\n      const transitionProps = route?.meta.layoutTransition ?? defaultLayoutTransition;\n      const previouslyRenderedLayout = lastLayout;\n      lastLayout = layout.value;\n      return _wrapInTransition(hasLayout && transitionProps, {\n        default: () => h(Suspense, { suspensible: true, onResolve: () => {\n          nextTick(done);\n        } }, {\n          default: () => h(\n            LayoutProvider,\n            {\n              layoutProps: mergeProps(context.attrs, { ref: layoutRef }),\n              key: layout.value || void 0,\n              name: layout.value,\n              shouldProvide: !props.name,\n              isRenderingNewLayout: (name) => {\n                return name !== previouslyRenderedLayout && name === layout.value;\n              },\n              hasTransition: !!transitionProps\n            },\n            context.slots\n          )\n        })\n      }).default();\n    };\n  }\n});\nconst LayoutProvider = defineComponent({\n  name: \"NuxtLayoutProvider\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: [String, Boolean]\n    },\n    layoutProps: {\n      type: Object\n    },\n    hasTransition: {\n      type: Boolean\n    },\n    shouldProvide: {\n      type: Boolean\n    },\n    isRenderingNewLayout: {\n      type: Function,\n      required: true\n    }\n  },\n  setup(props, context) {\n    const name = props.name;\n    if (props.shouldProvide) {\n      provide(LayoutMetaSymbol, {\n        isCurrent: (route) => name === (route.meta.layout ?? \"default\")\n      });\n    }\n    const injectedRoute = inject(PageRouteSymbol);\n    const isNotWithinNuxtPage = injectedRoute && injectedRoute === useRoute();\n    if (isNotWithinNuxtPage) {\n      const vueRouterRoute = useVueRouterRoute();\n      const reactiveChildRoute = {};\n      for (const _key in vueRouterRoute) {\n        const key = _key;\n        Object.defineProperty(reactiveChildRoute, key, {\n          enumerable: true,\n          get: () => {\n            return props.isRenderingNewLayout(props.name) ? vueRouterRoute[key] : injectedRoute[key];\n          }\n        });\n      }\n      provide(PageRouteSymbol, shallowReactive(reactiveChildRoute));\n    }\n    let vnode;\n    if (import.meta.dev && import.meta.client) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            if (name) {\n              console.warn(`[nuxt] \\`${name}\\` layout does not have a single root node and will cause errors when navigating between routes.`);\n            } else {\n              console.warn(\"[nuxt] `<NuxtLayout>` needs to be passed a single root node in its default slot.\");\n            }\n          }\n        });\n      });\n    }\n    return () => {\n      if (!name || typeof name === \"string\" && !(name in layouts)) {\n        if (import.meta.dev && import.meta.client && props.hasTransition) {\n          vnode = context.slots.default?.();\n          return vnode;\n        }\n        return context.slots.default?.();\n      }\n      if (import.meta.dev && import.meta.client && props.hasTransition) {\n        vnode = h(\n          LayoutLoader,\n          { key: name, layoutProps: props.layoutProps, name },\n          context.slots\n        );\n        return vnode;\n      }\n      return h(\n        LayoutLoader,\n        { key: name, layoutProps: props.layoutProps, name },\n        context.slots\n      );\n    };\n  }\n});\n","import { defineComponent, h, nextTick, onMounted, provide, shallowReactive } from \"vue\";\nimport { PageRouteSymbol } from \"./injections.js\";\nexport const defineRouteProvider = (name = \"RouteProvider\") => defineComponent({\n  name,\n  props: {\n    route: {\n      type: Object,\n      required: true\n    },\n    vnode: Object,\n    vnodeRef: Object,\n    renderKey: String,\n    trackRootNodes: Boolean\n  },\n  setup(props) {\n    const previousKey = props.renderKey;\n    const previousRoute = props.route;\n    const route = {};\n    for (const key in props.route) {\n      Object.defineProperty(route, key, {\n        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key],\n        enumerable: true\n      });\n    }\n    provide(PageRouteSymbol, shallowReactive(route));\n    let vnode;\n    if (import.meta.dev && import.meta.client && props.trackRootNodes) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = vnode?.type?.__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (!props.vnode) {\n        return props.vnode;\n      }\n      if (import.meta.dev && import.meta.client) {\n        vnode = h(props.vnode, { ref: props.vnodeRef });\n        return vnode;\n      }\n      return h(props.vnode, { ref: props.vnodeRef });\n    };\n  }\n});\nexport const RouteProvider = defineRouteProvider();\n","import { Fragment, Suspense, defineComponent, h, inject, nextTick, onBeforeUnmount, ref, watch } from \"vue\";\nimport { RouterView } from \"vue-router\";\nimport { defu } from \"defu\";\nimport { generateRouteKey, toArray, wrapInKeepAlive } from \"./utils.js\";\nimport { RouteProvider, defineRouteProvider } from \"#app/components/route-provider\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { useRouter } from \"#app/composables/router\";\nimport { _wrapInTransition } from \"#app/components/utils\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"#app/components/injections\";\nimport { appKeepalive as defaultKeepaliveConfig, appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nconst _routeProviders = import.meta.dev ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new WeakMap();\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs, slots, expose }) {\n    const nuxtApp = useNuxtApp();\n    const pageRef = ref();\n    const forkRoute = inject(PageRouteSymbol, null);\n    let previousPageKey;\n    expose({ pageRef });\n    const _layoutMeta = inject(LayoutMetaSymbol, null);\n    let vnode;\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (import.meta.client && props.pageKey) {\n      watch(() => props.pageKey, (next, prev) => {\n        if (next !== prev) {\n          nuxtApp.callHook(\"page:loading:start\");\n        }\n      });\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtPageUsed = true;\n    }\n    let pageLoadingEndHookAlreadyCalled = false;\n    if (import.meta.client) {\n      const unsub = useRouter().beforeResolve(() => {\n        pageLoadingEndHookAlreadyCalled = false;\n      });\n      onBeforeUnmount(() => {\n        unsub();\n      });\n    }\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: import.meta.server ? (routeProps) => {\n          return h(Suspense, { suspensible: true }, {\n            default() {\n              return h(RouteProvider, {\n                vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,\n                route: routeProps.route,\n                vnodeRef: pageRef\n              });\n            }\n          });\n        } : (routeProps) => {\n          const isRenderingNewRouteInOldFork = haveParentRoutesRendered(forkRoute, routeProps.route, routeProps.Component);\n          const hasSameChildren = forkRoute && forkRoute.matched.length === routeProps.route.matched.length;\n          if (!routeProps.Component) {\n            if (vnode && !hasSameChildren) {\n              return vnode;\n            }\n            done();\n            return;\n          }\n          if (vnode && _layoutMeta && !_layoutMeta.isCurrent(routeProps.route)) {\n            return vnode;\n          }\n          if (isRenderingNewRouteInOldFork && forkRoute && (!_layoutMeta || _layoutMeta?.isCurrent(forkRoute))) {\n            if (hasSameChildren) {\n              return vnode;\n            }\n            return null;\n          }\n          const key = generateRouteKey(routeProps, props.pageKey);\n          const willRenderAnotherChild = hasChildrenRoutes(forkRoute, routeProps.route, routeProps.Component);\n          if (!nuxtApp.isHydrating && previousPageKey === key && !willRenderAnotherChild) {\n            nextTick(() => {\n              pageLoadingEndHookAlreadyCalled = true;\n              nuxtApp.callHook(\"page:loading:end\");\n            });\n          }\n          previousPageKey = key;\n          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition);\n          const transitionProps = hasTransition && _mergeTransitionProps([\n            props.transition,\n            routeProps.route.meta.pageTransition,\n            defaultPageTransition,\n            {\n              onAfterLeave() {\n                delete nuxtApp._runningTransition;\n                nuxtApp.callHook(\"page:transition:finish\", routeProps.Component);\n              }\n            }\n          ]);\n          const keepaliveConfig = props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig;\n          vnode = _wrapInTransition(\n            hasTransition && transitionProps,\n            wrapInKeepAlive(\n              keepaliveConfig,\n              h(Suspense, {\n                suspensible: true,\n                onPending: () => {\n                  if (hasTransition) {\n                    nuxtApp._runningTransition = true;\n                  }\n                  nuxtApp.callHook(\"page:start\", routeProps.Component);\n                },\n                onResolve: () => {\n                  nextTick(() => nuxtApp.callHook(\"page:finish\", routeProps.Component).then(() => {\n                    delete nuxtApp._runningTransition;\n                    if (!pageLoadingEndHookAlreadyCalled && !willRenderAnotherChild) {\n                      pageLoadingEndHookAlreadyCalled = true;\n                      return nuxtApp.callHook(\"page:loading:end\");\n                    }\n                  }).finally(done));\n                }\n              }, {\n                default: () => {\n                  const routeProviderProps = {\n                    key: key || void 0,\n                    vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,\n                    route: routeProps.route,\n                    renderKey: key || void 0,\n                    trackRootNodes: hasTransition,\n                    vnodeRef: pageRef\n                  };\n                  if (!keepaliveConfig) {\n                    return h(RouteProvider, routeProviderProps);\n                  }\n                  const routerComponentType = routeProps.Component.type;\n                  const routeProviderKey = import.meta.dev ? routerComponentType.name || routerComponentType.__name : routerComponentType;\n                  let PageRouteProvider = _routeProviders.get(routeProviderKey);\n                  if (!PageRouteProvider) {\n                    PageRouteProvider = defineRouteProvider(routerComponentType.name || routerComponentType.__name);\n                    _routeProviders.set(routeProviderKey, PageRouteProvider);\n                  }\n                  return h(PageRouteProvider, routeProviderProps);\n                }\n              })\n            )\n          ).default();\n          return vnode;\n        }\n      });\n    };\n  }\n});\nfunction _mergeTransitionProps(routeProps) {\n  const _props = routeProps.filter(Boolean).map((prop) => ({\n    ...prop,\n    onAfterLeave: prop.onAfterLeave ? toArray(prop.onAfterLeave) : void 0\n  }));\n  return defu(..._props);\n}\nfunction haveParentRoutesRendered(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  if (!index || index === -1) {\n    return false;\n  }\n  return newRoute.matched.slice(0, index).some(\n    (c, i) => c.components?.default !== fork.matched[i]?.components?.default\n  ) || Component && generateRouteKey({ route: newRoute, Component }) !== generateRouteKey({ route: fork, Component });\n}\nfunction hasChildrenRoutes(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  return index < newRoute.matched.length - 1;\n}\nfunction normalizeSlot(slot, data) {\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? h(slotContent[0]) : h(Fragment, void 0, slotContent);\n}\n","import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  fill: \"none\",\n  viewBox: \"0 0 8 9\"\n}\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(\"svg\", _hoisted_1, [...(_cache[0] || (_cache[0] = [\n    _createElementVNode(\"path\", {\n      fill: \"#FA974C\",\n      d: \"M4.354.146a.5.5 0 0 0-.708 0L.464 3.328a.5.5 0 1 0 .708.708L4 1.207l2.828 2.829a.5.5 0 0 0 .708-.708L4.354.146ZM4 9h.5V.5h-1V9H4Z\"\n    }, null, -1)\n  ]))]))\n}\nexport default { render: render }","import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  fill: \"none\",\n  viewBox: \"0 0 21 20\"\n}\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(\"svg\", _hoisted_1, [...(_cache[0] || (_cache[0] = [\n    _createElementVNode(\"path\", {\n      fill: \"#000\",\n      d: \"M16 .892H19.1l-6.776 7.745 7.972 10.54h-6.242l-4.89-6.393-5.594 6.393H.467l7.249-8.285-7.648-10h6.4l4.42 5.842L15.999.892ZM14.91 17.32h1.72L5.534 2.65H3.69l11.22 14.67Z\"\n    }, null, -1)\n  ]))]))\n}\nexport default { render: render }","import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nconst _hoisted_1 = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  fill: \"none\",\n  viewBox: \"0 0 23 23\"\n}\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(\"svg\", _hoisted_1, [...(_cache[0] || (_cache[0] = [\n    _createElementVNode(\"path\", {\n      fill: \"#000\",\n      d: \"M20.434 0H1.63C.73 0 0 .711 0 1.59v18.883c0 .88.728 1.595 1.63 1.595h18.804c.901 0 1.634-.716 1.634-1.59V1.59c0-.879-.733-1.59-1.634-1.59ZM6.547 18.805H3.271V8.271h3.276v10.534ZM4.91 6.835a1.897 1.897 0 1 1-.006-3.794 1.897 1.897 0 0 1 .006 3.795Zm13.896 11.97h-3.271v-5.12c0-1.22-.022-2.793-1.703-2.793-1.702 0-1.96 1.332-1.96 2.707v5.206H8.602V8.271h3.138v1.44h.043c.435-.828 1.504-1.703 3.095-1.703 3.314 0 3.926 2.181 3.926 5.017v5.78Z\"\n    }, null, -1)\n  ]))]))\n}\nexport default { render: render }","<template>\n  <footer id=\"footer\" ref=\"el\">\n    <div class=\"scroll color-gray\" @click=\"scrollToTop\">\n      <Text class=\"link color-gray\" variant=\"body12\">Back to Top</Text>\n      <IconArrow />\n    </div>\n\n    <div class=\"top\">\n      <div class=\"logo\">\n        <TextLogo :is-footer=\"true\" />\n      </div>\n    </div>\n\n    <div class=\"center\">\n      <div class=\"links\">\n        <Text class=\"subtitle\" variant=\"body18\">Company</Text>\n\n        <ul>\n          <li><NuxtLink class=\"link\" to=\"/\">About SOL Strategies</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Leadership Team</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Careers</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Contact Us</NuxtLink></li>\n        </ul>\n      </div>\n\n      <div class=\"links\">\n        <Text class=\"subtitle\" variant=\"body18\">Solutions</Text>\n\n        <ul>\n          <li><NuxtLink class=\"link\" to=\"/\">Institutional Staking</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Validator Services</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">White-Label Solutions</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">ETF Services</NuxtLink></li>\n        </ul>\n      </div>\n\n      <div class=\"links\">\n        <Text class=\"subtitle\" variant=\"body18\">Resources</Text>\n\n        <ul>\n          <li><NuxtLink class=\"link\" to=\"/\">Press Releases</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">News</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Research</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Educational Content</NuxtLink></li>\n        </ul>\n      </div>\n\n      <div class=\"links\">\n        <Text class=\"subtitle\" variant=\"body18\">Investors</Text>\n\n        <ul>\n          <li><NuxtLink class=\"link\" to=\"/\">Stock Information</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Financial Reports</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">SEC Filings</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">IR Contact</NuxtLink></li>\n        </ul>\n      </div>\n\n      <div class=\"links\">\n        <Text class=\"subtitle\" variant=\"body18\">Legal & Compliance</Text>\n\n        <ul>\n          <li><NuxtLink class=\"link\" to=\"/\">Trust Center</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Privacy Policy</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Terms of Service</NuxtLink></li>\n          <li><NuxtLink class=\"link\" to=\"/\">Regulatory Disclosures</NuxtLink></li>\n        </ul>\n      </div>\n    </div>\n\n    <div class=\"separator\">\n      <Text class=\"copyright\">© {{ new Date().getFullYear() }} SOL Strategies Inc</Text>\n\n      <div class=\"address\">\n        <NuxtLink class=\"link active\"> <b>Investor Relations Contact</b> </NuxtLink>\n        <br >\n        <br >\n        <Text>\n          ICR<br >\n          <b>John Ragozzino, CFA</b><br >\n          <a class=\"link active\" href=\"mailto:solstrategies@icrinc.com\">solstrategies@icrinc.com</a><br >\n          Tel: 203-682-8284\n        </Text>\n      </div>\n\n      <div class=\"social\">\n        <ul>\n          <li>\n            <NuxtLink to=\"/\" :external=\"true\" target=\"_blank\" aria-label=\"Twitter\"><IconTwitter /></NuxtLink>\n          </li>\n          <li>\n            <NuxtLink to=\"/\" :external=\"true\" target=\"_blank\" aria-label=\"LinkedIn\"><IconLinkedin /></NuxtLink>\n          </li>\n        </ul>\n      </div>\n    </div>\n\n    <div class=\"bottom\">\n      <Text variant=\"body13\" class=\"color-gray\">\n        Legal Disclaimer<br ><br >\n        The information on the website is not intended to modify, qualify, supplement, or amend information disclosed under corporate and securities\n        legislation of any jurisdiction applicable to Sol Strategies and should not be used or relied upon for the purpose of making investment\n        decisions concerning any securities of Sol Strategies. If you are considering any investment in the securities of Sol Strategies, you are\n        advised to seek independent professional advice and refer to Sol Strategies' official disclosure documents which are made available to the\n        public in accordance with applicable securities laws and filed with the Canadian Securities Regulatory Authorities on SEDAR+ under Sol\n        Strategies' profile at www.sedar.com. Printed copies of public disclosure documents may also be obtained from Sol Strategies, upon request.\n        Sol Strategies assumes no responsibility for errors or omissions in the information or software or other documents which are referenced by or\n        linked to the website. Therefore, the website may include technical or other inaccuracies. This website contains statistical data, market\n        research and industry forecasts that were obtained, unless otherwise indicated, from independent industry and government publications and\n        reports or based on estimates derived from such publications and reports. While Sol Strategies believes this data and information to be\n        reliable, market and industry data and information is subject to variation and cannot be and therefore has not been verified due to limits on\n        the availability and reliability of raw data, the voluntary nature of the data gathering process and other limitations and uncertainties\n        inherent in any statistical survey. Sol Strategies has not participated in the preparation of such information contained herein.Sol Strategies\n        is an independent organization in the Solana ecosystem. Sol Strategies is not affiliated with, owned by, or under common control with Solana\n        Foundation (the \"Foundation\"), and the Foundation has not entered into any association, partnership, joint venture, employee, or agency\n        relationship with Sol Strategies. None of the Foundation or its council members, officers, agents or advisors (collectively, the \"Foundation\n        Parties\") make any representations or warranties, recommendations, endorsements or promises with the respect to the accuracy of any statements\n        made, information provided or action taken by Sol Strategies and expressly disclaim any and all liability arising from or related to any such\n        statements, information or action.<br ><br >\n\n        Stock Quotes<br ><br >\n        All stock quotes and historical stock price data provided on the Website are provided by third party service providers and are provided for\n        informational purposes only and are not intended for trading purposes. If you are contemplating trading in the securities of Sol Strategies,\n        we strongly advise you to seek independent professional advice before making any investment decision. Sol Strategies makes no representation\n        or warranty regarding the accuracy or completeness of any such stock price quotes or historical stock price data and has not taken any steps\n        to verify the adequacy, accuracy or completeness of the information provided herein.<br ><br >\n\n        CAUTIONARY NOTE REGARDING FORWARD-LOOKING STATEMENTS\n      </Text>\n    </div>\n  </footer>\n\n \n</template>\n\n<script setup>\nconst lenis = useNuxtApp().$lenis;\n\nconst scrollToTop = () => {\n  lenis.scrollTo(0, { force: true });\n};\n\nconst nuxtApp = useNuxtApp();\n\nconst el = useTemplateRef('el');\n\nlet ctx;\nlet ctxMotionFooter;\n\nconst motionFooter = () => {\n  ctxMotionFooter = gsap.context(() => {\n    ctxMotionFooter?.revert();\n\n    if (IS_MOBILE.value) return;\n\n    const tl = gsap.timeline({\n      defaults: {\n        ease: 'none',\n      },\n      scrollTrigger: {\n        trigger: el.value,\n        start: 'top bottom',\n        end: 'bottom bottom',\n        invalidateOnRefresh: true,\n        scrub: true,\n        refreshPriority: -1,\n      },\n    });\n\n    tl.set(el.value, {\n      yPercent: -50,\n    });\n\n    tl.to(el.value, {\n      yPercent: 0,\n    });\n  }, el.value);\n};\n\nonMounted(() => {\n  ctx = gsap.context(() => {\n    callOnce(() => {\n      motionFooter();\n    });\n\n    nuxtApp.hook('page:transition:finish', () => {\n      motionFooter();\n    });\n  }, el.value);\n});\n\nonUnmounted(() => {\n  ctxMotionFooter?.revert();\n  ctx?.revert();\n});\n</script>\n\n<style scoped lang=\"scss\">\n#footer {\n  position: relative;\n\n  overflow: hidden;\n\n  width: calc(100% - (fn.toVw(38) * 2));\n  margin-left: fn.toVw(38);\n  padding: fn.toVw(96) fn.toVw(30) 0 fn.toVw(30);\n  border-top-left-radius: fn.toVw(68);\n  border-top-right-radius: fn.toVw(68);\n\n  background-color: $color-neutral;\n\n  @include mx.mobile {\n    display: flex;\n    flex-direction: column;\n\n    width: calc(100% - (fn.toVw(35) * 2));\n    margin-bottom: fn.toVw(35);\n    padding: fn.toVw(32) fn.toVw(18) fn.toVw(50) fn.toVw(18);\n    border-top-left-radius: fn.toVw(8);\n    border-top-right-radius: fn.toVw(8);\n  }\n}\n\n.scroll {\n  cursor: pointer;\n\n  position: absolute;\n  top: fn.toVw(40);\n  right: fn.toVw(90);\n\n  display: flex;\n  gap: fn.toVw(12);\n  align-items: center;\n\n  text-transform: uppercase;\n\n  @include mx.mobile {\n    display: none;\n  }\n\n  &:deep(svg) {\n    width: fn.toVw(12.5);\n  }\n}\n\n.top {\n  padding-bottom: fn.toVw(63);\n\n  @include mx.mobile {\n    order: 2;\n    padding: fn.toVw(50) 0 fn.toVw(20) 0;\n  }\n\n  .logo {\n    width: 100%;\n    margin: 0 auto;\n\n    &:deep(.text-logo) {\n      margin: 0 auto;\n    }\n  }\n}\n\n.center {\n  display: flex;\n  justify-content: space-between;\n  padding: fn.toVw(28) fn.toVw(153) fn.toVw(78) fn.toVw(153);\n  border-top: 1px solid $color-neutral02;\n\n  @include mx.mobile {\n    flex-wrap: wrap;\n    row-gap: fn.toVw(26);\n    order: 1;\n\n    padding: 0;\n    padding-bottom: fn.toVw(47);\n    border-top: 0;\n    border-bottom: 1px solid $color-neutral02;\n  }\n}\n\n.separator {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n\n  padding: fn.toVw(15) fn.toVw(33);\n  border-radius: fn.toVw(10);\n\n  font-size: fn.toVw(14);\n  font-weight: 300;\n\n  background-color: $color-neutral02;\n\n  @include mx.mobile {\n    flex-direction: column;\n    gap: fn.toVw(36);\n    order: 3;\n\n    padding: 0;\n    border-radius: 0;\n\n    text-align: center;\n\n    background-color: initial;\n  }\n\n  .address {\n    max-width: fn.toVw(200);\n    font-size: fn.toVw(16);\n    font-weight: 300;\n    text-align: center;\n\n    b,\n    &:deep(b) {\n      font-weight: 400;\n    }\n  }\n\n  .copyright {\n    width: 100%;\n    max-width: fn.toVw(190);\n    text-align: left;\n  }\n\n  .social {\n    text-align: right;\n\n    ul {\n      display: flex;\n      gap: fn.toVw(100);\n\n      @include mx.mobile {\n        gap: fn.toVw(37);\n      }\n\n      li {\n        width: fn.toVw(20);\n        transition: opacity $transition-default;\n\n        &:hover {\n          opacity: 0.5;\n        }\n      }\n    }\n  }\n}\n\n.links {\n  width: 100%;\n  max-width: fn.toVw(180);\n\n  @include mx.mobile {\n    max-width: 50%;\n    padding-top: fn.toVw(34);\n    border-top: 1px solid $color-neutral02;\n\n    &:nth-child(-n + 2) {\n      padding-top: 0;\n      border-top: 0;\n    }\n\n    &:last-child {\n      max-width: 100%;\n    }\n  }\n\n  ul {\n    display: flex;\n    flex-direction: column;\n    gap: fn.toVw(18);\n\n    margin-top: fn.toVw(18);\n\n    font-size: fn.toVw(16);\n    color: $color-gray30;\n\n    @include mx.mobile {\n      gap: fn.toVw(9);\n      margin-top: fn.toVw(9);\n      font-size: fn.toVw(9);\n    }\n  }\n}\n\n.bottom {\n  padding: fn.toVw(33);\n\n  @include mx.mobile {\n    order: 4;\n    margin-top: fn.toVw(43);\n    padding: 0;\n  }\n}\n</style>\n","<script setup>\nimport variables from '~~/config/variables.json';\nimport seo from '~~/config/seo.json';\n\nconst lenis = useNuxtApp().$lenis;\n\nonMounted(() => {\n  useResizeReload();\n\n  lenis.scrollTo(0, {\n    duration: 0,\n    force: true,\n    immediate: true,\n  });\n});\n\nconst titleSite = seo.title;\nconst descriptionSite = seo.description;\nconst imageSite = seo.thumbnail;\n\nuseHead({\n  titleTemplate: `%s ― ${titleSite}`,\n});\n\nuseSeoMeta({\n  title: titleSite || seo.title,\n  ogTitle: titleSite || seo.title,\n  description: descriptionSite || seo.description,\n  ogDescription: descriptionSite || seo.description,\n  ogImage: imageSite || seo.thumbnail,\n  twitterCard: 'summary_large_image',\n});\n</script>\n\n<template>\n  <Html>\n    <Body>\n      <BaseHeader />\n\n      <BaseIndicator />\n\n      <BasePreloader />\n\n      <PopupCookies />\n\n      <!-- Layout -->\n      <NuxtLayout>\n        <NuxtPage />\n      </NuxtLayout>\n\n      <!-- Footer -->\n      <BaseFooter />\n    </Body>\n  </Html>\n</template>\n","<template>\n  <div>\n    <h1>{{ props.title }}</h1>\n    <p>{{ props.message }}</p>\n  </div>\n</template>\n\n<script setup>\nconst props = defineProps({\n  title: {\n    type: String,\n  },\n  message: {\n    type: String,\n  },\n});\n</script>\n","<template>\n  <div class=\"bg\">\n    <div class=\"container\">\n      <div v-if=\"DEV\" class=\"error-dev\">\n        <h2 class=\"statuscode\">{{ props?.error?.statusCode }}</h2>\n        <p class=\"message\">{{ props?.error?.message }}</p>\n        <pre v-if=\"props?.error?.stack\" class=\"stack\" v-html=\"props?.error?.stack\" />\n      </div>\n      <section class=\"error\">\n        <!-- 500 -->\n        <BaseError\n          v-if=\"props?.error?.statusCode === 500\"\n          title=\"Internal Server Error\"\n          message=\"Oops! Something Went Wrong, Please try again later\" />\n\n        <!-- 404 -->\n        <BaseError v-if=\"props?.error?.statusCode === 404\" title=\"Page Not Found\" message=\"Oops! Something Went Wrong, Please try again later\" />\n\n        <!-- 400 -->\n        <BaseError v-if=\"props?.error?.statusCode === 400\" title=\"Bad Request\" message=\"Oops! Something Went Wrong, Please try again later\" />\n\n        <div class=\"cta\">\n          <a href=\"/\">Go To Homepage</a>\n        </div>\n      </section>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { DEV } from '#imports';\nimport type { NuxtError } from '#app';\n\nconst props = defineProps({\n  error: Object as () => NuxtError,\n});\n</script>\n\n<style scoped lang=\"scss\">\n.bg {\n  width: 100%;\n  height: 100vh;\n  min-height: 100%;\n}\n\n.error {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n\n  height: 100vh;\n  min-height: 100%;\n  margin: 0;\n\n  text-align: center;\n\n  &:deep(.animation) {\n    max-width: 40rem;\n    margin: 4rem auto;\n  }\n\n  &:deep(h1) {\n    margin-bottom: 1rem;\n    text-transform: none;\n  }\n}\n\n.error-dev {\n  width: 100%;\n  margin-top: 2rem;\n}\n\n.statuscode {\n  font-size: 3rem;\n}\n\n.message {\n  margin-bottom: 1rem;\n}\n\n.stack {\n  padding: 2rem;\n  color: white;\n  white-space: normal;\n  background-color: black;\n}\n\n.cta {\n  margin-top: 2rem;\n\n  a {\n    text-decoration: underline;\n  }\n}\n</style>\n","<template>\n  <Suspense @resolve=\"onResolve\">\n    <div v-if=\"abortRender\" />\n    <ErrorComponent\n      v-else-if=\"error\"\n      :error=\"error\"\n    />\n    <IslandRenderer\n      v-else-if=\"islandContext\"\n      :context=\"islandContext\"\n    />\n    <component\n      :is=\"SingleRenderer\"\n      v-else-if=\"SingleRenderer\"\n    />\n    <AppComponent v-else />\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent, onErrorCaptured, onServerPrefetch, provide } from \"vue\";\nimport { useNuxtApp } from \"../nuxt\";\nimport { isNuxtError, showError, useError } from \"../composables/error\";\nimport { useRoute, useRouter } from \"../composables/router\";\nimport { PageRouteSymbol } from \"../components/injections\";\nimport AppComponent from \"#build/app-component.mjs\";\nimport ErrorComponent from \"#build/error-component.mjs\";\nimport { componentIslands } from \"#build/nuxt.config.mjs\";\nconst IslandRenderer = import.meta.server && componentIslands ? defineAsyncComponent(() => import(\"./island-renderer\").then((r) => r.default || r)) : () => null;\nconst nuxtApp = useNuxtApp();\nconst onResolve = nuxtApp.deferHydration();\nif (import.meta.client && nuxtApp.isHydrating) {\n  const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", onResolve);\n  useRouter().beforeEach(removeErrorHook);\n}\nconst url = import.meta.server ? nuxtApp.ssrContext.url : window.location.pathname;\nconst SingleRenderer = import.meta.test && import.meta.dev && import.meta.server && url.startsWith(\"/__nuxt_component_test__/\") && defineAsyncComponent(() => import(\"#build/test-component-wrapper.mjs\").then((r) => r.default(import.meta.server ? url : window.location.href)));\nprovide(PageRouteSymbol, useRoute());\nconst results = nuxtApp.hooks.callHookWith((hooks) => hooks.map((hook) => hook()), \"vue:setup\");\nif (import.meta.dev && results && results.some((i) => i && \"then\" in i)) {\n  console.error(\"[nuxt] Error in `vue:setup`. Callbacks must be synchronous.\");\n}\nconst error = useError();\nconst abortRender = import.meta.server && error.value && !nuxtApp.ssrContext.error;\nconst BOT_RE = /bot\\b|chrome-lighthouse|facebookexternalhit|google\\b/i;\nonErrorCaptured((err, target, info) => {\n  nuxtApp.hooks.callHook(\"vue:error\", err, target, info).catch((hookError) => console.error(\"[nuxt] Error in `vue:error` hook\", hookError));\n  if (import.meta.client && BOT_RE.test(navigator.userAgent)) {\n    nuxtApp.hooks.callHook(\"app:error\", err);\n    console.error(`[nuxt] Not rendering error page for bot with user agent \\`${navigator.userAgent}\\`:`, err);\n    return false;\n  }\n  if (import.meta.server || isNuxtError(err) && (err.fatal || err.unhandled)) {\n    const p = nuxtApp.runWithContext(() => showError(err));\n    onServerPrefetch(() => p);\n    return false;\n  }\n});\nconst islandContext = import.meta.server && nuxtApp.ssrContext.islandContext;\n</script>\n","import { createApp, createSSRApp, nextTick } from \"vue\";\nimport \"#build/fetch.mjs\";\nimport \"#build/global-polyfills.mjs\";\nimport { applyPlugins, createNuxtApp } from \"./nuxt.js\";\nimport { createError } from \"./composables/error.js\";\nimport \"#build/css\";\nimport plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport { appId, appSpaLoaderAttrs, multiApp, spaLoadingTemplateOutside, vueAppRootContainer } from \"#build/nuxt.config.mjs\";\nlet entry;\nif (import.meta.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (error) {\n      await nuxt.hooks.callHook(\"app:error\", error);\n      nuxt.payload.error ||= createError(error);\n    }\n    if (ssrContext?._renderResponse) {\n      throw new Error(\"skipping render\");\n    }\n    return vueApp;\n  };\n}\nif (import.meta.client) {\n  if (import.meta.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  let vueAppPromise;\n  entry = async function initApp() {\n    if (vueAppPromise) {\n      return vueAppPromise;\n    }\n    const isSSR = Boolean(\n      (multiApp ? window.__NUXT__?.[appId] : window.__NUXT__)?.serverRendered ?? (multiApp ? document.querySelector(`[data-nuxt-data=\"${appId}\"]`) : document.getElementById(\"__NUXT_DATA__\"))?.dataset.ssr === \"true\"\n    );\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    async function handleVueError(error) {\n      await nuxt.callHook(\"app:error\", error);\n      nuxt.payload.error ||= createError(error);\n    }\n    vueApp.config.errorHandler = handleVueError;\n    nuxt.hook(\"app:suspense:resolve\", () => {\n      if (vueApp.config.errorHandler === handleVueError) {\n        vueApp.config.errorHandler = void 0;\n      }\n    });\n    if (spaLoadingTemplateOutside && !isSSR && appSpaLoaderAttrs.id) {\n      nuxt.hook(\"app:suspense:resolve\", () => {\n        document.getElementById(appSpaLoaderAttrs.id)?.remove();\n      });\n    }\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      handleVueError(err);\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(vueAppRootContainer);\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      handleVueError(err);\n    }\n    return vueApp;\n  };\n  vueAppPromise = entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n    throw error;\n  });\n}\nexport default (ssrContext) => entry(ssrContext);\n"],"version":3}